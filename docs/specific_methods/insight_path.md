# Insight path

	- with a path relating three objects (a, b, c):
		a    b   c
		   \
		a(x) b   c
			   /
		a(x) b   c (2X)

		- each operation function has a 'reason' such as a 'need' or 'intent': 
			- "a needs an x & b has a function y which outputs an x, so a does y on b to get x"
			- "c needs its property X to be larger so combine with b, which also has property X, where the combine operation is cooperative & doesnt take X away from b"
	- the insight path can be represented as:
		- a set of functions/patterns operating on objects/types
		- where insight components are replaceable with:
			- object metadata:
					- dependencies
					- attributes
					- type_stack
					- alternatives/approximations/antagonists
					- input_variables/output_variables
					- intents/functions/core_functions
				- where dependencies are:
					- source/target objects (receive input from, give output to) 
					- hierarchical objects (objects that generate & objects generated by)
			- an approximation of any of the above
			- a combination of any of the above (operations + inputs, operation function types + input source objects)
			- a generator function to create a random example of an object or object metadata, restricted by params:
				generate(object(type="person"))
				generate(object(type="function", attributes="no(side_effects)", inputs="dataset", outputs="correlations"))
				generate(object(variance=[3x5])), where 3 is the number of variables and 5 is the sum of their variance scores, 5 being the largest
				generate(metadata(type_stack=['species', 'canine', 'chihuahua']))
			

	- Example: 

		A specific rule set representing a simplistic system in a problem space, mimicking the above rule set:

			doctor    					 			patient   					drug

			  				ask

			doctor(patient.symptom_info) 			patient   					drug

				   												drug.molecule.share_electron(patient.component="bloodstream".molecule(attribute.bond="covalent").electrons)

			doctor(patient.symptom_info) 			patient   					drug.molecule.electrons(2e)

		1. "the doctor asks the patient to get the symptom info"
		2. "the drug needs an electron to work so it shares one with a molecule the patient's system produces"

		The insights that are stored in an insight path would include:
			- "doctor ask patient to get info" (get_types, None, get_types, None, get_types) # no operations done on functions, just objects
			- "x ask y to get info" (get_vars, None, get_vars, None, get_types)
			- "person ask person to get symptoms" 
				(a doctor type is person, a patient type is person, an info type is symptoms - for situations where a doctor isnt present)
			- "machine ask person to get info" (person alternative is machine)
			- "x ask y to do function get(implement, data, type)" 
				(function get(implement, data, type) is a function that gets information from data that fits the type)
			- "x ask y to do core_functions(find, match, implement, query, fit, equals)" 
				((find, match, implement, query, fit, equals) are the core functions necessary to build get()
			- "doctor ask assistant to get info"
				("assistant" is a source dependency of "patient" bc the patient becomes relevant to the doctor bc of the "assistant")
			- "machine ask patient to get info"
				("machine" is a target dependency of "doctor" bc the doctor enters the info into the machine)
				- note we can get to this insight by various paths, 
					as reflected in "machine ask person to get info" above, which varies only by type(patient) = person
					which we got to using the types of all objects, then using the alternative of a person (machine)
			- and so on until youve covered all the patterns producible from the dependencies, attributes, types, alternative vars, functions, core functions

		Youd ideally store each insight with the functions used to generate it, in the same order as objects & functions in the rule:
			functions = [get_types, None, get_types, None, get_types]
		in case you want to try to derive the original rule from the insight & its generating functions.

		The insight path itself would be:

			- any combination of these insights that fits into the 3-step rule set above
			- any combination of these insights that fits into a subset, transform, combination, alternative, or approximation of the 3-step rule set above
				- this is bc the rule set can be modified by operations inherent to the rule set to derive other insights, 
				  without logically violating the objects' & functions' rules
				- these inherent operations include:
					- core_functions & functions of rules in the set
					- standard abstract operations (get_type, get_example)
					- conceptual abstract operations, like merge(intent1, intent2):
						def merge(a,b):
							if a.prop.intent == (-1 * b.prop.intent):
								merge_operation.conflicts.add('opposite_intent', a.prop.intent, b.prop.intent)
								# check if this conflict neutralizes a function of either object

			- it might seem best to store an insight path only if its logically consistent 
			  & doesnt violate standard & conceptual operations that hold in the original rule set,
			  but if its abstracted at all, other rules can apply:
			  - when you change "doctor" to "x", then personal interaction rules dont apply because x could be a machine

			- however there are filters that apply for:

				- an insight:
					- it must explain the rule interaction accurately

				- an insight to be part of an insight path:
					- it must contribute to the explanation of how an origin object of a possible route in the rule set gets to its target object
						- for trees, the routes go in one direction, so it's a clear matter of:
						  "explain how the top node gets to the bottom node, which this insight interacts with"
						- for other structures like networks, it may be a more complex route from start to finish of any given path in the network

				- ideally each insight would contribute more than other insights considered, 
					so there should be a "best-fit" insight path composed of the "best-fitting" insights,
					as well as a stack of other explanatory insight paths,
					such as an "abstract" insight path composed entirely of abstract insights,
					containing no specific information except core-function versions of objects & functions, 
					for example the abstract core-function decomposition of "machine" may be any of these depending on context like intent:
					  	- information-storage unit (intent="store")
					  	- operation-executor unit (intent="run_tasks")
					  	- experience unit (intent="entertainment")
					  	- communication unit (intent="interact")
					so the insights containing "machine" would be considered abstract if they had this replacement done

				- the full stack of insight paths can include:
					- an abstract insight path
					- a best-fit insight path
					- a most-efficient insight path
					- a most-reusable insight path (has objects in common with many other systems)

		Then you could apply the generated insight paths from a rule set to a new system's rule set with similar dynamics, 
			as determined by the number of matching insights in the new rule set.
