python study guide

- questions
	- AML typologies
	- db normalization
	- data buffer
	- python OOP
	- how to use python given limited memory
	- heap memory
	- garbage collection
	- detect a memory leak
	- whats the difference between python and java
	- whats the difference between an interface and an abstraction
	- what is the difference between a stack and a queue
	- describe recursion
	- Usage of circuit breaker in microservices
	- SOLID concepts
	- how to optimize sql queries
	- thread-safe
	- mutable structures are passed by reference, immutable structures are passed by value
	- python is dynamically typed
	- python compiles code to bytecode which is then executed by the python virtual machine and interpreted at runtime
	- encapsulation
	- polymorphism
	- __init__.py (for shared functions and variables across the package)

- libraries/tools
	- black for formatting
	- pylint/flake8 for PEP compliance
	- security testing
		- bandit identifies injection attack vectors, cryptographic flaws, security misconfigurations, and credential management issues but cant do taint analysis (data flow issues)
		- pyt (pytaint) identifies XSS, SQL injections, path traversal attacks
		- pysa improves on static analysis with data dependency and code context awareness to implement taint analysis and avoid false positives, identifying issues like XSS, SQL injections, path injections, OS command executions
	- pytest or unittest for unit testing
	- cprofile and line_profiler and memory_profiler for profiling
	- pdb for debugging
	- mypy for linting/static analysis
		- static analysis identifies bugs in code without being run like XSS and SQL injection attack vectors, authentication bypass issues, and abstract injection points but can identify false positives
	- dynamic analysis
		- dynamic analysis is done on running apps but misses untested flows
	- interactive analysis
		- interactive analysis combines static flaws with limited attacks, identifying for example authentication bypass issues and testing the login endpoint with sample parameters, but requires manual testing expertise to be valuable
	- pentesting
	- regression testing

- design patterns
	- creational design patterns help make a system independent of how its objects are created, composed, and represented
		- factory method: this pattern is useful to separate the construction of an object from its implementation, so objects can be created without having to define the exact class of object to be created
			- Factory easily adds new class types without changing existing code, avoids tight coupling between sub-classes/objects and creator classes/objects
			- But the client might have to sub-class the creator class and might create a large number of files
			- replaces the object construction calls with calls to the factory method
			- allows an interface or a class to create an object, but lets subclasses decide which class to instantiate
			- creates objects without exposing logic to the client and uses the same interface to create new objects
		- abstract factory method: another layer of abstraction over the factory pattern, which works with a super-factory that creates other factories
			- allows creating families of related objects without specifying their concrete classes, creating a similar type of many objects
			- provides a way to encapsulate a group of individual factories
			- replaces object construction calls with calls to the abstract factory method
			- useful when client doesnt know which type to create, makes it easy to introduce new variants of classes without breaking existing code, and classes created from the factory are compatible
			- But if there are a lot of classes code can become complex and create a large number of files
		- singleton method: the singleton pattern guarantees that a class has just one instance and offers a way to access it globally
			- a way to provide one and only one object of a type like a database connection which should only have one instance at a time
			- Borg singletons allow multiple instances with shared state
			- Double checked locking singleton only assigns a lock using the getinstance method when the object is None
			- classic singleton method uses the static method for creating the getinstance method to return the shared resource
			- the virtual private constructor __init__ can be used to raise an exception although its not required
			- an object created with singleton is initialized only when requested for the first time, and it grants global access to the instance of the object, and method classes cant have more than one instance
			- But it's difficult to use singletons in a multithread environment bc we have to guarantee that the multiple threads cant create a singleton object more than once, and singleton doesnt follow the single responsibility principle bc it solves multiple problems at once, and singleton makes unit testing harder by introducing global state
			- singleton is recommended where control over global variables is important and is often used in logging, caching, thread pools, and configuration settings and often used with the factory method
		- prototype method: allows hiding complexity of making new instances from the client, copying an existing object rather than creating a new instance
			- enables creating new objects by cloning existing objects (making the existing cloned object the prototype), which is efficient when the cost of creating a new object is high and when an object's initial state or configuration is complex
			- includes:
				- the prototype interface or abstract class that declares methods for cloning objects, defining the common interface that concrete prototypes have to implement so all prototypes can be cloned consistently, declaring the clone method to produce copies of the prototype
				- concrete prototypes is a class that implements the prototype interface or extends the abstract class, and is the class of the specific type of object being cloned, defining the details of how cloning should happen for instances of that class and implementing the clone method for specific cloning logic for that class
				- client is the code that requests the creation of new objects by interacting with the prototype, initiating the cloning process without being aware of the concrete classes involved
				- clone method is declared in the prototype interface or abstract class, and implemented in concrete prototypes to define specific cloning logic, describing how the object's internal state should be duplicated to create new independent instances
			- use the prototype method when creating objects is more costly or complex than copying existing ones, when objects need to vary slightly without justifying a whole set of alternate classes, when the system requires dynamic configuration and you want to create objects with configurations at runtime so prototyping a base configuration and cloning it would be useful, and when you want to reduce the cost of initializing an object
			- dont use the prototype method when object instances are unique and implementing the pattern costs more than it benefits, when object creation is simple and doesnt consume a lot of resources and there is no object variation required, when objects are immutable which are often safely shared without requiring cloning, when the object creation process is easy to understand and manage, when there are only a few variations of objects and creating subclasses or instances with specific configurations is easy
		- builder method: used to separate construction of a complex object from its representation so the same construction process can create different representations, helping construct a complex object step by step in which the final step returns the object
			- allows using the same construction code to create different types and representations of the object easily, designed to provide flexibility to solutions to various object creation problems
			- allows separating business logic and the complex construction code, and constructs objects step by step, allows deferring construction steps, allows calling steps recursively, prevents the client from fetching incomplete data bc it doesn't allow exposing an unfinished object, is useful when constructing various representations of the class involves similar steps that vary in details, in which case the base builder interface defines the construction steps while these steps are implemented by concrete builders
			- But increases code complexity bc it requires creating multiple new classes, requires the builder class to be mutable, and data members of the class arent guaranteed to be initialized
	
	- structural design patterns use inheritance to compose interfaces or implementations, solving problems of composing classes and objects into larger structures which are flexible and efficient
		- adapter method: converts the interface of a class into another interface expected by the client, letting classes work together that couldnt otherwise bc of incompatible interfaces
			- helps make incompatible objects adaptable to each other by creating a connection between two incompatible interfaces, providing a different interface for a class, thereby enabling integration of classes that were previously incompatible
			- the client requests to the adapter using the target interface, the adapter translates the request to the adaptee interface, then the result of the call is received by the client
			- for example, the adapter passes arguments like functions/attributes with different names by using the same parameter, so that same parameter can be used to access the function/attribute instead of the different function/attribute names
			- the adapter achieves single responsibility bc it separates specific code from primary logic of the client
			- the adapter is flexible and allows code reusability
			- the client class is not required to use a different interface thereby allowing the client to remain simple and we can use polymorphism to swap between different implementations of adapters
			- the new adapter classes can be introduced without violating the open/closed principle
			- But the adapter increases complexity of the code and requires many adaptation with the adaptee chain to reach the compatibility that we want
			- adapter is used when we want to make certain classes communicate
			- when we want to reuse some piece of code like interfaces that lack some functionality, the adapter method is used
		- bridge method: allows abstraction and implementation to be developed independently, so the client code can access the abstraction part without accessing the implementation part
			- allows separating implementation-specific abstractions and implementation-independent abstractions so they are developed as single entities, useful for organizing the class hierarchy
			- the abstraction provides the reference to the implementer
			- the refined abstraction extends the abstraction to a new level where it takes the specific details one level above and hides the specific elements from the implementers
			- the implementer defines the interface for implementation classes, which doesnt need to correspond directly to the abstraction interface and can therefore be very different
			- concrete implementation: the concrete implementation implements the above implementer
			- the implementation-specific abstractions are separated from the class with the implementation-independent abstractions, such as by passing the implementation-specific abstraction as a parameter to the class with the implementation-independent abstractions
			- the bridge method follows the single responsibility principle bc it separates abstractions from their implementation so the abstraction and implementation can vary independently
			- bridge doesnt violate the open/closed principle bc at any time, we can introduce the new abstractions and implementations independently from each other
			- bridge can be used to implement platform-independent features
			- But the bridge method is complex bc it introduces new abstraction classes and interfaces, and might negatively impact performance bc the abstraction has to pass messages along with the implementation for the operation to be executed, and is difficult to manage with many interfaces
			- the bridge method provides run-time binding of an implementation (run-time binding is what we can call a method at run-time instead of compile-time)
			- the bridge method is used to map independent class hierarchies
		- composite method: a partitioning design pattern which characterizes a collection of items that are handled the same as a single instance of that type of object, with intent to compose objects into tree structures to represent part-whole hierarchies
			- composite method describes a group of objects that is treated the same way as a single instance of the same type of object, with intent to compose objects into tree type structures to represent the whole-partial hierarchies
			- composite method allows composing objects into the tree structure and then allows working with tree structures as an individual object
			- the operations that can be performed on all the composite objects often have the least common denominator relationship
			- component: helps implement default behavior for the interface common to all classes, declaring the interface of the objects in the composition and for accessing and managing its child components
			- leaf: defines behavior for primitive objects in the composition, representing the leaf object
			- composite: stores the child component and implements child related operations in the component interface
			- client: manipulates objects in the composition through the component interface
			- the composite method is used when there are composites that contain components, each of which could be a composite
			- the composite method follows the open/closed principle bc the introduction of new elements, classes, and interfaces is allowed into the application without breaking the existing code of the client
			- the composite method allows consuming less memory bc it creates less objects and it has improved execution time by sharing objects, and is flexible by providing flexibility of structure as it defines class hierarchies with primitive and complex objects
			- But it makes it harder to restrict the type of components of a composite, and is not useful when representing a full or partial hierarchy of objects is not needed, and produces the general tree once the tree structure is defined, and depends on run-time checks to apply constraints bc it doesnt allow using the type system of the language
			- composite is preferred when producing a nested tree structure is required, and allows organizing structures with common operations so the structures can be handled in the same way
		- decorator method: allows dynamically adding functionality to an object without affecting the behavior of other existing objects within the same class, using inheritance to extend the behavior of the class which takes place at compile-time so all the instances of that class get the same extended behavior
			- allows functionality to be added to individual objects dynamically without affecting the functionality of other objects from the same class, which involves decorator classes which wrap concrete components
			- promotes flexibility and extensibility by allowing composing objects with different combinations of functionality at runtime
			- follows the open/closed principle since new decorators can be added without modifying existing code
			- decorators are used where a variety of optional features need to be added in a flexible and reusable manner
			- add additional functionality like cross-cutting variables such as logging, profiling, caching, error handling or authentication without modifying core logic
			- component interface: an abstract class or interface that defines the common interface for the concrete components and decorators, specifying the operations that can be applied to the objects
			- concrete component: these are the basic objects or classes that implement the component interface, they are the objects to which new behavior is added
			- decorator: an abstract class that also implements the component interface and has a reference to a component object, responsible for adding new behaviors to the wrapped component object
			- concrete decorator: these are the concrete classes that extend the decorator class, adding specific behaviors to the component, where each concrete decorator can add one or more behaviors to the component
			- unlike traditional inheritance which can lead to a deep and inflexible class hierarchy, the decorator pattern uses composition, allowing composing objects with different decorators to add the necessary functionality, which avoids the disadvantages of inheritance like tight coupling and rigid hierarchies
			- decorators allow dynamic behavior modification by allowing application or removal at runtime, which is useful to change object behavior based on changing requirements or user preferences
			- allows clear code structure
			- decorators can add complexity, increase the number of classes, increase requirements like managing the correct order of decorators, and overusing decorators is a complicating factor
		- facade method: provides a unified interface to a set of interfaces in a subsystem, defining a high-level interface that makes the subystem easier to use
			- helps reduce dependencies between clients and a system, making code more modular and understandable, allows hiding complexities of a system and offering a simpler way to interact with the system, enhancing maintainability and scalability
			- structuring a system into subsystems helps reduce complexity
			- minimizing the communication and dependencies between subsystems is useful
			- one way to minimize communication/dependencies between subsystems is a facade object that provides a simple interface to other functions of a subsystem
			- facade: a single class that provides a simple interface to a complex subsystem, which delegates client requests to the appropriate subsystem objects without exposing the underlying complexity
			- subsystem classes: classes that do the work of the system, which provide the actual functionality, which are not directly accessible by clients but are used by the facade
			- client: entity that interacts with the subsystem through the facade by making requests to the facade
			- used to simplify complex system, promote loose coupling, hide implementation details, improve code readability and maintainability, implement layers like the business logic layer and hiding the complexities of data access and processing layers, and manage legacy code
			- avoid the facade if abstraction is unnecessary, if direct access to subsystems is needed, to avoid performance hits by adding extra layers of method calls, when subsytems are simple, and when the facade is tightly coupled with client code so making changes to subsystems requires making changes to the facade and client, which defeats the purpose of decoupling, so that the facade becomes a bottleneck for changes and updates which hinders system flexibility
		- flyweight method: provides ways to decrease object count thereby improving applications' required objects structure, used to create a large number of similar objects
			- minimizes object count required at run-time, creating a flyweight object that is shared by multiple contexts, created to be indistinguishable from normal objects
			- flyweight objects are immutable
			- to implement flyweight, dictionaries store references to the objects that are already created
			- fewer objects reduce memory usage and reduces object creation time by sharing objects or sharing common parts of objects
			- flyweight uses less RAM, improves data caching for fast response time, and improves performance bc it uses less heavy objects
			- But flyweight breaks encapsulation by moving state outside the object which is less efficient, and flyweight complicates code
			- flyweight saves space when the application is independent of the object created, and reduces cost in terms of space and time complexity
		- proxy method: also called surrogates, handles, and wrappers, closely related in structure but not intent to adapters/decorators
			- allows providing a replacement for another object, using different classes to represent functionality of another class, creating an object having the original object functionality
			- proxy method controls and manages access to the object being protected
			- for example the proxy method can avoid multiple database connections, by making one proxy connection to the database which handles multiple queries
			- the proxy method follows the open/closed principle bc new proxies are easily introduced without changing client code
			- the proxy works even when the service object is not ready or not available, and the proxy method also provides security and increases performance by avoiding duplication of objects that can be large and memory intensive
			- But the proxy might create slow responses, and introduces another layer of abstraction which is a problem if the protected code is accessed directly by some clients and some of them use the proxy class, and increases complexity by introducing a lot of new classes
			- a virtual proxy is used in databases, a protective proxy creaets a protective layer over the application, a remote proxy is used when the service object is located on a remote server so the proxy passes the client request over the network, and a smart proxy provides additional security to the application by intervening with specific actions when the protected object would be accessed
	
	- behavioral design patterns relate to algorithms and the assignment of responsibilities between objects, describing not just patterns of objects or classes but the patterns of their communication, characterizing complex control flow that's difficult to follow at run-time
		- chain of responsibility method: used for loose coupling where a request from the client is passed to a chain of objects to process the request, and later the objects in the chain will decide who will be processing the request and whether the request needs to be sent to the next object in the chain
		- command method: a transforms a request into an independent object with all of the information requested, an object which can be passed around, stored, and executed at a later time
		- interpreter method: used to define a grammatical representation for a language and provides an interpreter to deal with this grammar
		- mediator method: enables decoupling of objects by introducing a layer in between so the interaction between objects happen with the layer
		- memento method: used to return an object's state to its initial state, enabling creating checkpoints in an application and returning to these checkpoints at a later time
		- observer method: establishes a one to many dependency between objects, meaning all the dependents (observers) of the subject are immediately updated and notified when the subject changes
		- state method: where an object modifies its behavior according to its internal state, where if we have to change the behavior of an object based on its state, we can use a state variable in the object and an if-else condition to perform different actions based on the state
		- strategy method: selecting an object's behavior at runtime, involving encapsulating a family of algorithms into distinct classes that each implement a common interface
		- template method: defines an algorithm as a collection of skeleton operations where the child classes handle the implementation of the specifics and the parent class maintains the overall structure and flow of the algorithm
		- visitor method: used to perform an operation on a group of a similar kind of Objects, enabling moving the operational logic from the objects to another class

- version updates
	- 3.14: deferred evaluation of annotations, template strings, improved error messages, a tail-call-compiled interpreter, a C API for python runtime configuration
	- 3.13: advanced interactive interpreter, JIT compiler, and a free thread mode
	- 3.12: enhanced error messages, flexible f-strings, type parameter syntax, module improvement, syntactic formalization of f-strings
	- 3.11: enhanced performance by 10 - 60%, improved error messages, exception groups, exception notes
	- 3.10: parenthesized context managers, pattern matching for complex data structures
	- 3.9: offered string methods, dictionary merge and update operators, pattern matching zoneinfo, improved type hinting
	- 3.8: new optimizations and features like positional-only parameters and the walrus operators
	- 3.7: improved performance, data classes to generate __init__ and __repr__ in classes, context variables to manage context-local state
	- 3.6: formatted string literals, asynchronous generators, underscores in numeric literals
	- 3.5: type hints/annotations to function arguments and return values, added async, await
	- 3.4: asyncio and pathlib
	- 3.0: erased redundant constructs from 2.7, new syntax and semantics, removal of deprecated features, print function
	- 2.7: improved syntax, set literals, ordered dictionaries
	- 2.0: list comprehensions and garbage collection
	- 1.5: unicode support, enhanced standard library, facilitated internationalization
	- 1.0: exception handling, map, filter, reduce, improved code error management and exceptions

- optimizations
	- address reasons for bottlenecks (inefficient algorithms with polynomial runtime, memory consumption, IO operations, Global Interpreter Lock which limits concurrent execution)
		- use cprofile (cprofile.run('function_name')) and line_profiler and memory_profiler and timeit for timing function calls and pytest-benchmark for identifying bottlenecks
		- use pypy for JIT compilation
		- use dicts instead of lists for lookup operations
		- use list comprehensions which are faster than loops for creating a list
		- use map function which is faster than list comprehensions for function calls and large datasets: map(lambda x: x * x, range(1000000)) instead of [x * x for x in range(1000000)]
		- use zip function to iterate two lists of equal size
		- work around the GIL to use multiple CPU cores and run multiple tasks simultaneously
			- use multiprocessing to create separate processes with their own memory space, bypassing the GIL which is useful for CPU bound tasks
				with multiprocessing.Pool(processes=4) as pool:
					results = pool.map(square_function, range(10))
			- use asyncio for IO tasks like HTTP requests or database queries to perform concurrent tasks without blocking the main thread
			- use python 3.13 which comes with free thread mode
			- use multi-threading
			- use coroutines to create concurrent asynchronous code in python to perform multiple tasks simultaneously by creating simple lightweight threads
		- use scipy and numpy (implemented in c) for numerical operations which is much faster than lists for large-scale numerical operations
		- use JIT compilation with numba which automatically compiles the function to machine code which boosts performance
			from numba import jit
			@jit(nopython=True)
	- use match-case rather than if-else
	- use built-in functions which are usually optimized for speed and are often written in C
	- write generators to return one item at a time rather than all items at once
	- check membership of an item in a list with the in keyword
	- load modules only when needed
	- avoid recursion which takes up a lot of memory and instead use iteration
	- use cython (a superset of python) to speed up slow code, cython is compiled into c which makes it faster
		save file with pyx extension and use cythonize command on the file to compile it, after which it can be imported and used like a normal function
	- use vectorized operations and broadcasting
	- use pandas to manipulate data which is faster than standard python data structures
	- use sets and unions instead of loops where possible
	- use multiple assignment when possible
	- avoid global variables to help keep track of scope and avoid unnecessary memory usage, also local variables are faster to retrieve than global variables
	- use join rather than + to concatenate strings whch avoids creating a new string for each component
	- use while 1 for infinite loops
	- exit early (raise exceptions or exit first under failure conditions where possible to avoid executing code that will fail)
	- use itertools for combinations/permutations
	- use memoization like decorator caching such as with @functools.lru_cache(maxsize=100)
	- use keys for sorts using operator.itemgetter()
	- dont use sets for conditions like checking membership of an item in a list
	- use linked lists which allocate memory as needed, each item in a linked list can be stored in a different location, although lookup times are slower in linked lists, linked lists are faster at adding elements at the start of the linked list
	- use numpy arrays instead of lists for large data bc numpy arrays use less memory and are faster
	- use sets to check if an item is in a group of items, dicts to efficiencly store and retrieve data, and tuples to group values together
	- use lazy loading of data to only load data when needed
	- use hdfs or parquet formats to save data on disk and load only the parts that are needed
	- use memory_profiler or psutil to identify memory leaks

- other tips
	- use context managers to handle resources (files, sockets, db connections) in an efficient way by defining a context in which a resource is used and automatically open and close the resource
	- use try-except blocks to handle exceptions rather than failing
	- group errors with ExceptionGroup to handle them all at once
	- use the traceback module to see detailed error info
	- use TaskGroups to run similar tasks together as opposed to asyncio.gather which fails on the first exception
	- use decimal instead of float for calculations
	- use f"{value:.2f}" to control decimal places
	- use math module for square roots, logs, and trig functions
	- use numpy for faster, more complex operations like matrix operations, fourier transforms and statistical operations
	- use scipy for scientific operations, signal processing, optimization, interpolation, and integration

- handlers for security bugs
	- cross site scripting
	- log injection
	- sql injection
		- use parameterized sql queries instead of string building
	- security tips
		- hash and salt passwords with bcrypt
		- set strict access controls
		- monitor query performance
		- log suspicious patterns
		- use environment variables for configuration
		- use structured logging, gitignore logs, use logging level control, and avoid logging sensitive data
		- minimize dependencies
		- use precommit hooks with security scanning tools
		- use standard auth libraries like requests-oauthlib or Flask-Login
		- apply session management to expire tokens/sessions, rate limit API requests, and validate emails
		- use whitelists to support valid requests
		- use prepared statements to send a query template and then send the values for fields in the template
		- check hashes of downloads
		- have a secure backup strategy in case of database corruption or sql injection attacks
		- move credentials to .env files
		- use secret managers in prod
		- gitignore configuration files
		- patch dependencies regularly
		- rotate keys regularly
		- handle cookies securely
		- set up Cross-Site Request Forgery (CSRF) protection by using flask_wtf to use unpredictable CSRF tokens in forms which are verified by servers when requests are made, so that valid requests cant be forged
		- keep tokens private
		- use APIs securely
		- use secure libraries
		- use SAST (bandit, veracode) and DAST tools (burpsuite, OWASP zed attack proxy, arachni)
		- use SSL/TLS connections, enforce HTTPS to protect against MITM attacks
		- avoid using root access
		- set file permissions (0 = none, 1 = x, 2 = w, 3 = w/x, 4 = r, 5 = r/x, 6 = r/w, 7 = r/w/x)
		- avoid eval() (use ast.literal_eval()), compile(), exec(), input() without validation, pickle.loads(), subprocess.call() with shell=True
		- validate character encoding (unicode, ascii) or character sets and input length
		- use type annotations and linters to check types
			- for example, use the Literal type annotation to validate a string matches items in a static list and use type checking tools like linters to check that type annotations are followed
		- deserialize with caution
			- the pickle module is insecure, where a better alternative is json or PyYAML which allows serialization/deserialization to/from YAML, which should be used with yaml.SafeLoader to avoid attack vectors even though it cant load custom classes
			- use defusedxml to avoid xml security issues like DOS attacks or external entity expansion where an external source is referenced
		- sanitize external data
			- schema is a library that validates data structures like from config files, forms, external services or command line parsing or converted from JSON/YAML to python data types
			- bleach is a library that escapes or strips markup and attributes
			- jinja is a templating engine that auto-escapes to prevent XSS using markupsafe
			- use named parameters to prevent SQL injections instead of building a query string, or use object relationship mapping (ORM) tools like sqlalchemy
		- download packages cautiously
			- check package names for typos and check snyk advisor or use safety CLI or install pip audit or check github issues/dependabot alerts for known security issues with packages
			- use pip freeze to record environment-specific package versions
			- keep dependencies updated to use code with latest security fixes
		- review dependency vulnerabilities and licenses
			- avoid GPL, AGPL, LGPL, and EPL and use code with permissive licenses (MIT, Apache, BSD) where possible
		- dont use the system python version which is unlikely to be current
		- use virtual environments with venv to isolate projects (including python versions used, libraries, and scripts)
		- set DEBUG=False in prod to avoid publishing overly informative error messages
		- format strings cautiously
			- use templating tools like string.template to format strings with parameters to avoid evaluating python statements like f-strings evaluate python statements

- sources
	https://www.geeksforgeeks.org/python/python-design-patterns/
	https://wpexperts.io/blog/python-version-history/
	https://snyk.io/blog/python-security-best-practices-cheat-sheet/
	https://securecodingpractices.com/python-secure-coding-best-practices/
	https://www.programmingworld.tech/blog/optimizing-python-code-for-performance-tips-and-tools