python study guide

- questions
	- AML typologies
	- db normalization
	- python OOP
	- how to use python given limited memory
	- heap memory
	- garbage collection
	- detect a memory leak
	- whats the difference between python and java
	- whats the difference between an interface and an abstraction
	- what is the difference between a stack and a queue
	- describe recursion
	- Usage of circuit breaker in microservices
	- SOLID concepts
	- how to optimize sql queries
	- thread-safe
	- mutable structures are passed by reference, immutable structures are passed by value
	- python is dynamically typed
	- python compiles code to bytecode which is then executed by the python virtual machine and interpreted at runtime
	- encapsulation
	- polymorphism
	- __init__.py (for shared functions and variables across the package)

- libraries/tools
	- black for formatting
	- pylint/flake8 for PEP compliance
	- security testing
		- bandit identifies injection attack vectors, cryptographic flaws, security misconfigurations, and credential management issues but cant do taint analysis (data flow issues)
		- pyt (pytaint) identifies XSS, SQL injections, path traversal attacks
		- pysa improves on static analysis with data dependency and code context awareness to implement taint analysis and avoid false positives, identifying issues like XSS, SQL injections, path injections, OS command executions
	- pytest or unittest for unit testing
	- cprofile and line_profiler and memory_profiler for profiling
	- pdb for debugging
	- mypy for linting/static analysis
		- static analysis identifies bugs in code without being run like XSS and SQL injection attack vectors, authentication bypass issues, and abstract injection points but can identify false positives
	- dynamic analysis
		- dynamic analysis is done on running apps but misses untested flows
	- interactive analysis
		- interactive analysis combines static flaws with limited attacks, identifying for example authentication bypass issues and testing the login endpoint with sample parameters, but requires manual testing expertise to be valuable
	- pentesting
	- regression testing

- design patterns
	- creational design patterns help make a system independent of how its objects are created, composed, and represented
		- factory method: this pattern is useful to separate the construction of an object from its implementation, so objects can be created without having to define the exact class of object to be created
			- Factory easily adds new class types without changing existing code, avoids tight coupling between sub-classes/objects and creator classes/objects
			- But the client might have to sub-class the creator class and might create a large number of files
			- replaces the object construction calls with calls to the factory method
			- allows an interface or a class to create an object, but lets subclasses decide which class to instantiate
			- creates objects without exposing logic to the client and uses the same interface to create new objects
		- abstract factory method: another layer of abstraction over the factory pattern, which works with a super-factory that creates other factories
			- allows creating families of related objects without specifying their concrete classes, creating a similar type of many objects
			- provides a way to encapsulate a group of individual factories
			- replaces object construction calls with calls to the abstract factory method
			- useful when client doesnt know which type to create, makes it easy to introduce new variants of classes without breaking existing code, and classes created from the factory are compatible
			- But if there are a lot of classes code can become complex and create a large number of files
		- singleton method: the singleton pattern guarantees that a class has just one instance and offers a way to access it globally
			- a way to provide one and only one object of a type like a database connection which should only have one instance at a time
			- Borg singletons allow multiple instances with shared state
			- Double checked locking singleton only assigns a lock using the getinstance method when the object is None
			- classic singleton method uses the static method for creating the getinstance method to return the shared resource
			- the virtual private constructor __init__ can be used to raise an exception although its not required
			- an object created with singleton is initialized only when requested for the first time, and it grants global access to the instance of the object, and method classes cant have more than one instance
			- But it's difficult to use singletons in a multithread environment bc we have to guarantee that the multiple threads cant create a singleton object more than once, and singleton doesnt follow the single responsibility principle bc it solves multiple problems at once, and singleton makes unit testing harder by introducing global state
			- singleton is recommended where control over global variables is important and is often used in logging, caching, thread pools, and configuration settings and often used with the factory method
		- prototype method: allows hiding complexity of making new instances from the client, copying an existing object rather than creating a new instance
			- enables creating new objects by cloning existing objects (making the existing cloned object the prototype), which is efficient when the cost of creating a new object is high and when an object's initial state or configuration is complex
			- includes:
				- the prototype interface or abstract class that declares methods for cloning objects, defining the common interface that concrete prototypes have to implement so all prototypes can be cloned consistently, declaring the clone method to produce copies of the prototype
				- concrete prototypes is a class that implements the prototype interface or extends the abstract class, and is the class of the specific type of object being cloned, defining the details of how cloning should happen for instances of that class and implementing the clone method for specific cloning logic for that class
				- client is the code that requests the creation of new objects by interacting with the prototype, initiating the cloning process without being aware of the concrete classes involved
				- clone method is declared in the prototype interface or abstract class, and implemented in concrete prototypes to define specific cloning logic, describing how the object's internal state should be duplicated to create new independent instances
			- use the prototype method when creating objects is more costly or complex than copying existing ones, when objects need to vary slightly without justifying a whole set of alternate classes, when the system requires dynamic configuration and you want to create objects with configurations at runtime so prototyping a base configuration and cloning it would be useful, and when you want to reduce the cost of initializing an object
			- dont use the prototype method when object instances are unique and implementing the pattern costs more than it benefits, when object creation is simple and doesnt consume a lot of resources and there is no object variation required, when objects are immutable which are often safely shared without requiring cloning, when the object creation process is easy to understand and manage, when there are only a few variations of objects and creating subclasses or instances with specific configurations is easy
		- builder method: used to separate construction of a complex object from its representation so the same construction process can create different representations, helping construct a complex object step by step in which the final step returns the object
			- allows using the same construction code to create different types and representations of the object easily, designed to provide flexibility to solutions to various object creation problems
			- allows separating business logic and the complex construction code, and constructs objects step by step, allows deferring construction steps, allows calling steps recursively, prevents the client from fetching incomplete data bc it doesn't allow exposing an unfinished object, is useful when constructing various representations of the class involves similar steps that vary in details, in which case the base builder interface defines the construction steps while these steps are implemented by concrete builders
			- But increases code complexity bc it requires creating multiple new classes, requires the builder class to be mutable, and data members of the class arent guaranteed to be initialized
	
	- structural design patterns use inheritance to compose interfaces or implementations, solving problems of composing classes and objects into larger structures which are flexible and efficient
		- adapter method: converts the interface of a class into another interface expected by the client, letting classes work together that couldnt otherwise bc of incompatible interfaces
		- bridge method: allows abstraction and implementation to be developed independently, so the client code can access the abstraction part without accessing the implementation part
		- composite method: a partitioning design pattern which characterizes a collection of items that are handled the same as a single instance of that type of object, with intent to compose objects into tree structures to represent part-whole hierarchies
		- decorator method: allows dynamically adding functionality to an object without affecting the behavior of other existing objects within the same class, using inheritance to extend the behavior of the class which takes place at compile-time so all the instances of that class get the same extended behavior
		- facade method: provides a unified interface to a set of interfaces in a subsystem, defining a high-level interface that makes the subystem easier to use
		- flyweight method: provides ways to decrease object count thereby improving applications' required objects structure, used to create a large number of similar objects
		- proxy method: also called surrogates, handles, and wrappers, closely related in structure but not intent to adapters/decorators
	
	- behavioral design patterns relate to algorithms and the assignment of responsibilities between objects, describing not just patterns of objects or classes but the patterns of their communication, characterizing complex control flow that's difficult to follow at run-time
		- chain of responsibility method: used for loose coupling where a request from the client is passed to a chain of objects to process the request, and later the objects in the chain will decide who will be processing the request and whether the request needs to be sent to the next object in the chain
		- command method: a transforms a request into an independent object with all of the information requested, an object which can be passed around, stored, and executed at a later time
		- interpreter method: used to define a grammatical representation for a language and provides an interpreter to deal with this grammar
		- mediator method: enables decoupling of objects by introducing a layer in between so the interaction between objects happen with the layer
		- memento method: used to return an object's state to its initial state, enabling creating checkpoints in an application and returning to these checkpoints at a later time
		- observer method: establishes a one to many dependency between objects, meaning all the dependents (observers) of the subject are immediately updated and notified when the subject changes
		- state method: where an object modifies its behavior according to its internal state, where if we have to change the behavior of an object based on its state, we can use a state variable in the object and an if-else condition to perform different actions based on the state
		- strategy method: selecting an object's behavior at runtime, involving encapsulating a family of algorithms into distinct classes that each implement a common interface
		- template method: defines an algorithm as a collection of skeleton operations where the child classes handle the implementation of the specifics and the parent class maintains the overall structure and flow of the algorithm
		- visitor method: used to perform an operation on a group of a similar kind of Objects, enabling moving the operational logic from the objects to another class

- version updates
	- 3.14: deferred evaluation of annotations, template strings, improved error messages, a tail-call-compiled interpreter, a C API for python runtime configuration
	- 3.13: advanced interactive interpreter, JIT compiler, and a free thread mode
	- 3.12: enhanced error messages, flexible f-strings, type parameter syntax, module improvement, syntactic formalization of f-strings
	- 3.11: enhanced performance by 10 - 60%, improved error messages, exception groups, exception notes
	- 3.10: parenthesized context managers, pattern matching for complex data structures
	- 3.9: offered string methods, dictionary merge and update operators, pattern matching zoneinfo, improved type hinting
	- 3.8: new optimizations and features like positional-only parameters and the walrus operators
	- 3.7: improved performance, data classes to generate __init__ and __repr__ in classes, context variables to manage context-local state
	- 3.6: formatted string literals, asynchronous generators, underscores in numeric literals
	- 3.5: type hints/annotations to function arguments and return values, added async, await
	- 3.4: asyncio and pathlib
	- 3.0: erased redundant constructs from 2.7, new syntax and semantics, removal of deprecated features, print function
	- 2.7: improved syntax, set literals, ordered dictionaries
	- 2.0: list comprehensions and garbage collection
	- 1.5: unicode support, enhanced standard library, facilitated internationalization
	- 1.0: exception handling, map, filter, reduce, improved code error management and exceptions

- optimizations
	- address reasons for bottlenecks (inefficient algorithms with polynomial runtime, memory consumption, IO operations, Global Interpreter Lock which limits concurrent execution)
		- use cprofile (cprofile.run('function_name')) and line_profiler and memory_profiler and timeit for timing function calls and pytest-benchmark for identifying bottlenecks
		- use pypy for JIT compilation
		- use dicts instead of lists for lookup operations
		- use list comprehensions which are faster than loops for creating a list
		- use map function which is faster than list comprehensions for function calls and large datasets: map(lambda x: x * x, range(1000000)) instead of [x * x for x in range(1000000)]
		- use zip function to iterate two lists of equal size
		- work around the GIL to use multiple CPU cores and run multiple tasks simultaneously
			- use multiprocessing to create separate processes with their own memory space, bypassing the GIL which is useful for CPU bound tasks
				with multiprocessing.Pool(processes=4) as pool:
					results = pool.map(square_function, range(10))
			- use asyncio for IO tasks like HTTP requests or database queries to perform concurrent tasks without blocking the main thread
			- use python 3.13 which comes with free thread mode
			- use multi-threading
			- use coroutines to create concurrent asynchronous code in python to perform multiple tasks simultaneously by creating simple lightweight threads
		- use scipy and numpy (implemented in c) for numerical operations which is much faster than lists for large-scale numerical operations
		- use JIT compilation with numba which automatically compiles the function to machine code which boosts performance
			from numba import jit
			@jit(nopython=True)
	- use match-case rather than if-else
	- use built-in functions which are usually optimized for speed and are often written in C
	- write generators to return one item at a time rather than all items at once
	- check membership of an item in a list with the in keyword
	- load modules only when needed
	- avoid recursion which takes up a lot of memory and instead use iteration
	- use cython (a superset of python) to speed up slow code, cython is compiled into c which makes it faster
		save file with pyx extension and use cythonize command on the file to compile it, after which it can be imported and used like a normal function
	- use vectorized operations and broadcasting
	- use pandas to manipulate data which is faster than standard python data structures
	- use sets and unions instead of loops where possible
	- use multiple assignment when possible
	- avoid global variables to help keep track of scope and avoid unnecessary memory usage, also local variables are faster to retrieve than global variables
	- use join rather than + to concatenate strings whch avoids creating a new string for each component
	- use while 1 for infinite loops
	- exit early (raise exceptions or exit first under failure conditions where possible to avoid executing code that will fail)
	- use itertools for combinations/permutations
	- use memoization like decorator caching such as with @functools.lru_cache(maxsize=100)
	- use keys for sorts using operator.itemgetter()
	- dont use sets for conditions like checking membership of an item in a list
	- use linked lists which allocate memory as needed, each item in a linked list can be stored in a different location, although lookup times are slower in linked lists, linked lists are faster at adding elements at the start of the linked list
	- use numpy arrays instead of lists for large data bc numpy arrays use less memory and are faster
	- use sets to check if an item is in a group of items, dicts to efficiencly store and retrieve data, and tuples to group values together
	- use lazy loading of data to only load data when needed
	- use hdfs or parquet formats to save data on disk and load only the parts that are needed
	- use memory_profiler or psutil to identify memory leaks

- other tips
	- use context managers to handle resources (files, sockets, db connections) in an efficient way by defining a context in which a resource is used and automatically open and close the resource
	- use try-except blocks to handle exceptions rather than failing
	- group errors with ExceptionGroup to handle them all at once
	- use the traceback module to see detailed error info
	- use TaskGroups to run similar tasks together as opposed to asyncio.gather which fails on the first exception
	- use decimal instead of float for calculations
	- use f"{value:.2f}" to control decimal places
	- use math module for square roots, logs, and trig functions
	- use numpy for faster, more complex operations like matrix operations, fourier transforms and statistical operations
	- use scipy for scientific operations, signal processing, optimization, interpolation, and integration

- handlers for security bugs
	- cross site scripting
	- log injection
	- sql injection
		- use parameterized sql queries instead of string building
	- security tips
		- hash and salt passwords with bcrypt
		- set strict access controls
		- monitor query performance
		- log suspicious patterns
		- use environment variables for configuration
		- use structured logging, gitignore logs, use logging level control, and avoid logging sensitive data
		- minimize dependencies
		- use precommit hooks with security scanning tools
		- use standard auth libraries like requests-oauthlib or Flask-Login
		- apply session management to expire tokens/sessions, rate limit API requests, and validate emails
		- use whitelists to support valid requests
		- use prepared statements to send a query template and then send the values for fields in the template
		- check hashes of downloads
		- have a secure backup strategy in case of database corruption or sql injection attacks
		- move credentials to .env files
		- use secret managers in prod
		- gitignore configuration files
		- patch dependencies regularly
		- rotate keys regularly
		- handle cookies securely
		- set up Cross-Site Request Forgery (CSRF) protection by using flask_wtf to use unpredictable CSRF tokens in forms which are verified by servers when requests are made, so that valid requests cant be forged
		- keep tokens private
		- use APIs securely
		- use secure libraries
		- use SAST (bandit, veracode) and DAST tools (burpsuite, OWASP zed attack proxy, arachni)
		- use SSL/TLS connections, enforce HTTPS to protect against MITM attacks
		- avoid using root access
		- set file permissions (0 = none, 1 = x, 2 = w, 3 = w/x, 4 = r, 5 = r/x, 6 = r/w, 7 = r/w/x)
		- avoid eval() (use ast.literal_eval()), compile(), exec(), input() without validation, pickle.loads(), subprocess.call() with shell=True
		- validate character encoding (unicode, ascii) or character sets and input length
		- use type annotations and linters to check types
			- for example, use the Literal type annotation to validate a string matches items in a static list and use type checking tools like linters to check that type annotations are followed
		- deserialize with caution
			- the pickle module is insecure, where a better alternative is json or PyYAML which allows serialization/deserialization to/from YAML, which should be used with yaml.SafeLoader to avoid attack vectors even though it cant load custom classes
			- use defusedxml to avoid xml security issues like DOS attacks or external entity expansion where an external source is referenced
		- sanitize external data
			- schema is a library that validates data structures like from config files, forms, external services or command line parsing or converted from JSON/YAML to python data types
			- bleach is a library that escapes or strips markup and attributes
			- jinja is a templating engine that auto-escapes to prevent XSS using markupsafe
			- use named parameters to prevent SQL injections instead of building a query string, or use object relationship mapping (ORM) tools like sqlalchemy
		- download packages cautiously
			- check package names for typos and check snyk advisor or use safety CLI or install pip audit or check github issues/dependabot alerts for known security issues with packages
			- use pip freeze to record environment-specific package versions
			- keep dependencies updated to use code with latest security fixes
		- review dependency vulnerabilities and licenses
			- avoid GPL, AGPL, LGPL, and EPL and use code with permissive licenses (MIT, Apache, BSD) where possible
		- dont use the system python version which is unlikely to be current
		- use virtual environments with venv to isolate projects (including python versions used, libraries, and scripts)
		- set DEBUG=False in prod to avoid publishing overly informative error messages
		- format strings cautiously
			- use templating tools like string.template to format strings with parameters to avoid evaluating python statements like f-strings evaluate python statements

- sources
	https://www.geeksforgeeks.org/python/python-design-patterns/
	https://wpexperts.io/blog/python-version-history/
	https://snyk.io/blog/python-security-best-practices-cheat-sheet/
	https://securecodingpractices.com/python-secure-coding-best-practices/
	https://www.programmingworld.tech/blog/optimizing-python-code-for-performance-tips-and-tools