      - conversion functions (conversion to an interface format, and conversion back to input information system format) 
        
        1. convert input information to an interface based on interface object definition (remove information unrelated to dependencies for the causal interface) 
        2. apply an interface to input information (find core causal interface components (like structures, such as directions of dependency) in the input information necessary to do other causal interface operations) 
        3. apply interface components to distort information to generate additional information to match (distort input information with causal or other interface components) 
            - specific interface components (like navigation functions) for that interface 
            - core/common components (like distortion functions) of that interface 
            - related components of the interface 
            - other interfaces/interface operations 
        4. find matching objects (check formatted information & distorted information for objects that match the causal interface objects 
        5. convert to input information format (integrate causal structures found with the input information, checking for validity of the structures & their related objects once integrated with the input information) 

        - interface conversion function as shown in FIG. 20 (Interface conversion & matching) example:  
            - converting objects to the type interface involves identifying attribute sets that are unique, and then identifying types that can describe multiple unique objects as variations of an attribute in the attribute set 
            - converting to the cause interface involves focusing on dependence objects (inputs/outputs) 
            - As shown in Fig. 20, the application of a standard interface query (function-structure interface) is depicted for a problem definition such as 'complete the function based on the implied pattern'. 
                - The interface query steps to find/derive/generate the 'completion' function may include:
                    1. standardize to structural interface (graph the function)
                    2. query for implications of the structure (triangle with curvature applied, alternate paths between corners varying on curvature, motion in the direction of concavity, filling a shape similar to existing shape)
                    3. apply implications (implications of change types indicating prior or next states)
                    4. result is a triangle or ellipse for various implied change types
                    5. convert triangle/ellipse to function
                    6. filter by any specific solution metrics given
                - Given the origin function structure, the interface query would find rules, implications, & other objects relevant to the structure, such as:
                    - 'Copy & rotate a semi-circle to create a circle/ellipse'
                    - 'Streamline along tangent (involves standardizing to concept interface) to make triangle'
                - The origin function structure has been converted from the structure interface to the system interface (including the 'implication' object) and back to the structure interface, with system objects like relevant rules of implications applied.


        - example conversion function logic on cause interface:

            - conversion function 
              - standardize to the cause object definition 
                - default conversion operations: 
                  - mapping objects that can be converted 
                  - adding/deriving missing objects required for the interface 
                  - removing irrelevant objects 
                - conversion operations that apply other interfaces on top of the causal interface 
                  - structure-function interface: linking inputs & outputs for causal functions that have structure (sequential functions, hub functions, etc) 
                  - concept interface: identify dependency, state, adaptability, & agency 
                  - structure-type interface combination: 
                    - identifying causal types, such as ambiguous cause, structured as multiple alternate similar routes or multiple unenforced rules/variance injection points 
              - the conversion function can be formatted with many different formats (like filters/limits/routes/combinations) to achieve conversion intents (like add/derive/change/remove attributes, or apply metrics)  
              - the intent of the conversion function is to represent each component in the problem space (or data set) as a component of cause (attribute, structure, concept, related object, etc) 
              - the conversion function will attempt to standardize to related interfaces, if the minimum information for the current interface is not met 
                - adjacent causal interfaces (interfaces acting as inputs/outputs or with similarities to this interface, like how information, math, and structure are related interfaces) 
                - alternate/proxy causal interfaces (interface combinations/embeddings that can act in place of this interface) 
              - a structure with a causation attribute (standardizable to the causal interfacee) can have: 
                - causal attributes (causal inputs/outputs, function variables, causal metrics, and descriptive attributes like direction, ambiguity, relevance, uniqueness, directness, inevitability) 
                - causal types (root, direct, hub) 
                - causal functions (converge/diverge, catalyze, depend, isolate) 
                - causal structures (vector, tree, loop, network) 
                - related objects (related concepts like dependence, ambiguity, relevance, agency) 
              - you can look for cause in structures by prioritizing: 
                - known causal structures & causal patterns 
                - causal vertex variables (like dependence) 
                - variables that are often found with cause 
                  - combinations of identifying objects/attributes/functions, like ambiguous-direction or inevitable-unique structures 
                  - causal function inputs/outputs 
                  - related objects to cause 
                  - preceding/determining/generative structures of these components (generative structures of related objects, causal function outputs, inevitable-unique structures) 
            

        7.A. applying default components or prioritized structures to format or otherwise alter the information to identify its structural relevance to that interface 
            - default components or prioritized structures can include: 
                - specific interface components (like navigation functions) for that interface 
                - core/common components (like distortion functions) of that interface 
                - related components of the interface 
                - other interfaces/interface operations 
            - for example: 
                - once a data set is converted to the information interface format, like: 
                    - an information-interface structure indicating information position/distribution/identity across agents 
                    - a structural-interface structure like a language network 
                    - a system-interface structure like the interaction of two information systems (with different internal functions/attributes/objects and/or information, like two type clusters in a data set) in a host system 
                    - a math-interface graph of data points on various dimension sets 
                 - the analysis program may follow that conversion with an additional conversion to a format amenable for comparison with important components on the information interface, like: 
                      - core info objects (like a core differentiating/comparison/storage rule, core conversion/filtering/organization function for new information, or a constant fact as a core information unit) 
                      - primary info objects (like perspectives/insights/questions/etc) 
                    - for example, the structure of a question in its default format might be a structure indicating missing information (the important object of the 'question' definition) for an intent 
                - in a graph format, this core 'missing information' structure of the question info object could take the form of structures in the graph like: 
                        - mismatches (like an incomplete rule set missing a function/variable attribute/object) 
                        - assumptions (questions being the removal of an assumption, the missing information being how the graph would change if the assumption was removed) 
                        - randomness (missing relevance/dependency to the system, like a data set having outliers that are missing the information of relationship to the data set) 
                    - which could indicate several embedded questions given these question type sub-structures: 
                        - which are the independent/dependent variables? 
                        - what is the independent/dependent variable relationship? 
                        - what do the clusters mean? (group membership of a data record) 
                        - what are the patterns of the clusters? 
                        - what is the probability of various given/generated data points being in a cluster? 
                        - what causes the outliers? (randomness, group resolution/dissolution/merging/divergence/adaptation/misidentification) 
                        - what function describes each clusters' variation? (function relating variables in data set) 
                        - what functions relate the clusters? (how could you transform one cluster to the other) 
                        - what direction or other structures of causation exist between the clusters? (does one group tend to become the other, and why/how/in what contexts) 
                - as another example, once a data set is converted to the system interface format (like a network of objects & functions with attribute shapes like layers), the program would follow that by converting it to a format amenable for comparison with primary interface objects (like incentives), functions (like optimize), or attributes (like complexity). 
                    - a format that enables comparison with interface objects like incentives would attach labels & structures where known interface structures (or calculated probably interactive/relevant alternative/adjacent interface structures using core combination analysis) are found 
                        - for example, if incentives have a structure like 'a shape where resources would stabilize at rest', a related structure would be generatable with core combination analysis by applying core functions like 'condition where other system variables are simultaneously changing' instead of the 'condition where other system variables are unchanging (at rest)' to generate an adjacent structures like 'a shape where resources are constant regardless of other variables', which may be a 'constant' or 'assumption' object 
                        - if the data set has a structure matching the 'constant' or 'assumption' object definition the program just generated by applying core distortions to the system 'incentive' object definition, it may be comparable with the 'incentive' definition object, because those objects are adjacent and operate on similar interaction layers, and may even interact (the program would query for insights or functions to check). 
        
        7.B. identifying matching components between information & interface components (components like systems, objects, functions, attributes, & types) with interface traversal function

        7.C. convert matching interface components back to input information 
            - if the program identifies a matching object in step 4 like a pattern (like two variable types that are usually related in a certain way indicated by the pattern) found in the input information, apply that pattern to the input information 
            - this means: 
                - retrieving functions/attributes/objects of that matching pattern (like which variable types are applicable), as well as relationships of that pattern to related objects (like related patterns/insights/functions, such as a validation function to check variable type) 
                - iterating through those related components and/or component sets of the matching pattern from the interface 
                - applying each related component or component set to the original input information (does this variable pair have the pattern implied by their variable types, which are applicable for that pattern) 
                - testing the new state of the input information for validity 
                    - does that pattern make sense (does it match functions/outputs or other structures) or have meaning (does it interact with relevant structures), given the system context of other input information or other information generated by prior interface analysis) 
            - if the probability of an accurate match is high enough, store that matching interface component, formatted to fit the input information, as a possible version of the input information, on which other interface analysis can be applied sequentially 
    
        7.D. repeat steps 7.A - 7.C if the selected interface analysis intent (support intents of interface analysis including 'traversing the interface' or 'formatting input information in as many ways as possible' or 'filling out an interface definition') is not complete. 
