TITLE OF INVENTION 

INTERFACE ANALYSIS

FIELD 
[0001] Embodiments of the disclosure relate to interface-specific analysis for extracting formatted information (like solutions, functions, meaning, & insights) from input information.

BACKGROUND OF THE INVENTION 
[0002] Analysis logic is usually done manually, without structure applied that would enable automation of the analysis. Any prior art relating to methods of applying analysis logic automatically would be possible outputs of this invention, as this invention includes logic executed on interfaces (interfaces as defined in application 16887411 as a information-filtering standard/format where cross-system change occurs), which can include logic to apply an interface standard to information, find & build logic for an intent, or applying structures to information operations (which enables analysis automation).

ABSTRACT
[0003] This invention translates input information (such as a data set, API, or document) into a format that is explanatory/descriptive/generative/predictive (insights, patterns, functions, meaning, cause, structure, etc), according to a supported interface analysis intent.

BRIEF SUMMARY OF THE INVENTION 
[0004] One or more embodiments of the present disclosure may include a method that involves the logic inherent to steps 402-410 of process 400 of the application 16887411:

''' to do:
- include link to repo for a more readable version with indents
- add new diagram of meaning interface (integrating information across interfaces into relevant structures for an intent)
- give fig 22 as an example of interface analysis
'''

General interface analysis process:

	1. convert to interface based on definition
	2. apply an interface to input information
	3. apply interface components to distort information to generate additional information to match
	    - specific interface components (like navigation functions) for that interface
	    - core/common components (like distortion functions) of that interface
		- related components of the interface
		- other interfaces/interface operations
	4. find matching objects
	5. convert to original system format)

General interface traversal process:

	1. obtaining input information from a program or user (like a data set of possibly related variables, or objects in a relational database)
	2. retrieving an interface definition
	3. deriving the interface definition if not found
	4. determining relevant interfaces or interface structures
	5. determining an interface query structure to organize relevant interfaces or interface structures
	6. execute query, checking for information needed after each interface or interface structure traversal
	7. applying the conversion function from the interface definition to standardize the information to the interface format, which involves:

		7.A. applying default or prioritized structures (interface components like functions for navigating that interface, core/common distortion functions of that interface, related components of the interface) to format or otherwise alter the information to identify its structural relevance to that interface

		7.B. identify matching components between information & interface components (components like systems, objects, functions, attributes, & types)

		7.C. convert matching interface components back to input information

		7.D. repeat steps 7.A - 7.C if the selected interface analysis intent (support intents of interface analysis including 'traversing the interface' or 'formatting input information in as many ways as possible' or 'filling out an interface definition') is not complete.

	8. integrate output into a structure relevant to the interface traversal intent (on the interface-interface), interface traversal intents such as 'find a cause of this variable' or 'find an optimal structure for this information', which involves applying structure to the output information as designated in the initial interface query design

The object and advantages of the embodiments will be realized and achieved at least by the elements, features, and combinations particularly pointed out in the claims. 

It is to be understood that both the foregoing general description and the following detailed description are merely examples and explanatory and are not restrictive. 


'''

BRIEF DESCRIPTION OF THE DRAWINGS 

[0005] Example embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which: 
[0006] FIG. 1. 'User Interface Module' illustrates a diagram of a user interface that can accept user input about a problem & program configuration.
[0007] FIG. 2. 'Interface-specific analysis Module' illustrates a diagram of a general workflow for how the interface-specific analysis program may find a solution for a problem statement.
[0008] FIG. 3. 'Problem Space Metadata' illustrates an example of metadata describing a problem, problem space, or related problem network.
[0009] FIG. 4. 'Solution Metadata' illustrates an example of metadata describing a solution, solution set, or solution space.
[0010] FIG. 5. 'Structure Application Function (Apply)' illustrates applying a structure to another structure.
[0011] FIG. 6. 'Problem space visualization' illustrates an example visualization of a problem space.
[0012] FIG. 7. 'Network of related problems' illustrates an example of a network of related problems.
[0013] FIG. 8. 'Problem Types' illustrates a set of common problem types formatted as information or structural problems.
[0014] FIG. 9. 'Problem formats, with matching solution formats of problem formats' illustrates an example of various problem formats & solution formats that match them.
[0015] FIG. 10. 'Problem-solution structure-matching: apply a solution function to a structure containing the problem to find specific solution structures for that problem' illustrates an example of matching a problem with a solution.
[0016] FIG. 11. 'Finding alternate solution formats that fulfill different metrics' illustrates an example of selecting a solution format that fulfills a solution metric.
[0017] FIG. 12. 'Network of problem sub-problems, breaking a problem into components problems' illustrates an example of breaking a problem into a set of sub-problems, which once solved, can be aggregated with a solution-aggregation method as shown.
[0018] FIG. 13. 'Causal structure-matching' illustrates a method of matching causal structures to a variable set.
[0021] FIG. 16. 'Concept definition network' illustrates a network of related concepts.
[0022] FIG. 17. 'Alternate definition routes' illustrates a set of definition routes for a concept.
[0023] FIG. 18. 'Match structure for a definition of a concept' illustrates matching a structure to a concept.
[0024] FIG. 19. 'Intent-matching' illustrates matching intent to structure & vice versa.
[0025] FIG. 20. 'Insight path application' illustrates insight path examples and an example of applying an insight path.
[0026] FIG. 21. 'Interface conversion & matching' illustrates an example of selecting an interface to traverse.
[0027] FIG. 22. 'Interface & traversal diagram' illustrates an example of a diagram indicating an example interface, & a diagram indicating which interfaces to traverse in what sequence (forming an interface query).
[0028] FIG. 23. illustrates an example computing system.â€¨


CLAIMS 

1. [original] A method comprising: 
	- obtaining a problem statement from a user, optionally including solution metrics (such as priorities, functionality, or attributes)
	- identifying problem & problem space metadata (such as problem type, variables, side effects, position on problem network, & minimum information required to solve the problem)
	- identifying optimal origin interface to start traversing from, identifying the interface traversal sequence, & applying interface operations like combine/embed
	- traversing the interface network (optionally including such interfaces as information, insight, structure, math, concept, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) according to that interface query, where the interface network is a network of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions/objects/attributes, and related information objects like patterns & other metadata specific to the interface)
	- identifying and/or reducing the solution space to a solution, applying filtering information found from interface traversals, to the standardized original/updated problem format
	- traversing subsequent interfaces to obtain additional information, if the minimum information to solve is not reached
	- returning identified solutions as a set of steps to reduce/solve the problem, as well as solution metrics, attributes, & actions, and/or related information objects like insights, patterns, the systematized problem format, the reduced solution space, and the interface queries used.

2. [original] The method of claim 1, wherein obtaining a problem statement involves: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms or using general/abstract versions of words, converting passive to active language, and removing words that don't change the meaning of the statement, and other operations that enable framing the problem as having a target solution structure.
	- converting a user-submitted query like 'distribute money equally' into a standardized problem statement like 'find a function to distribute resources while fulfilling this fairness definition', which is the actual intent of the user, given that equality and fairness definitions are often conflated

3. [original] The method of claim 1, wherein identifying the problem & problem space metadata involves:
	- identifying problem metadata like the problem type (like an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and problem inputs like interchangeable attribute sets, dependencies, & assumptions, as well as the minimum information required to solve the problem & other solution requirements
		- mapping the inferred/stated information describing the problem & problem space to a structure generated by the problem variables, a problem structure usually bound by assumption/requirement structures like filter/limit conditions, & indicating possible interactions between the problem objects & the other system objects like related problems & previous solutions, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure).
	
4. [original] The method of claim 1, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject/structure involves: 
	- assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, and differentiation potential) of the given & directly inferable information, which may include recommended traversals given the problem type, if identified (like how a 'prediction function' problem type has a recommended interface query sequence)
	- whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface, for example)
	- which interfaces should be traversed in what sequence, combination, or other structure produced by an interface operation
	This interface query is designed to maximize the chance of finding/generating/deriving additional information necessary to describe information about the problem system, beyond its initially identified metadata, so that its corresponding solution space can be identified/reduced.
		- using core operations (like find, identify, fit, match, apply, embed, build, create, derive) and standard interfaces, generate a custom diagram representing the interface query, which will specify what steps to take across the interface network to solve this specific problem
			- identify information (identify differentiating attributes/functions/sub-systems of agents/positions/routes within the system)
			- fit a system (identify relevant structures like abstraction layer to traverse at, identify important objects required to solve the problem, like trading problems/markets/skills/information/risk/bets vs. trading currency, or framing currency as a position attribute, rather than a standardizing interface)
			- match structures (identify trade & other market structures that are important for understanding why resources don't get distributed fairly, like closed trade loops & independence machines)
			- identify potential (identify alternative perspectives that could also explain the variation in optimized routes, like alternate value definitions)
			- fit causes (identify causes like marketing, collusion, and regulations that prevent or interfere with equilibrium market events)
			- find concepts (identify concepts relevant to markets like balance, demand/supply matching, and how the concept of information can disrupt any other market bc it enables automation)
		- if queries of those interfaces are insufficient to solve the problem, interface operations can be used
			- apply the system-structure interface to the information interface (can be used to determine information like the next layer of information objects that are relevant if enough automation is distributed)

5. [original] The method of claim 1, wherein traversing an interface on the interface network involves:
	- traversing an interface involves converting problem objects to that interface, using that interface's conversion function (which applies logic like system-mapping, position-finding, structure-matching, & object-identification logic), where the conversion function might be as simple as reducing objects to a set of attributes relevant to that interface (like how standardizing to the causal interface means focusing on dependencies between positions), or more complicated, like fitting problem objects to another system
	- once converted, the traversal proceeds to finding components on the interface that match the problem structures (optionally including related objects like insights, patterns, & functions relevant to that interface), and once an object/attribute/function between problem objects & interface objects is matched in an interface, their connecting structures (like functions/subsets) are queried and tested for relevance to the associated problem objects
	- using matching interface relationships to infer relationships about associated problem objects
	- identifying starting points on the interface, optionally including core objects & functions, directly mappable objects to the problem objects, or other starting points like important/required interface objects
	- where the output of each traversal may include information like matching interface objects, problem/solution or problem/solution space metadata, or functions/attributes reducing the problem
	- where the intent of traversals is to match a problem & a solution & is done with various analysis specific to interfaces or the interfaces resulting from interface operations
		- example: converting the 'route optimization' problem to the concept interface means identifying all important concepts (varying by the conceptual structure of an abstraction layer) determining the various states, paths, attributes, limits & other known important objects of the system where the route optimization occurs, like conditions that can prevent switching or connecting two nodes in the system
		- once any matching interface objects are found, the traversal reduces the problem statement into its most useful structure (as defined by solution metrics) to reflect the new information
			- example: if there are 'connection-prevention conditions' between concepts relevant to the problem definition (converted to the concept interface), those conditions can be looked for in the problem itself, and rules/patterns/attributes related to those conditions can be used to improve the solution structure that is the route (by reducing the route optimization costs, like reducing steps required) or maximizing rewards of a particular route, like hitting more valuable nodes during the route), so that useful information can be associated with problem objects newly identified as important from this interface traversal

6. [original] The method of claim 4, wherein traversing an interface involves interface-specific analysis, such as example analysis like:
	- core analysis: automatically finding core objects/functions/attributes/states possible to determine/describe a system, defining core operations like find/apply/build/derive
	- system analysis: automatically fitting system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, efficiencies, incentives, and conflicts to problem definition to determine optimal organization/format/routes/metrics/positions
	- structure analysis: automatically finding structures, like a route between information formats to solve a problem
	- information analysis
		- insight analysis: insight path application (using insight paths from other fields to optimize insight generation) - some of which is depicted in FIG 20 Insight path application.
		- problem analysis: applying structure to convert problems to a format with more solution methods, such as problem vectorization (mapping the problem definition to a directed network with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions) 
			- problem space analysis: visualizing problem metadata & related problem network, and changes to the problem space that invalidate the original or other problems once a particular solution is applied
				- some of which is depicted in diagrams FIG. 3 Problem Space Metadata, FIG. 4 Solution Metadata, FIG. 5 Apply function, FIG. 6 Problem space visualization, FIG. 7 Network of related problems, FIG. 8 Problem Types, FIG. 9 Problem formats, FIG. 10 Problem-solution structure-matching, FIG. 11 Finding alternate solution formats that fulfill different metrics, FIG. 12 Network of problem sub-problems, breaking a problem into component problems.
		- question analysis: where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network
	- change analysis: automatically identifying change metadata like change types necessary to explain a solution or solve a problem
		- potential analysis: automatically finding structures of variance like gaps/cascades/reducers, possibility fields, and determining/limiting vertices
	- logical analysis
		- function analysis: automatically identifying function metadata like variables, input/output trajectory, the function in a filter format, intent, complexity, efficiency, & exploits
		- intent analysis: automatically finding possible reasons to use a function to automate logic, some of which is depicted in FIG 19 Intent-matching
		- causal analysis: automatically matching the problem to causal structures to infer relevant variables & causation metadata (like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape) - some of which is depicted in FIG 13 Causal structure-matching
		- pattern analysis: automatically finding patterns with relevant similarities to infer the relevance of pattern metadata, where patterns replace missing required data (such as using patterns between variables of specific types or system positions to infer probable variable relationships)
	- concept analysis: automatically identifying concepts associated with a structure & vice versa, identifying positions of default abstract concepts in the network - some of which is depicted in FIG. 16 Concept definition network, FIG. 17 Alternate definition routes, and FIG. 18 Match structure for a definition of a concept.
	- interface analysis: identifying a interface-specific analysis workflow to derive/apply, mapping a query across combination or embedded interfaces given problem requirements, or identifying a specific or new interface to define/query (some of which is depicted in FIG 21 Interface conversion & matching and FIG 22 Interface & traversal diagram).

7. [original] The method of claim 1, wherein the solution space is identified or reduced with filtering information found from interface traversals to the original/updated problem format, & the interface network traversal process in claims 3 - 5 is repeated for converting the problem space to a solution space or reducing the solution space as needed to fulfill solution metrics, & then finding/deriving/generating a specific solution or a general solution method that reduces the problem into a format that is more similar to its final solved format (identifying a specific optimal route or explanatory variable combination), where the solution method may be calculated on other interfaces & then converted to a vector or other object impacting the formatted problem in the problem space structure (the causes of a problem & the sequence of reducing these causes calculated on the causal interface, a set of causes & reduction step sequence that is then mapped to the problem format in the problem space, at which point the solution is ready to be checked with regard to impact on the original problem, the problem space and/or related problems)
	- the solution space is the set of possible solutions, which in a 'route optimization' problem (formatted as a network of possible node positions with connecting functions, and/or a set of state networks) is the set of all possible routes that fulfill some solution metric, if not all of them
		- the filters found by the matching concept interface relationships in the example can be applied to reduce the solution space further
	- the solution can also be in alternative formats, if a solution in one format cannot be found
		- the solution to a 'route optimization' problem doesn't have to be a network trajectory, it can be a function installed in all positions to prevent the route from being necessary to traverse, for example, or a system optimization to the same effect
	- this step involves calculating the remaining distance from the minimum information required to solve the problem, any fulfilled solution requirements, & other measures of progress in reducing the problem like reducing problem variables, causes, related problems, etc
	- the solution is found when the solution metrics are fulfilled (for example, if an optimal route is found, a prediction function with some level of accuracy is found, or a set of implementation steps of a bug-free function is found), which doesn't necessarily mean the solution space has been reduced to one solution (the solution can be a set of alternatives, a range, or a comparable format)

8. [original] The method of claim 1, further comprising traversing subsequent interfaces to obtain additional information, if the minimum information to solve the problem is not reached.
	- if the solution metrics are not fulfilled, the interface query is updated if new information was found, the query is continued if no information was found, or a new query is generated if the previous query was complete
		- if the solution route doesn't minimize costs or maximize rewards above the specified solution metric level, or if there are nodes in the system that weren't checked during the previous interface traversal & there is room for optimization in the previous traversal's solution, the interface query can be continued/updated or a new one can be generated

9. [original] The method of claim 1, further comprising deriving summary solution metadata from the output of the interface traversals executed, like the success of comparable alternative found solutions & whether the solution created other problems in the problem space, given the solution requirements stated/inferred from the problem statement, where the query information & standardized problem space information is returned and if a solution or solution set is found, the summary solution metadata is optionally included, and query metadata & any new information objects or updates identified can be stored in the database for future queries.
	- this could be the specific optimized route or route-invalidating system-optimization function found, with metrics fulfilled, descriptive attributes, & relevant information like comparative cost/benefit of this solution, as well as alternate solutions, and optionally including general metrics like success probability, robustness/permanence of solution, etc.

10. [original] A non-transitory computer-readable medium containing instructions that, when executed by a processor, cause a device to perform operations, the operations comprising: 
	- obtaining a problem statement from a user, optionally including solution metrics (such as priorities, functionality, or attributes)
	- identifying problem & problem space metadata (such as problem type, variables, side effects, position on problem network, & minimum information required to solve the problem)
	- identifying optimal origin interface to start traversing from, identifying the interface traversal sequence, & applying interface operations like combine/embed
	- traversing the interface network (optionally including such interfaces as information, insight, structure, math, concept, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) according to that interface query, where the interface network is a network of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions/objects/attributes, and related information objects like patterns & other metadata specific to the interface)
	- identifying and/or reducing the solution space to a solution, applying filtering information found from interface traversals, to the standardized original/updated problem format
	- traversing subsequent interfaces to obtain additional information, if the minimum information to solve is not reached
	- returning identified solutions as a set of steps to reduce/solve the problem, as well as solution metrics, attributes, & actions, and/or related information objects like insights, patterns, the systematized problem format, the reduced solution space, and the interface queries used.

11. [original] The non-transitory computer-readable medium of claim 10, wherein obtaining a problem statement involves: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms or using general/abstract versions of words, converting passive to active language, and removing words that don't change the meaning of the statement, and other operations that enable framing the problem as having a target solution structure.

12. [original] The non-transitory computer-readable medium of claim 10, wherein identifying the problem & problem space metadata involves:
	- identifying metadata like the problem type (like an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and problem inputs like interchangeable attribute sets, dependencies, & assumptions, as well as the minimum information required to solve the problem & other solution requirements
		- mapping the inferred/stated information describing the problem & problem space to a structure generated by the problem variables, a problem structure usually bound by assumption/requirement structures like filter/limit conditions, & indicating possible interactions between the problem objects & the other system objects like related problems & previous solutions, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure).

13. [original] The non-transitory computer-readable medium of claim 10, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject involves: 
	- assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, and differentiation potential) of the given & directly inferable information, which may include recommended traversals given the problem type, if identified (like how a 'prediction function' problem type has a recommended interface query sequence)
	- whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface, for example)
	- which interfaces should be traversed in what sequence, combination, or other structure produced by an interface operation
	This interface query is designed to maximize the chance of finding/generating/deriving additional information necessary to describe information about the problem system, beyond its initially identified metadata, so that its corresponding solution space can be identified/reduced.

14. [original] The non-transitory computer-readable medium of claim 10, wherein traversing an interface on the interface network involves:
	- traversing an interface involves converting problem objects to that interface, using that interface's conversion function (which applies logic like system-mapping, position-finding, structure-matching, & object-identification logic), where the conversion function might be as simple as reducing objects to a set of attributes relevant to that interface (like how standardizing to the causal interface means focusing on dependencies between positions), or more complicated, like fitting problem objects to another system
		- once converted, the traversal proceeds to finding components on the interface that match the problem structures (optionally including related objects like insights, patterns, & functions relevant to that interface), and once an object/attribute/function between problem objects & interface objects is matched in an interface, their connecting structures (like functions/subsets) are queried and tested for relevance to the associated problem objects
		- using matching interface relationships to infer relationships about associated problem objects
		- identifying starting points on the interface, optionally including core objects & functions, directly mappable objects to the problem objects, or other starting points like important/required interface objects
		- where the output of each traversal may include information like matching interface objects, problem/solution or problem/solution space metadata, or functions/attributes reducing the problem
		- where the intent of traversals is to match a problem & a solution & is done with various analysis specific to interfaces or the interfaces resulting from interface operations

15. [original] The non-transitory computer-readable medium of claim 10, wherein traversing an interface involves interface-specific analysis, such as example analysis like:
	- core analysis: automatically finding core objects/functions/attributes/states possible to determine/describe a system, defining core operations like find/apply/build/derive
	- system analysis: automatically fitting system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, efficiencies, incentives, and conflicts to problem definition to determine optimal organization/format/routes/metrics/positions
	- structure analysis: automatically finding structures, like a route between information formats to solve a problem
	- information analysis
		- insight analysis: insight path application (using insight paths from other fields to optimize insight generation) - some of which is depicted in FIG 20 Insight path application.
		- problem analysis: applying structure to convert problems to a format with more solution methods, such as problem vectorization (mapping the problem definition to a directed network with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions) 
			- problem space analysis: visualizing problem metadata & related problem network, and changes to the problem space that invalidate the original or other problems once a particular solution is applied
				- some of which is depicted in diagrams FIG. 3 Problem Space Metadata, FIG. 4 Solution Metadata, FIG. 5 Apply function, FIG. 6 Problem space visualization, FIG. 7 Network of related problems, FIG. 8 Problem Types, FIG. 9 Problem formats, FIG. 10 Problem-solution structure-matching, FIG. 11 Finding alternate solution formats that fulfill different metrics, FIG. 12 Network of problem sub-problems, breaking a problem into component problems.
		- question analysis: where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network
	- change analysis: automatically identifying change metadata like change types necessary to explain a solution or solve a problem
		- potential analysis: automatically finding structures of variance like gaps/cascades/reducers, possibility fields, and determining/limiting vertices
	- logical analysis
		- function analysis: automatically identifying function metadata like variables, input/output trajectory, the function in a filter format, intent, complexity, efficiency, & exploits
		- intent analysis: automatically finding possible reasons to use a function to automate logic, some of which is depicted in FIG 19 Intent-matching
		- causal analysis: automatically matching the problem to causal structures to infer relevant variables & causation metadata (like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape) - some of which is depicted in FIG 13 Causal structure-matching
		- pattern analysis: automatically finding patterns with relevant similarities to infer the relevance of pattern metadata, where patterns replace missing required data (such as using patterns between variables of specific types or system positions to infer probable variable relationships)
	- concept analysis: automatically identifying concepts associated with a structure & vice versa, identifying positions of default abstract concepts in the network - some of which is depicted in FIG. 16 Concept definition network, FIG. 17 Alternate definition routes, and FIG. 18 Match structure for a definition of a concept.
	- interface analysis: identifying a interface-specific analysis workflow to derive/apply, mapping a query across combination or embedded interfaces given problem requirements, or identifying a specific or new interface to define/query (some of which is depicted in FIG 21 Interface conversion & matching and FIG 22 Interface & traversal diagram).

16. [original] The non-transitory computer-readable medium of claim 10, wherein the solution space is identified or reduced with filtering information found from interface traversals to the original/updated problem format, & the interface network traversal process in claims 3 - 5 is repeated for converting the problem space to a solution space or reducing the solution space as needed to fulfill solution metrics, & then finding/deriving/generating a specific solution or a general solution method that reduces the problem into a format that is more similar to its final solved format (identifying a specific optimal route or explanatory variable combination), where the solution method may be calculated on other interfaces & then converted to a vector or other object impacting the formatted problem in the problem space structure (the causes of a problem & the sequence of reducing these causes calculated on the causal interface, a set of causes & reduction step sequence that is then mapped to the problem format in the problem space, at which point the solution is ready to be checked with regard to impact on the original problem, the problem space and/or related problems) 

17. [original] The non-transitory computer-readable medium of claim 10, further comprising traversing subsequent interfaces to obtain additional information, if the minimum information to solve the problem is not reached.

18. [original] The non-transitory computer-readable medium of claim 10, the operations further comprising deriving summary solution metadata from the output of the interface traversals executed, like the success of comparable alternative found solutions & whether the solution created other problems in the problem space, given the solution requirements stated/inferred from the problem statement, where the query information & standardized problem space information is returned and if a solution or solution set is found, the summary solution metadata is optionally included, and query metadata & any new information objects or updates identified can be stored in the database for future queries.

19. [original] A system comprising: one or more processors; and one or more non-transitory computer-readable media containing instructions that, when executed by the one or more processors, cause the system to perform operations, the operations comprising:
	- obtaining a problem statement from a user, optionally including solution metrics (such as priorities, functionality, or attributes)
	- identifying problem & problem space metadata (such as problem type, variables, side effects, position on problem network, & minimum information required to solve the problem)
	- identifying optimal origin interface to start traversing from, identifying the interface traversal sequence, & applying interface operations like combine/embed
	- traversing the interface network (optionally including such interfaces as information, insight, structure, math, concept, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) according to that interface query, where the interface network is a network of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions/objects/attributes, and related information objects like patterns & other metadata specific to the interface)
	- identifying and/or reducing the solution space to a solution, applying filtering information found from interface traversals, to the standardized original/updated problem format
	- traversing subsequent interfaces to obtain additional information, if the minimum information to solve is not reached
	- returning identified solutions as a set of steps to reduce/solve the problem, as well as solution metrics, attributes, & actions, and/or related information objects like insights, patterns, the systematized problem format, the reduced solution space, and the interface queries used.

20. [original] The system of claim 19, wherein obtaining a problem statement involves: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms or using general/abstract versions of words, converting passive to active language, and removing words that don't change the meaning of the statement, and other operations that enable framing the problem as having a target solution structure.

21. [original] The system of claim 19, wherein identifying the problem & problem space metadata involves:
	- identifying metadata like the problem type (like an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and problem inputs like interchangeable attribute sets, dependencies, & assumptions, as well as the minimum information required to solve the problem & other solution requirements
		- mapping the inferred/stated information describing the problem & problem space to a structure generated by the problem variables, a problem structure usually bound by assumption/requirement structures like filter/limit conditions, & indicating possible interactions between the problem objects & the other system objects like related problems & previous solutions, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure).

22. [original] The system of claim 19, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject involves: 
	- assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, and differentiation potential) of the given & directly inferable information, which may include recommended traversals given the problem type, if identified (like how a 'prediction function' problem type has a recommended interface query sequence)
	- whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface, for example)
	- which interfaces should be traversed in what sequence, combination, or other structure produced by an interface operation
	This interface query is designed to maximize the chance of finding/generating/deriving additional information necessary to describe information about the problem system, beyond its initially identified metadata, so that its corresponding solution space can be identified/reduced.

23. [original] The system of claim 19, wherein traversing an interface on the interface network involves:
	- traversing an interface involves converting problem objects to that interface, using that interface's conversion function (which applies logic like system-mapping, position-finding, structure-matching, & object-identification logic), where the conversion function might be as simple as reducing objects to a set of attributes relevant to that interface (like how standardizing to the causal interface means focusing on dependencies between positions), or more complicated, like fitting problem objects to another system
		- once converted, the traversal proceeds to finding components on the interface that match the problem structures (optionally including related objects like insights, patterns, & functions relevant to that interface), and once an object/attribute/function between problem objects & interface objects is matched in an interface, their connecting structures (like functions/subsets) are queried and tested for relevance to the associated problem objects
		- using matching interface relationships to infer relationships about associated problem objects
		- identifying starting points on the interface, optionally including core objects & functions, directly mappable objects to the problem objects, or other starting points like important/required interface objects
		- where the output of each traversal may include information like matching interface objects, problem/solution or problem/solution space metadata, or functions/attributes reducing the problem
		- where the intent of traversals is to match a problem & a solution & is done with various analysis specific to interfaces or the interfaces resulting from interface operations

24. [original] The system of claim 19, wherein traversing an interface involves interface-specific analysis, such as example analysis like:
	- core analysis: automatically finding core objects/functions/attributes/states possible to determine/describe a system, defining core operations like find/apply/build/derive
	- system analysis: automatically fitting system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, efficiencies, incentives, and conflicts to problem definition to determine optimal organization/format/routes/metrics/positions
	- structure analysis: automatically finding structures, like a route between information formats to solve a problem
	- information analysis
		- insight analysis: insight path application (using insight paths from other fields to optimize insight generation) - some of which is depicted in FIG 20 Insight path application.
		- problem analysis: applying structure to convert problems to a format with more solution methods, such as problem vectorization (mapping the problem definition to a directed network with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions) 
			- problem space analysis: visualizing problem metadata & related problem network, and changes to the problem space that invalidate the original or other problems once a particular solution is applied
				- some of which is depicted in diagrams FIG. 3 Problem Space Metadata, FIG. 4 Solution Metadata, FIG. 5 Apply function, FIG. 6 Problem space visualization, FIG. 7 Network of related problems, FIG. 8 Problem Types, FIG. 9 Problem formats, FIG. 10 Problem-solution structure-matching, FIG. 11 Finding alternate solution formats that fulfill different metrics, FIG. 12 Network of problem sub-problems, breaking a problem into component problems.
		- question analysis: where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network
	- change analysis: automatically identifying change metadata like change types necessary to explain a solution or solve a problem
		- potential analysis: automatically finding structures of variance like gaps/cascades/reducers, possibility fields, and determining/limiting vertices
	- logical analysis
		- function analysis: automatically identifying function metadata like variables, input/output trajectory, the function in a filter format, intent, complexity, efficiency, & exploits
		- intent analysis: automatically finding possible reasons to use a function to automate logic, some of which is depicted in FIG 19 Intent-matching
		- causal analysis: automatically matching the problem to causal structures to infer relevant variables & causation metadata (like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape) - some of which is depicted in FIG 13 Causal structure-matching
		- pattern analysis: automatically finding patterns with relevant similarities to infer the relevance of pattern metadata, where patterns replace missing required data (such as using patterns between variables of specific types or system positions to infer probable variable relationships)
	- concept analysis: automatically identifying concepts associated with a structure & vice versa, identifying positions of default abstract concepts in the network - some of which is depicted in FIG. 16 Concept definition network, FIG. 17 Alternate definition routes, and FIG. 18 Match structure for a definition of a concept.
	- interface analysis: identifying a interface-specific analysis workflow to derive/apply, mapping a query across combination or embedded interfaces given problem requirements, or identifying a specific or new interface to define/query (some of which is depicted in FIG 21 Interface conversion & matching and FIG 22 Interface & traversal diagram).

25. [original] The system of claim 19, wherein the solution space is identified or reduced with filtering information found from interface traversals to the original/updated problem format, & the interface network traversal process in claims 3 - 5 is repeated for converting the problem space to a solution space or reducing the solution space as needed to fulfill solution metrics, & then finding/deriving/generating a specific solution or a general solution method that reduces the problem into a format that is more similar to its final solved format (identifying a specific optimal route or explanatory variable combination), where the solution method may be calculated on other interfaces & then converted to a vector or other object impacting the formatted problem in the problem space structure (the causes of a problem & the sequence of reducing these causes calculated on the causal interface, a set of causes & reduction step sequence that is then mapped to the problem format in the problem space, at which point the solution is ready to be checked with regard to impact on the original problem, the problem space and/or related problems)

26. [original] The system of claim 19, further comprising traversing subsequent interfaces to obtain additional information, if the minimum information to solve the problem is not reached.

27. [original] The system of claim 19, further comprising deriving summary solution metadata from the output of the interface traversals executed, like the success of comparable alternative found solutions & whether the solution created other problems in the problem space, given the solution requirements stated/inferred from the problem statement, where the query information & standardized problem space information is returned and if a solution or solution set is found, the summary solution metadata may be included, and query metadata & any new information objects or updates identified can be stored in the database for future queries.


DETAILED DESCRIPTION OF THE INVENTIONâ€¨

[0031] As used herein, terms used in claims may include definitions such as: 

	- component: functions/attributes/types/objects/systems
	- input information: can refer to original information input to the initial interface traversal, or traversal output information that has been converted, enhanced, formatted, or otherwise altered in a prior interface traversal, stored as a possible version of the original input information, and sent as input to another interface traversal
	
	''' to do: '''
	- interface: a useful standard for comparison consisting of the filtering object's definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface 
		- abstract interfaces optionally include cause, concept, structure, etcâ€¨
		- specific interfaces are other foundations where change develops in a clearly defined range that can be found in specific systems 
	- the traversal of an interface implies finding a map between objects, functions, & attributes inherent to that interface to the problem objects, functions, & attributes 
	- the application of an interface is an operation in an interface combination, mapping, injection, or other operation 
	
	- function: a set of inputs, a sequential list of rules or rule lists (logic tree) applied to the input set, an output set created by changes to the input set executed by the sequential rule list, optionally including side effects from execution. A function may be formatted in a different way, such as a list of attributes, filters, or a network.
	- intent: any of an abstract goal with direction, a reason to use something, or an output such as the intended result or an unintended side effect, which can be an abstract priority like fairness, a concrete goal, and can have a starting & ending position.
	- concept: set of unique objects remaining once objects from other spaces have their context & contradictory attributes removed. 
	- network: standard network graph containing nodes (sometimes called vertices) & linking functions (sometimes called edges), with or without node attributes, function relationship determining function shape, and direction as an indicator of intent or another metric. 

[0032] The present disclosure relates to the use of interface-specific analysis workflows, standardizing interfaces & custom logic automation for constructing a interface-specific analysis system, enabling the identification of solution spaces, solution sets achieving different solution metrics within the solution space, with an intent of identifying optimal solutions for a particular problem, problem type, or problem network in a particular problem space. This system enables the automation of finding solutions that optimize specific solution metrics defined in a problem statement in a discoverable system (where information can be derived, found, retrieved, generated, or gathered with testing, such as how relevant system objects can be described, core system functions can be derived, solutions can be tested, & success can be measured with some metric & threshold or target value). This system enables arriving at insights sooner, building products optimally sooner, inventing products sooner, and predicting patterns sooner, with less data, computational capacity, and human input. 

[0033] Method described in claims includes a general program workflow, from user problem input to supported output (like interface-formatted information or interface definition):

	1. obtaining input information from a program or user (like a data set of possibly related variables, or objects in a relational database)
	2. retrieving an interface definition
	3. deriving the interface definition if not found
	4. determining relevant interfaces or interface structures
	5. determining an interface query structure to organize relevant interfaces or interface structures
	6. execute query, checking for information needed after each interface or interface structure traversal
	7. applying the conversion function from the interface definition to standardize the information to the interface format, which involves:
			
		7.A. applying default or prioritized structures (interface components like functions for navigating that interface, core/common distortion functions of that interface, related components of the interface) to format or otherwise alter the information to identify its structural relevance to that interface
			
			- for example:
				
				- once a data set is converted to the information interface format, like:
					- an information-interface structure indicating information position/distribution/identity across agents
					- a structural-interface structure like a language network
					- a system-interface structure like the interaction of two information systems (with different internal functions/attributes/objects and/or information, like two type clusters in a data set) in a host system
					- a math-interface graph of data points on various dimension sets

				 - the analysis program may follow that conversion with an additional conversion to a format amenable for comparison with important components on the information interface, like:
				  	
				  	- core info objects (like a core differentiating/comparison/storage rule, core conversion/filtering/organization function for new information, or a constant fact as a core information unit)
				  	- primary info objects (like perspectives/insights/questions/etc)

					- for example, the structure of a question in its default format might be a structure indicating missing information (the important object of the 'question' definition) for an intent

				- in a graph format, this core 'missing information' structure of the question info object could take the form of structures in the graph like:

						- mismatches (like an incomplete rule set missing a function/variable attribute/object)
						- assumptions (questions being the removal of an assumption, the missing information being how the graph would change if the assumption was removed)
						- randomness (missing relevance/dependency to the system, like a data set having outliers that are missing the information of relationship to the data set)

					- which could indicate several embedded questions given these question type sub-structures:

						- which are the independent/dependent variables?
						- what is the independent/dependent variable relationship?
						- what do the clusters mean? (group membership of a data record)
						- what are the patterns of the clusters?
						- what is the probability of various given/generated data points being in a cluster?
						- what causes the outliers? (randomness, group resolution/dissolution/merging/divergence/adaptation/misidentification)
						- what function describes each clusters' variation? (function relating variables in data set)
						- what functions relate the clusters? (how could you transform one cluster to the other)
						- what direction or other structures of causation exist between the clusters? (does one group tend to become the other, and why/how/in what contexts)
				
				- as another example, once a data set is converted to the system interface format (like a network of objects & functions with attribute shapes like layers), the program would follow that by converting it to a format amenable for comparison with primary interface objects (like incentives), functions (like optimize), or attributes (like complexity).
					
					- a format that enables comparison with interface objects like incentives would attach labels & structures where known interface structures (or calculated probably interactive/relevant alternative/adjacent interface structures using core combination analysis) are found
						
						- for example, if incentives have a structure like 'a shape where resources would stabilize at rest', a related structure would be generatable with core combination analysis by applying core functions like 'condition where other system variables are simultaneously changing' instead of the 'condition where other system variables are unchanging (at rest)' to generate an adjacent structures like 'a shape where resources are constant regardless of other variables', which may be a 'constant' or 'assumption' object
						
						- if the data set has a structure matching the 'constant' or 'assumption' object definition the program just generated by applying core distortions to the system 'incentive' object definition, it may be comparable with the 'incentive' definition object, because those objects are adjacent and operate on similar interaction layers, and may even interact (the program would query for insights or functions to check).

		7.B. identify matching components between information & interface components (components like systems, objects, functions, attributes, & types)

			A. then the input information objects (converted to the interface) would be compared to interface components, to find matching structures

			B. after this initial match check, the function interface is applied, using interface-specific functions, which are either:
				- functions of that interface (function types like core/common/interactive/relevant/change/causative/generative/other prioritized distortion function types)
				- functions of other interfaces
					- patterns & functions across interfaces (apply the pattern interface)
					- insights & insight paths (apply the insight interface, a sub-interface of the information interface)
					- functions to achieve core/common/current interface intents, like core/common formats like 'minimized', attributes like a 'change-handling' priority, or other outputs like core/common/generative functions (apply the intent interface)
					- functions of cause/change/potential (apply change/cause/potential interfaces, to ensure youre checking versions of the structure that are probably relevant by commonness or other core priorities like causative change types, causal adjacence, or probability)
					- functions of concepts (apply concept interface, to identify concept structures)
					- functions of systems (apply the system interface & its components, like the 'optimize' function)
			
			C.A. once these functions are applied, iterate through distortion sets producing different states of the input information:
				- verify that the distortions are still relevant to the interface
				- repeat the matching process, looking for matching structures between the newly distorted input information structures & the interface components
					- for example, once youve applied an insight like 'comparison is quicker if you only compare different attributes', which involves reducing the attributes of the input information to the different attributes, do you find any new matches with interface objects, like a match with a function that could produce those differences, from either point in a compared pair as the input & the other point in the compared pair as the output?
						- if so, this is a function that you might not have found as quickly if you were matching the object having those attributes on a different interaction layer, like how comparing two shapes would benefit from different functions than comparing two generative functions of the two shapes

			C.B. optionally, distortion functions can be applied with intent to identify new components on the interface (apply an intent distortion function on the cause interface)

			C.C. optionally, distortion functions can be applied to other interface objects, to identify new components on other interfaces (such as applying a causal distortion function to an insight path to check if a new insight path applies, while traversing the cause interface), using the new input information and/or the cause interface objects for comparison

		7.C. convert matching interface components back to input information

			- if the program identifies a matching object in step 4 like a pattern (like two variable types that are usually related in a certain way indicated by the pattern) found in the input information, apply that pattern to the input information

			- this means:
				- retrieving functions/attributes/objects of that matching pattern (like which variable types are applicable), as well as relationships of that pattern to related objects (like related patterns/insights/functions, such as a validation function to check variable type)
				- iterating through those related components and/or component sets of the matching pattern from the interface
				- applying each related component or component set to the original input information (does this variable pair have the pattern implied by their variable types, which are applicable for that pattern)
				- testing the new state of the input information for validity
					- does that pattern make sense (does it match functions/outputs or other structures) or have meaning (does it interact with relevant structures), given the system context of other input information or other information generated by prior interface-specific analysis)

			- if the probability of an accurate match is high enough, store that matching interface component, formatted to fit the input information, as a possible version of the input information, on which other interface analysis can be applied sequentially

		7.D. repeat steps 7.A - 7.C if the selected interface analysis intent (support intents of interface analysis including 'traversing the interface' or 'formatting input information in as many ways as possible' or 'filling out an interface definition') is not complete.


[0034] One or more example embodiments are explained with reference to the accompanying drawings.

[0030]
	As shown in FIG. 1A, and by reference number 110, the interface analysis module 140 may include a user interaction module that may include any device or system or components thereof configured to receive user input and/or provide information to the user. For example, the user interaction module 110 may present an input to enter the problem statement and a set of filters (to refine the problem statement, or attach problem and/or problem space metadata such as expected complexity, known problem sub-problem, known problem factor, or preferred problem definition) as well as an input for common & other solution metrics (such as solution- finding time/cost, solution-implementing time/cost, accuracy, using pre-computed solutions or deriving solutions from scratch, using a particular data source for definitions & other API calls inserted into the workflow rather than using system-generated data sources from the initial or previous queries, etc) to a user. In these and other embodiments, the user may utilize the user interaction module 110 to identify problem & problem space metadata & solution metrics as an input filter to reduce the solution space and evaluate output solutions. In these and other embodiments, the user may additionally utilize the user interaction module 110 to identify output solutions of varying types (including optimal, low-cost, reusable, able to reduce other problems, able to invalidate a problem space, able to change a problem space to a very different one, etc) to create a score to store the output in the database as a solution (if the score is high) or a problem (if the score is low) associated with the origin problem statement. For example, the user may designate an output solution as optimal for solving a sub-problem of the origin problem, and the database will store a link between the sub-problem and the output solution as one of the sub-problem's optimal solutions.
	In some embodiments, user input may vary, such as where the problem statement may be an abstract statement, a statement about a problem type, or missing necessary information. The output may be incomplete or otherwise sub-optimal, in which case the user can state the problem differently or add information or their own theory about the cause or solution, or expand the allowances of the configuration to include more pattern & derivation computations than more direct problem-solving methods or pre-computed solutions that may need updating. The problem statement validation will return a message if the program cannot correct the problem statement or return a validation question to prompt the user to enter specific information. Deriving problem metadata such as the minimum information to solve a problem or deriving solution requirements would take the form of logic such as identifying required probable solution structures necessary to solve the problem & information necessary for filtering solutions in that format or for a particular intent (if it's a shape, the solution needs to be in vector format and the dimensions need to be identified). The validation will also validate other input fields like problem metadata, so that a problem statement that doesn't match the specific problem type will return an error indicating that mismatch.

[0031]
	As shown in FIG. 1B, and by reference number 140, the example interface analysis module 140 may be used to automate finding a solution for a problem statement, in accordance with one or more embodiments of the present disclosure. The interface analysis module 140 may include a user interaction module 110 and a machine learning system 120 and an API finding & calling system 130 that may provide input to a interface analysis module 140. The interface analysis module 140 may facilitate determination of the solution 150 associated with the problem statement, and output the solution 150 to the user interaction module 110.
	In some embodiments, such solution automation may lead to a solution for the problem, such as the cause of a problem, the intents fulfilled by a problem and/or the solution, a set of steps to reduce the problem, or a set of steps to neutralize or change the problem space containing the problem. In these and other embodiments, if a user is dissatisfied with the provided solution 150 (e.g., the solution is incomplete or no solution was found), the user may interact with the interface analysis module 140 (e.g., to add more information or remove assumptions) and the solution automation may be run again.
	The interface analysis module 140 may include any device or system or components thereof configured to utilize the inputs from the machine learning system 120 or the API finding & calling system 130 and from the user interaction module 110 to output the solution 150.

[0032]
	*new
	As shown in FIG. 1C, and by reference number 120, the interface analysis module 140 may include a machine learning system. In some implementations, the machine learning model, used to predict a variable, may include a supervised machine learning model (e.g., a decision tree learning model, a learning classifier systems model, a nearest neighbor model, a support vector machine model, and/or the like), an unsupervised machine learning model (e.g., a clustering model, a neural network model, a latent variable model, and/or the like), or a combination of the aforementioned, described elsewhere herein.
	*eonew
	The machine learning system 120 may include any machine learning system configured to identify relationships and/or correlations from a data set. For example, the machine learning system 120 may be configured to identify a set of most likely factors contributing to a problem or sub-problem or solution, whether directly or indirectly, by analyzing data sets. As an example, the machine learning system 120 may analyze all solution examples and predict which solution would be the best implementation for a problem definition, or analyze all sub- problem & problem associations stored in the database & predict which sub-problems would be the best way to break down a problem, or analyze all previous queries on the interface analysis module 140 and predict which factors will be used the most as inputs to show on the user interface module 110 (in the absence of functions on interfaces described above, or if machine learning is specified as a preferred solution method on the user interface module 110 before running the interface analysis module 140). In these and other embodiments, the machine learning system 120 may provide the correlations and/or the factors contributing to an input to the user interaction module 110 and/or the interface analysis module 140.
	In some embodiments, the machine learning system 120 may operate using any machine learning technique or deep learning technique, such as decision tree learning, association rule learning, clustering, reinforcement learning, representation learning, genetic algorithms, etc. In some embodiments, the machine learning system 120 may be utilized to perform a task, such as providing a recommendation of input filters to show in the user interface module 110 based on previous queries of the interface analysis module 140.

[0033]
	*new
	As shown in FIG. 1D, and by reference number 130, the interface analysis module 140 may include an API finding/calling system.
	*eonew
	In some embodiments, the user may want to use alternate data sources for the definitions & object metadata, or use data sources rather than deriving information, in which case API finding/calling functionality will be executed to discover public or permitted data sources matching target objects, or the data can be generated (or the definition predicted) using a standard machine learning model. Similarly these standard methods can be used to retrieve or generate the latest implementation or pre-computations for a solution or utility function (like sorting or indexing algorithms or testing tools), when local assets are compromised or when the user sets a preference for crowd-sourced or new tools.

[0035] FIG 2 is a diagram illustrating an example system 100 that may be used to automate finding a solution for a problem statement, in accordance with one or more embodiments of the present disclosure. The system 100 may include a user interaction module 110 and a machine learning system 120 and an API finding & calling system 130 that may provide input to a interface-specific analysis module 140. The interface-specific analysis module 140 may facilitate determination of the solution 150 associated with the problem statement, and output the solution 150 to the user interaction module 110. In some embodiments, such interface-specific analysis may lead to a solution for the problem, such as the cause of a problem, the intents fulfilled by a problem and/or the solution, a set of steps to reduce the problem, or a set of steps to neutralize or change the problem space containing the problem. In these and other embodiments, if a user is dissatisfied with the provided solution 150 (e.g., the solution is incomplete or no solution was found), the user may interact with the system 100 (e.g., to add more information or remove assumptions) and the interface-specific analysis may be run again. 

[0036] The machine learning system 120 may include any machine learning system configured to identify relationships and/or correlations from a data set. For example, the machine learning system 120 may be configured to identify a set of most likely factors contributing to a problem or sub-problem or solution, whether directly or indirectly, by analyzing data sets. As an example, the machine learning system 120 may analyze all solution examples and predict which solution would be the best implementation for a problem definition, or analyze all sub- problem & problem associations stored in the database & predict which sub-problems would be the best way to break down a problem, or analyze all previous queries on the interface-specific analysis module 140 and predict which factors will be used the most as inputs to show on the user interface module 110 (in the absence of functions on interfaces described above, or if machine learning is specified as a preferred solution method on the user interface module 110 before running the interface-specific analysis module 140). In these and other embodiments, the machine learning system 120 may provide the correlations and/or the factors contributing to an input to the user interaction module 110 and/or the interface-specific analysis module 140. In some embodiments, the machine learning system 120 may operate using any machine learning technique or deep learning technique, such as decision tree learning, association rule learning, clustering, reinforcement learning, representation learning, genetic algorithms, etc. In some embodiments, the machine learning system 120 may be utilized to perform a task, such as providing a recommendation of input filters to show in the user interface module 110 based on previous queries of the interface-specific analysis module 140. 

[0037] The user interaction module 110 may include any device or system or components thereof configured to receive user input and/or provide information to the user. For example, the user interaction module 110 may present an input to enter the problem statement and a set of filters (to refine the problem statement, or attach problem and/or problem space metadata such as expected complexity, known problem sub-problem, known problem factor, or preferred problem definition) as well as an input for common & other solution metrics (such as solution-finding time/cost, solution-implementing time/cost, accuracy, using pre-computed solutions or deriving solutions from scratch, using a particular data source for definitions & other API calls inserted into the workflow rather than using system-generated data sources from the initial or previous queries, etc) to a user. In these and other embodiments, the user may utilize the user interaction module 110 to identify problem & problem space metadata & solution metrics as an input filter to reduce the solution space and evaluate output solutions. In these and other embodiments, the user may additionally utilize the user interaction module 110 to identify output solutions of varying types (optionally including optimal, low-cost, reusable, able to reduce other problems, able to invalidate a problem space, able to change a problem space to a very different one, etc) to create a score to store the output in the database as a solution (if the score is high) or a problem (if the score is low) associated with the origin problem statement. For example, the user may designate an output solution as optimal for solving a sub-problem of the origin problem, and the database will store a link between the sub-problem and the output solution as one of the sub-problem's optimal solutions.

[0038] FIG. 1 illustrates a diagram depicting one embodiment of a component of the interface-specific analysis module 140 of FIG 2, the User Interface Module 110. Information displayed in the User Interface Module 110 may include structures from any of the other diagrams, given that the output sent to the User Interface Module 110 optionally includes query information about the processes run to generate problem & solution information.


[0040] Interface-specific analysis Module 140 is a general example of a workflow to find a solution to a problem automatically. It's an abstract version of specific interface-specific analysis workflows, and can therefore be used to generate those interface-specific analysis workflows. The process 200 runs logic to:
	- design interface queries (a sequence or directed network of interfaces to traverse) & execute interface queries
	- derive metadata & structure of problem & solution objects for the user to analyze & operate on in the problem space visualization generated by the process 200
	- optimize the queries run for a particular problem or problem type/format/version
	- identify/derive/apply/combine/generate interface-specific analysis workflows which determine the general solution method (like query for specific solutions to re-use solutions in the database, or apply a format to the problem to make calculating the solution trivial)
	- identify/derive/apply/combine/generate interfaces
	- apply the analysis specific to each interface (finding formats linking other formats, finding a structure for a concept, applying a function to a structure, etc). Examples of this type of logic are described in the other diagrams.

[0041] Method described in claims includes interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 21 & 22), with an example definition of the analysis as follows:

[0042] Method described in claims may include information interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0043] Method described in claims may include insight interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 20), with an example definition of the analysis as follows:

[0044] Method described in claims includes problem interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 3, 4, 5, 6, 7, 8, 9, 10, 11, & 12), with an example definition of the analysis as follows:


[0045] Method described in claims may include cause interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 13), with an example definition of the analysis as follows:

[0046] Method described in claims may include change interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0047] Method described in claims may include potential interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0048] Method described in claims may include structure interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0049] Method described in claims may include logic interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0050] Method described in claims may include pattern interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0051] Method described in claims may include intent interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 19), with an example definition of the analysis as follows:

[0052] Method described in claims may include function interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0053] Method described in claims may include concept interface analysis mentioned as a component of interface-specific analysis module 140 (optionally including example logic & output depicted in diagrams FIG 16, 17, & 18), with an example definition of the analysis as follows:

[0054] Method described in claims may include system interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0055] Method described in claims may include object interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0056] Method described in claims may include core interface analysis mentioned as a component of interface-specific analysis module 140, with an example definition of the analysis as follows:

[0057] Method described in claims optionally includes the aforementioned interface analysis types mentioned as a component of interface-specific analysis module 140, as well as other optional interface analysis types, which optionally includes example analysis type definitions that allow for automation of that analysis & allow for the application of specific functions powering that analysis (custom analysis functions like 'find the set of questions or formats that makes finding a solution trivial'), examples of these custom analysis functions being provided in the example interface analysis definitions above.


[0039] 
*new
As shown in FIG. 1J, a user may be associated with a client device, a server device, and a interface analysis module 140. In some cases, the user may wish to utilize the client device to access information (in formats such as a text document or data set) provided by the server device. As further shown in FIG. 1J, and by reference number 105, the server device may provide document information to the client device. In some implementations, the information may include information associated with the document, such as textual information provided in the document, information indicating locations of the document at the server device (e.g., uniform resource locators (URLs)), information indicating folders storing information associated with the document in the server device, information indicating files associated with the document that are stored in the server device, and/or the like. As further shown in FIG. 1J, the client device may receive the document information, and may provide a user interface (e.g., a web browser) that displays the information to the user. As further shown, the user interface may include a mechanism (e.g., a button, a link, a browser plugin, and/or the like) which, when selected, may cause the client device to generate a request to find, derive, or generate solutions to the problem statement, using the document information. As further shown in FIG. 1J, and by reference number 110, if the user selects the mechanism, the client device may provide, to the interface analysis module 140, the document information and the request to find, derive, or generate solutions. The interface analysis module 140 may receive the document information and the request to find, derive, or generate solutions to the problem statement. In some cases, the user may alternatively wish to utilize the client device to access information provided by an API or website, which could be downloaded to the client device & uploaded in the user interaction module 110, just like the document information could be uploaded.
*eonew

[0040] 
*new
As indicated above, FIGS. 1A-1J are provided merely as examples. Other examples are possible and may differ from what was described with regard to FIGS. 1A-1J. 
*eonew

[0058] One skilled in the art, after reviewing this disclosure, may recognize that modifications, additions, or omissions may be made to the system 100 without departing from the scope of the disclosure. For example, the operations of the system 100 may be implemented in differing order. Additionally or alternatively, two or more operations may be performed at the same time. Furthermore, the outlined operations and actions are provided as examples, and some of the operations and actions may be optional, combined into fewer operations and actions, or expanded into additional operations and actions without detracting from the essence of the disclosed embodiments. 

*new
[0041] 
FIG. 2 is a diagram of an example environment 200 in which systems and/or methods, described herein, may be implemented. As shown in FIG. 2, environment 200 may include a client device 210, an interface analysis module 220, a network 230, and a server device 240. Devices of environment 200 may interconnect via wired connections, wireless connections, or a combination of wired and wireless connections.
Client device 210 includes one or more devices capable of receiving, generating, storing, processing, and/or providing information, such as information described herein. For example, client device 210 may include a mobile phone (e.g., a smart phone, a radiotelephone, etc.), a laptop computer, a tablet computer, a desktop computer, a handheld computer, a gaming device, a wearable communication device (e.g., a smart wristwatch, a pair of smart eyeglasses, etc.), or a similar type of device. In some implementations, client device 210 may receive information from and/or transmit information to interface analysis module 220 and/or server device 240.
Interface analysis module 220 includes one or more devices that utilize machine learning models to predict a variable (e.g., provided by server device 240 to client device 210). In some implementations, interface analysis module 220 may be designed to be modular such that certain software components may be swapped in or out depending on a particular need. As such, interface analysis module 220 may be easily and/or quickly reconfigured for different uses. In some implementations, interface analysis module 220 may receive information from and/or transmit information to one or more client devices 210 and/or server devices 240.
In some implementations, as shown, interface analysis module 220 may be hosted in a cloud computing environment 222. Notably, while implementations described herein describe interface analysis module 220 as being hosted in cloud computing environment 222, in some implementations, interface analysis module 220 may not be cloud-based (i.e., may be implemented outside of a cloud computing environment) or may be partially cloud-based.
Cloud computing environment 222 includes an environment that hosts interface analysis module 220. Cloud computing environment 222 may provide computation, software, data access, storage, etc. services that do not require end-user knowledge of a physical location and configuration of system(s) and/or device(s) that hosts interface analysis module 220. As shown, cloud computing environment 222 may include a group of computing resources 224 (referred to collectively as "computing resources 224" and individually as "computing resource 224").
Computing resource 224 includes one or more personal computers, workstation computers, server devices, or other types of computation and/or communication devices. In some implementations, computing resource 224 may host interface analysis module 220. The cloud resources may include compute instances executing in computing resource 224, storage devices provided in computing resource 224, data transfer devices provided by computing resource 224, etc. In some implementations, computing resource 224 may communicate with other computing resources 224 via wired connections, wireless connections, or a combination of wired and wireless connections.
As further shown in FIG. 2, computing resource 224 includes a group of cloud resources, such as one or more applications ("APPs") 224-1, one or more virtual machines ("VMs") 224-2, virtualized storage ("VSs") 224-3, one or more hypervisors ("HYPs") 224-4, and/or the like.
Application 224-1 includes one or more software applications that may be provided to or accessed by client device 210 and/or server device 240. Application 224-1 may eliminate a need to install and execute the software applications on client device 210 and/or server device 240. For example, application 224-1 may include software associated with interface analysis module 220 and/or any other software capable of being provided via cloud computing environment 222. In some implementations, one application 224-1 may send/receive information to/from one or more other applications 224-1, via virtual machine 224-2.
Virtual machine 224-2 includes a software implementation of a machine (e.g., a computer) that executes programs like a physical machine. Virtual machine 224-2 may be either a system virtual machine or a process virtual machine, depending upon use and degree of correspondence to any real machine by virtual machine 224-2. A system virtual machine may provide a complete system platform that supports execution of a complete operating system ("OS"). A process virtual machine may execute a single program, and may support a single process. In some implementations, virtual machine 224-2 may execute on behalf of a user (e.g., a user of client device 210 and/or server device 240, or an operator of interface analysis module 220), and may manage infrastructure of cloud computing environment 222, such as data management, synchronization, or long-duration data transfers.
Virtualized storage 224-3 includes one or more storage systems and/or one or more devices that use virtualization techniques within the storage systems or devices of computing resource 224. In some implementations, within the context of a storage system, types of virtualizations may include block virtualization and file virtualization. Block virtualization may refer to abstraction (or separation) of logical storage from physical storage so that the storage system may be accessed without regard to physical storage or heterogeneous structure. The separation may permit administrators of the storage system flexibility in how the administrators manage storage for end users. File virtualization may eliminate dependencies between data accessed at a file level and a location where files are physically stored. This may enable optimization of storage use, server consolidation, and/or performance of non-disruptive file migrations.
Hypervisor 224-4 may provide hardware virtualization techniques that allow multiple operating systems (e.g., "guest operating systems") to execute concurrently on a host computer, such as computing resource 224. Hypervisor 224-4 may present a virtual operating platform to the guest operating systems, and may manage the execution of the guest operating systems. Multiple instances of a variety of operating systems may share virtualized hardware resources.
Network 230 includes one or more wired and/or wireless networks. For example, network 230 may include a cellular network (e.g., a fifth generation (5G) network, a long-term evolution (LTE) network, a third generation (3G) network, a code division multiple access (CDMA) network, etc.), a public land mobile network (PLMN), a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), a telephone network (e.g., the Public Switched Telephone Network (PSTN)), a private network, an ad hoc network, an intranet, the Internet, a fiber optic-based network, and/or the like, and/or a combination of these or other types of networks.
Server device 240 includes one or more devices capable of receiving, generating, storing, processing, and/or providing information, such as information described herein. For example, server device 240 may include a laptop computer, a tablet computer, a desktop computer, a server device, a group of server devices, or a similar type of device, that provides a social media application for access by client device 210. In some implementations, server device may receive information from and/or transmit information to client device 210 and/or interface analysis module 220.
The number and arrangement of devices and networks shown in FIG. 2 are provided as an example. In practice, there may be additional devices and/or networks, fewer devices and/or networks, different devices and/or networks, or differently arranged devices and/or networks than those shown in FIG. 2. Furthermore, two or more devices shown in FIG. 2 may be implemented within a single device, or a single device shown in FIG. 2 may be implemented as multiple, distributed devices. Additionally, or alternatively, a set of devices (e.g., one or more devices) of environment 200 may perform one or more functions described as being performed by another set of devices of environment 200.
*eonew

[0042] One skilled in the art, after reviewing this disclosure, may recognize that modifications, additions, or omissions may be made to the environment 200 without departing from the scope of the disclosure. For example, the operations of the process 200 may be implemented in differing order. Additionally or alternatively, two or more operations may be performed at the same time. Furthermore, the outlined operations and actions are provided as examples, and some of the operations and actions may be optional, combined into fewer operations and actions, or expanded into additional operations and actions without detracting from the essence of the disclosed embodiments.

*new
[0043] 
FIG. 3 is a diagram of example components of a device 300. Device 300 may correspond to client device 210, interface analysis module 220, computing resource 224, and/or server device 240. In some implementations, client device 210, interface analysis module 220, computing resource 224, and/or server device 240 may include one or more devices 300 and/or one or more components of device 300. As shown in FIG. 3, device 300 may include a bus 310, a processor 320, a memory 330, a storage component 340, an input component 350, an output component 360, and a communication interface 370.
Bus 310 includes a component that permits communication among the components of device 300. Processor 320 is implemented in hardware, firmware, or a combination of hardware and software. Processor 320 is a central processing unit (CPU), a graphics processing unit (GPU), an accelerated processing unit (APU), a microprocessor, a microcontroller, a digital signal processor (DSP), a field-programmable gate array (FPGA), an application-specific integrated circuit (ASIC), or another type of processing component. In some implementations, processor 320 includes one or more processors capable of being programmed to perform a function. Memory 330 includes a random access memory (RAM), a read only memory (ROM), and/or another type of dynamic or static storage device (e.g., a flash memory, a magnetic memory, and/or an optical memory) that stores information and/or instructions for use by processor 320.
Storage component 340 stores information and/or software related to the operation and use of device 300. For example, storage component 340 may include a hard disk (e.g., a magnetic disk, an optical disk, a magneto-optic disk, and/or a solid state disk), a compact disc (CD), a digital versatile disc (DVD), a floppy disk, a cartridge, a magnetic tape, and/or another type of non-transitory computer-readable medium, along with a corresponding drive.
Input component 350 includes a component that permits device 300 to receive information, such as via user input (e.g., a touch screen display, a keyboard, a keypad, a mouse, a button, a switch, and/or a microphone). Additionally, or alternatively, input component 350 may include a sensor for sensing information (e.g., a global positioning system (GPS) component, an accelerometer, a gyroscope, and/or an actuator). Output component 360 includes a component that provides output information from device 300 (e.g., a display, a speaker, and/or one or more light-emitting diodes (LEDs)).
Communication interface 370 includes a transceiver-like component (e.g., a transceiver and/or a separate receiver and transmitter) that enables device 300 to communicate with other devices, such as via a wired connection, a wireless connection, or a combination of wired and wireless connections. Communication interface 370 may permit device 300 to receive information from another device and/or provide information to another device. For example, communication interface 370 may include an Ethernet interface, an optical interface, a coaxial interface, an infrared interface, a radio frequency (RF) interface, a universal serial bus (USB) interface, a Wi-Fi interface, a cellular network interface, and/or the like.
Device 300 may perform one or more processes described herein. Device 300 may perform these processes based on processor 320 executing software instructions stored by a non-transitory computer-readable medium, such as memory 330 and/or storage component 340. A computer-readable medium is defined herein as a non-transitory memory device. A memory device includes memory space within a single physical storage device or memory space spread across multiple physical storage devices.
Software instructions may be read into memory 330 and/or storage component 340 from another computer-readable medium or from another device via communication interface 370. When executed, software instructions stored in memory 330 and/or storage component 340 may cause processor 320 to perform one or more processes described herein. Additionally, or alternatively, hardwired circuitry may be used in place of or in combination with software instructions to perform one or more processes described herein. Thus, implementations described herein are not limited to any specific combination of hardware circuitry and software.
The number and arrangement of components shown in FIG. 3 are provided as an example. In practice, device 300 may include additional components, fewer components, different components, or differently arranged components than those shown in FIG. 3. Additionally, or alternatively, a set of components (e.g., one or more components) of device 300 may perform one or more functions described as being performed by another set of components of device 300. 
*eonew

*new
[0045] As further shown in FIG. 4, process 400 may include utilizing a machine learning model to predict a variable. For example, interface analysis module 220 (via computing resource 224, processor 320, memory 330, and/or the like) may utilize a machine learning model to predict a variable. In some implementations, the machine learning model used to predict a variable may include one or more of a decision tree learning model, a learning classifier systems model, a nearest neighbor model, a support vector machine model, a clustering model, a neural network model, a latent variable model, and/or the like.
A decision tree learning model may use a decision tree data structure to perform machine learning. A decision tree data structure classifies a population into branch-like segments that form an inverted tree with a root node, internal nodes, and leaf nodes. For example, the decision tree learning model may use a decision tree as a predictive model to map observations about an item (e.g., represented in the branches of the tree data structure) to conclusions about a target value of the item (e.g., represented in the leaves of the tree data structure). The process of building a decision tree may include partitioning the data set into subsets, shortening branches of the tree, and selecting a tree (e.g., the smallest tree) that fits the data. In some implementations, a decision tree model may be a classification tree (e.g., where the target variable can take a discrete set of values) in which leaves represent class labels and branches represent conjunctions of features that lead to those class labels. Alternatively, a decision tree model may be a regression tree (e.g., where the target variable can take continuous values, such as real numbers).
A learning classifier systems model may use learning classifier systems to perform machine learning. Learning classifier systems are a paradigm of rule-based machine learning methods that combine a discovery component (e.g. typically a genetic algorithm) with a learning component (e.g., performing either supervised learning, reinforcement learning, or unsupervised learning). Learning classifier systems seek to identify a set of context-dependent rules that collectively store and apply knowledge in a piecewise manner in order to perform functions such as classification, regression, data mining, and/or the like. Learning classifier systems allow complex solution spaces to be broken up into smaller, simpler parts.
A nearest neighbor model may use a k-nearest neighbors model to perform machine learning (e.g., pattern recognition). A k-nearest neighbors model is a non-parametric method that may be used for classification (e.g., where the output is a class membership) in which an object is classified by a majority vote of its neighbors, with the object being assigned to the class most common among its k nearest neighbors, or may be used for regression (e.g., where the output is a property value for the object) in which the value is the average of the values of its k nearest neighbors. Additionally, weights may be assigned to the contributions of the neighbors, so that the nearer neighbors contribute more to the average of the values than the more distant neighbors.
A support vector machine model may use a support vector machine (also known as a support vector network) to perform machine learning. A support vector machine is a supervised learning model with associated learning algorithms that analyze data used for classification and regression analysis. Given a set of training examples, each marked as belonging to one or the other of two categories, a support vector machine training algorithm builds a model that assigns new examples to one category or the other. A support vector machine model represents examples as points in space that are mapped so that the examples of separate categories are divided by a clear gap. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall.
A clustering model may use cluster analysis (also known as clustering) to perform machine learning. Cluster analysis is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar to each other than to objects in other groups. Cluster analysis can be achieved by various methods that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Different cluster models may include connectivity models (e.g., where hierarchical clustering builds models based on distance connectivity), centroid models (e.g., where the k-means algorithm represents each cluster by a single mean vector), distribution models (e.g., where clusters are modeled using statistical distributions, such as multivariate normal distributions used by the expectation-maximization algorithm), density models (e.g., where clusters are defined as connected dense regions in the data space), and/or the like.
A neural network model may use an artificial neural network to perform machine learning. An artificial neural network utilizes a collection of connected units or nodes called artificial neurons. Each connection between artificial neurons can transmit a signal from one artificial neuron to another artificial neuron. The artificial neuron that receives the signal can process the signal and then provide a signal to artificial neurons connected to it. In some artificial neural network implementations, the signal at a connection between artificial neurons may be a real number, and the output of each artificial neuron may be calculated by a non-linear function of the sum of its inputs. Artificial neurons and connections typically have a weight that adjusts as learning proceeds. The weight may increase or decrease the strength of the signal at a connection. Additionally, an artificial neuron may have a threshold such that the artificial neuron may send a signal if the aggregate signal satisfies the threshold. Artificial neurons may be organized in layers, and different layers may perform different kinds of transformations on their inputs.
A latent variable model may use latent variables (e.g., variables that are inferred rather than directly observed) to perform machine learning. A latent variable model may infer the latent variables (e.g., through a mathematical model) from other variables that are observed (e.g., directly measured). In some cases, latent variables may correspond to aspects of physical reality that can be measured, but may not be measured for practical reasons. In such cases, latent variables may be referred to as hidden variables. In other cases, latent variables may correspond to abstract concepts, such as categories, behavioral or mental states, or data structures. In such cases, latent variables may be referred to as hypothetical variables or hypothetical constructs. 
*eonew

[0046] One skilled in the art, after reviewing this disclosure, may recognize that modifications, additions, or omissions may be made to the interface analysis module 140 without departing from the scope of the disclosure. For example, the designations of different elements in the manner described is meant to help explain concepts described herein and is not limiting. Further, the interface analysis module 140 may include any number of other elements or may be implemented within other systems or contexts than those described.

[0047] The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such, it is contemplated that various alternate embodiments and/or modifications to the present disclosure, whether explicitly described or implied herein, are possible in light of the disclosure. Having thus described embodiments of the present disclosure, it may be recognized that changes may be made in form and detail without departing from the scope of the present disclosure. Thus, the present disclosure is limited only by the claims.
In some embodiments, the different components, modules, engines, and services described herein may be implemented as objects or processes that execute on a computing system (e.g., as separate threads). While some of the systems and processes described herein are generally described as being implemented in software (stored on and/or executed by general purpose hardware), specific hardware implementations or a combination of software and specific hardware implementations are also possible and contemplated.
Terms used herein and especially in the appended claims (e.g., bodies of the appended claims) are generally intended as "open" terms (e.g., the term "including" should be interpreted as "including, but not limited to," the term "having" should be interpreted as "having at least," the term "includes" should be interpreted as "includes, but is not limited to," etc.).
Additionally, if a specific number of an introduced claim recitation is intended, such an intent will be explicitly recited in the claim, and in the absence of such recitation no such intent is present. For example, as an aid to understanding, the following appended claims may contain usage of the introductory phrases "at least one" and "one or more" to introduce claim recitations. However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles "a" or "an" limits any particular claim containing such introduced claim recitation to embodiments containing only one such recitation, even when the same claim includes the introductory phrases "one or more" or "at least one" and indefinite articles such as "a" or "an" (e.g., "a" and/or "an" should be interpreted to mean "at least one" or "one or more"); the same holds true for the use of definite articles used to introduce claim recitations.
In addition, even if a specific number of an introduced claim recitation is explicitly recited, those skilled in the art will recognize that such recitation should be interpreted to mean at least the recited number (e.g., the bare recitation of "two recitations," without other modifiers, means at least two recitations, or two or more recitations). Furthermore, in those instances where a convention analogous to "at least one of A, B, and C, etc." or "one or more of A, B, and C, etc." is used, in general such a construction is intended to include A alone, B alone, C alone, A and B together, A and C together, B and C together, or A, B, and C together, etc. For example, the use of the term "and/or" is intended to be construed in this manner.
Further, any disjunctive word or phrase presenting two or more alternative terms, whether in the description, claims, or drawings, should be understood to contemplate the possibilities of including one of the terms, either of the terms, or both terms. For example, the phrase "A or B" should be understood to include the possibilities of "A" or "B" or "A and B."
However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles "a" or "an" limits any particular claim containing such introduced claim recitation to embodiments containing only one such recitation, even when the same claim includes the introductory phrases "one or more" or "at least one" and indefinite articles such as "a" or "an" (e.g., "a" and/or "an" should be interpreted to mean "at least one" or "one or more"); the same holds true for the use of definite articles used to introduce claim recitations.
Additionally, the use of the terms "first," "second," "third," etc. are not necessarily used herein to connote a specific order. Generally, the terms "first," "second," "third," etc., are used to distinguish between different elements. Absence a showing of a specific that the terms "first," "second," "third," etc. connote a specific order, these terms should not be understood to connote a specific order.
All examples and conditional language recited herein are intended for pedagogical objects to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions. Although embodiments of the present disclosure have been described in detail, it should be understood that various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the present disclosure.
The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present disclosure. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the disclosure. Thus, the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

*new
[0048]
The foregoing disclosure provides illustration and description, but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above disclosure or may be acquired from practice of the implementations.
As used herein, the term component is intended to be broadly construed as hardware, firmware, or a combination of hardware and software.
Certain user interfaces have been described herein and/or shown in the figures. A user interface may include a graphical user interface, a non-graphical user interface, a text-based user interface, or the like. A user interface may provide information for display. In some implementations, a user may interact with the information, such as by providing input via an input component of a device that provides the user interface for display. In some implementations, a user interface may be configurable by a device and/or a user (e.g., a user may change the size of the user interface, information provided via the user interface, a position of information provided via the user interface, etc.). Additionally, or alternatively, a user interface may be pre-configured to a standard configuration, a specific configuration based on a type of device on which the user interface is displayed, and/or a set of configurations based on capabilities and/or specifications associated with a device on which the user interface is displayed.
It will be apparent that systems and/or methods, described herein, may be implemented in different forms of hardware, firmware, or a combination of hardware and software. The actual specialized control hardware or software code used to implement these systems and/or methods is not limiting of the implementations. Thus, the operation and behavior of the systems and/or methods were described herein without reference to specific software code--it being understood that software and hardware may be designed to implement the systems and/or methods based on the description herein.
Even though particular combinations of features are recited in the claims and/or disclosed in the specification, these combinations are not intended to limit the disclosure of possible implementations. In fact, many of these features may be combined in ways not specifically recited in the claims and/or disclosed in the specification. Although each dependent claim listed below may directly depend on only one claim, the disclosure of possible implementations includes each dependent claim in combination with every other claim in the claim set.
*eonew