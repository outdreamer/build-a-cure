# to do

  - organize new_examples.md
    - identify any examples missing from patents in docs/tasks by diffing patent spec texts
    - organize function implementations, to do list, examples, logic
 
  - add to govt/war
    - their lost loved ones wouldnt want them to seek revenge in isolation of context/meaning, bc it would destroy more innocent lives as collateral damage & continue the fight forever, they would want them to be the person who ends war forever

   - create configuration for 2-3 list items every day

      - create compilation script to compile code/config into a network graph on every change
        - add support for equivalent synonyms
        - add conversion to standard vocab

      - finish lists:
        - most valuable interface queries & workflows
          - find the sets of differences/dependencies/formats/errors & other useful structures that are the most valuable in a particular structure like a sequence to solve a problem
        - useful perspectives
          - useful to think of prediction functions as generative functions to select the variable interactions that are most likely
        - interface component definition routes
        - ai structures with supported intents & solution success causes
        - solution filters to apply in functions
        - useful interface components
          - aligning/balancing structures, to solve problems like 'a balance position of structures producing errors when unbalanced'
          - questions formatted as a disconnection between components like causal positions, paths, directions
        - subset indexes of an interface useful for solving most problems (structure indexed by metadata like problems solvable, fitting systems, interactive structures, supported intents)

  - identify useful perspectives

  - example of standardizing an error type:

    - 'maximizing shareholder value': using outputs (profit) to attract investment/capital rather than re-investing in products
      - calling 'routing outputs' function with intent to 'get more required inputs (like capital)' as a replacement of calling 'routing outputs' function with intent to 'make required inputs optional' has error structures with varying degrees:
        - false trade-off (not mutually exclusive)
          - outputs can be divided between both intents to create short-term & long-term gains
        - false causal structure
          - routing outputs with intent to 'increase product quality/variety' would fulfill the intent of 'attracting investment/capital'
        - over-prioritization
          - short-term gains
          - over-prioritization of inputs (like 'resources/ability') rather than using inputs to reduce costs (like 'required inputs')
        - lack of solution structures (once structures like over-prioritization are noticed, no solution structures were there to offset it)
        - lack of alternatives (other alternatives to 'increase product quality' to offset lack of intent fulfillment in the 'output routing' functions werent in position or available)
        - lack of opposite structures of competitor success (no monopoly or competitive moat or platform/supply chain/regulatory advantage in place)
        - lack of incentive structures to improve product in the absence of solution structures or correct output-routing functions (if executives planned on quitting/retiring before problems were noticed or compensation regulation changed)

  - add to science
    - cancer cells' mutations might just be some of the more adjacent/common/interactive mutations out of all the mutations that are possible or actually occur with any frequency
      - if this is true & the primary cause, that means these mutations will continue occurring unless actively prevented
        - substances should be examined for mutation-prevention functionality
        - root causes can be addressed as a prevention method, like:
          - the reason mutations occur more frequently for a gene structure (like a gene type, pattern, or set), such as gene position in relation to another structure
          - the host system's inability to prevent malicious interactivity/cascading of mutations that protect mutability & promote additional mutations
          - lack of a substance structure that would prevent or reverse these mutations, or particularly damaging subsets of mutations that enable the others
          - whether signals that enable/activate cancer cells can be routed where mutations are needed
      - examine what mutations almost never occur & determine the cause of mutation frequency (at a certain position on chromosomes, protein folds, relative position to gene types, or other structures on different interaction levels)
      - simulate whether changing position of genes reduces the frequency of mutations of those genes, if position is a variable to the mutation frequency
        - ultimately it should be possible by analyzing components like structures/functionality as combinable attack vectors, to calculate what diseases are possible/probable & will happen given a genome, their metadata like frequency & degree of impact on the host, and the substances/processes/stressors that can prevent or neutralize them
        - genomic data can be enhanced with data from output system & interaction structures

    - the idea of a 'cure' may be invalid, the concept of a 'functional state' may be a more useful goal
      - an example would be rather than returning someone to a prior or absolute state of optimal health, adjust their system to a state where its more functional, even if that functionality is distorted
        - rather than returning to origin DNA state, find adjacent DNA state to avoid susceptibility to a condition or general conditions
        - move bacteria from another region even if that reduces functionality in that region
        - generate useful bacteria factories, even if it sometimes results in overpopulation problems

    - the theory of 'the universe as a simulation' is only now getting popular bc our brain structures & functions are such that we are only now recognizing the influence of physics on human decisions, noticing that we can influence these decisions, and therefore fake them, which reminds us of computer simulations

  - interim functions to build:
    - derive definition routes on various interfaces from a definition
    - apply a standard format (function/attribute/object) to an input
    - derive function intent stack
    - identify error types
    - identify structures of cause
    - identify variable types & structures
    - consolidate repo, remove repeated content, merge similar functions

    - finish processes:
      - finish interface analysis of physics to determine other useful components like efficiencies, incentives, trade-offs, closed systems
      - finish applying interface components (like abstract) to useful interface components
        - core interaction functions of core interaction functions
      - create interface queries of finding useful interface component filters

  - why do structures overlap across interfaces:
    - different interaction types:
      - one interface may define the structure, and another may apply it
    - interfaces may have different definitions of the structure while still referencing the same underlying structure
    - interfaces have other interfaces injected in them by default
      - example: every interface has the core interface injected, bc it has core components
    - there's usually one interface that is the base interface for any given structure

  - add to useful structures
    - intent sequences
      - a 'requirement to survive' is the reason why an animal might develop bright colors, with varying intents:
        - with intent to 'attract prey', bc 'prey are difficult to find'
        - with intent to 'mimic a scarier animal' bc 'theyre not scary enough to disincentivize predators'
        - with intent to 'store excess mutations' bc 'mutations occurred for no reason other than structural damage'
      - the two intent sequences above overlap at the 'bright colors' node and diverge bc of different requirements, given their different positions relative to useful objects for survival (prey, predators, energy storage, change as energy)
      - this is a way to determine alternate causes of the same variable, given useful system objects like requirements & incentives
    - attribute sequences to connect problem/solution
      - example: a solution to this problem type has attribute sequence: complex, organized, filtered, isolated

  - finish identifying & applying other problem/solution components
      - insights/insight patterns: identify the variables of insight generation (such as structures like difference types/degrees, like 'applying a mixed different/similar system with various difference/similarity types to another system, with intent to understand the other system') and apply these variables to generate insights that can be applied to solve a problem

  - finish applying interfaces to problem/solution structures
    - intent: derive intent maps & align intents on multiple problem/solution structure layers, like problem-solution connection and sub-problem or problem/solution component connections
    - logic: derive interactive structures given logical rules like equivalences used as connecting functions
    - definition: apply problem/solution structure definitions to determine their possible interactions
    - cause: find solution success cause and generate solution automation workflows from that
    - change: 
      - find changes to problem/solution structures that still allow the structures to interact
      - find remaining variables of interactions

  - example of multiple ways to solve a problem
    - multiple ways to solve the 'find if a particular number is in a random sequence & find its position' problem
      - iterate through the sequence & check
      - filter the solution space of all possible sequences & approximate an answer by checking various points with solution filters
        - apply the definition of generative function's 'random' definition if available to identify error types possible/expected
        - apply the general definition of 'random' and 'probability' to find filter structures of likely sequences, which has probability-based filter structures when applied to a 'random number sequence' structure, like:
          - the sequence structure is likely to not have clear patterns in it (patterns that imply that it can be reduced to a function other than a random function)
          - the sequence structure is likely to not have a pattern that applies to the entire sequence (a pattern may occur, but is likely to only occur in a subset, the larger the sequence is)
          - if most positions do not have the number, its likely that remaining positions do have the number given possible patterns not ruled out by most positions (rather than finding a long sequence that doesnt contain the number, which is less likely than most numbers appearing in a long sequence at least once)
        - apply patterns of probability patterns as filters
          - how likely is it that 'if most positions do not have the number, its likely that remaining positions do have the number' produces an error?

    - multiple ways to solve the 'answer a question automatically' problem, with the following interface query:
      - if you have question-answer pattern info:
        - apply those patterns of language map routes or other info structures in the pattern to produce the answer
      - if you have error type & solution format or known solution info:
        - identify error type & apply solution formats or known solutions for that error type
          - apply the solution format as a template with a 'missing' error type or 'identification' problem:
            - for the question 'how did they get from A to B', the 'missing' structure is a 'missing path connecting the points', and the identification problem is selecting the correct route from all possible routes connecting the points
          - apply known solutions for the 'missing' error type (like 'matching structures that fit missing structure') or the 'identification' problem (like 'apply probability-based filters')
      - if you have concept identification, system structure identification, & derivation functions & access to info like agent decision histories but dont have specific info to filter possibilities of the optimal solution format of 'who drove it'
        - derive understanding of 'decisions' objects (to drive a car) & give proxy/approximate/abstract answers based on understanding
          - for the question 'who drove the car', derive relevant concepts such as 'inputs' to 'driving a car', like 'incentives', 'functions', 'access', 'requirements', 'intents' to 'drive a car' and produce a set of abstract descriptions of the types of people with those intents/incentives & other related objects

  - identify useful info formats for intents
    - rather than a language map, other useful info formats may include:
      - a map on a different interaction level, like 'core components':
        - a component language map (common core components of other terms) with words graphed as queries of the map
          - this would be useful for intents like the following, bc these involve adjacent attributes/functions/structures of this info format:
            - 'build a language map query like a particular word query'
            - 'find similarity between words'
            - 'generate a new word'
        - a network of common query structures on the language map (what are the words used for, like common sentence patterns such as questions)
    - rather than an attribute graph, containing a network of grouped attributes as objects:
      - a network of attributes as nodes
      - a network of individual attribute networks
    - rather than a causal network diagram:
      - a causal diagram with specifically n-degrees of causal inputs mapped
      - a set of vectors pointing in the same direction of other caused nodes (as vectors) with magnitude indicating input directness degree (root cause being shorter to indicate earlier position in the causal sequence)
      - clustered nodes by the outputs they have in common
    - rather than a system network diagram:
      - a network of functions that can generate/describe it
    - rather than a variable network:
      - a set of example system networks that include those variables as attributes of objects as network nodes

  - add to solution automation workflows

    - identify solution input variables that maximize differences in solution output or identify solution output types & weight them by some metric to integrate/filter them into a solution
      - example: for the 'find a prediction function' problem, find the most differentiating variables (number/value of constants/exponents, number of conditional/sub-range functions) producing the most differences in solutions ('constant linear average function', a 'highly variable function intersecting with the most data points', a 'piece-wise function describing threshold-based phases of the function') and weight these solutions to integrate/filter them according to a metric (like 'probability of the prediction function occurring with these input variable types/dependencies/correlations & data set patterns') to create an output solution
      - workflow fit: this is similar to 'find the maximally different filtering structures that will filter solution space the most efficiently', but is applied to 'input solution variables' rather than 'solution space filters'

    - apply error cause once an error is identified as a way of determining understanding of the problem system & decide whether to solve that error type or adjusting solution based on error cause
      - example:
        - an outlier would create an error in inaccuracy of predictions if incorporated into a prediction function, but the reason for the outlier ('error cause') may be that the connections between function variables are changing and the outlier is an early warning sign, or the outlier is the result of a set of interacting conditions creating an edge case that is expected occasionally but doesnt have to be included in a prediction function of other points & can be separated into its own conditional prediction function
      - workflow fit: this is similar to workflows analyzing 'solution success/failure cause' but identifying error cause in this case is to specifically improve understanding of the problem system so the connections between problem/solution structures are more identifiable & optimizable

    - apply error structures to problems as a neutralization structure and as a way of generating related problems (sub-problems, component problems) to solve instead or as part of the workflow
      - example: apply 'missing' error structure to problem components like data points or variables for the 'find a prediction function' problem, to solve the problem for a subset of the data set/variables instead
        - you can also apply correcting solution structures for each error type applied to get to the original solution format
          - to correct the 'missing' error structure that manifests as missing data points or variables, add an offsetting solution structure of 'iterate' & 'average' to repeat the process for other 'missing' error applications & average them to get back to the original solution format, a prediction function for the complete data set
            - data_set => missing(data set points) * iterate(missing, data_set) * average(iterations) => data set prediction function
        - other example: apply 'opposite' structure to the 'find a prediction function' problem, as in 'find functions that are not predictive' & differentiate from them to find the original solution format of the prediction function
          - apply('opposite', 'prediction function') => 'non-predictive functions' => apply ('differences', 'non-predictive functions') => 'set of possible prediction functions'
      - workflow fit: this is a variant of 'apply solution structures to solutions to optimize them' workflow
        - this specific process is similar to that produced by applying other analysis, like core analysis, which would apply a 'subset' function to various problem structures since thats a core structure, and then integrate those structures in a structure that would produce the original solution format, but its another route to produce that process

    - identify systems where a particular solution/error structure will be relevant (an error that causes damage by neutralizing required (or all alternative optional) functions, or a solution that neutralizes many error types) as a way of filtering relevant solution/error structures from the set of all possible structures, to find structures that are relevant to avoid for the input problem system, & add as a solution metric filter or solution component structure, in case the solution metric filters are incomplete/missing or solution components are not already identified by other methods
      - error type of 'assuming simplicity (failing to identify complexity)' can be caused by an error type of 'failing to identify the impact on complexity of the output of assuming simplicity'
        - when you assume simplicity, it reduces the incentive/benefit for an agent to be complex, and reduces the probability that they will be complex, causing a reduction in complexity or a reduction in showing complexity, if they were initially complex
        - the assumption causes itself to be likelier to be true (self-fulfilling prophecy) if the assumer is more powerful than the assumed & if they are connected by a mutual/common investment
        - this assumption can cause cascading errors in a system with a conceptual-probability interface structure like 'powerful outliers'
        - so solving a problem in a system with this condition ('powerful outliers' or the 'potential for powerful outliers') will require applying a solution/optimization structure to offset that error type, and a solution without this structure may not be optimal unless other structures of the solution provide a substitute/alternate for it
      - find error/solution structures that can replace other structures and identify the most-reduced set of structures that can fulfill the most functions without neutralizing any relevant solution structures in a system
    - workflow fit: this is similar to the 'find/derive error/solution structures & apply them as filters/components of solutions' workflow, but includes a function of 'finding useful alternate reduced error/solution structure sets' to fulfill relevant error type filters or solution structures, and 'finding systems where these structures are particularly relevant' to avoid applying irrelevant structures
    - why this is useful: many solution/error structures are possible, and its useful to filter them to reduce the operations required or reduce the solution space
    - solution success cause: this works as a filter bc some structures are only relevant for some systems

    - apply interaction (connection functions, structure-building) & neutralizing (structure-invalidating) structures & apply them to generate the sets of possible systems to allowing identifying the true structure of a problem system (how a problem system works)
      - once the sets are generated, filter the possible system structures by other structures like probabilities, patterns & prediction tests ('can a known system connection function be predicted by assuming this system structure')
        - prediction tests can be filtered by relevance ('predict important system connection functions, such as functions that are inputs to many other functions or required functions')
      - why this is useful: misunderstanding a problem system is a major source of error types and solving that problem can solve other problems like 'finding a specific connection function', just by knowing how structures can interact given relevant neutralizing structures, which allows identifying possible & probable problem system structures
      - workflow fit: this is a specific variant of the 'apply useful structures like interaction structures to problem/solution structures' but is applied to the 'problem system' structure as a particularly useful way of drastically reducing other errors, given rules about how interaction/neutralizing structures can create systems, indicating its an important input to the problem system, meaning its particularly useful relative to other problem/solution structures, & solving for this error type in understanding the problem system can drastically reduce other errors to the point of not needing to solve them
      - solution success cause: this works bc if an interaction structure cant exist in a system given other neutralizing structures, its not relevant and doesnt need to be included in the solution space, allowing reduction of the solution space

    - apply rules/patterns of solution connections to identify when a more optimal solution is adjacent to a sub-optimal solution (to offset the error type 'failing to pursue a direction when a more optimal solution is adjacent bc of prior cost from that pursuit')
      - just like the 'identify absolute minima/maxima' problem solved by methods like 'gradient descent', optimal solutions are often adjacent to the selected sub-optimal solution, but arent found bc of lack of understanding of solution patterns, connections & probabilities
      - solutions follow patterns revealing rules in their connections
        - some solutions are connected by an adjacent function, like an 'opposite' function or 'adding a variable/constant'
          - applying common differences determining the difference between sub-optimal & optimal solutions is a good way to find an optimal solution quickly once you have an initial sub-optimal solution with methods like 'approximation' or 'subset prediction'
        - applying 'standard function subset difference' structures to a standard/initial solution (like a function predicting a data subset) to produce 'maximally different' or 'highly probable given function patterns' possible alternative functions & checking which of these functions are good predictors for randomly selected data subsets is a good way to reduce the solution space
        - assuming that a consistent lack of value added by pursuing a particular direction will never produce value is a fallacy
          - just like assuming that bc you havent found a local maxima in a particular direction for a consistent period doesnt mean there isnt one, and bc functions & variables have patterns, maxima pattern probabilities can be used to predict their positions rather than applying random checks or applying a particular cost/benefit ratio to each pursued 'direction' variable value
        - solutions are rarely an idealized simple continuous function 
          - more often in reality a solution function for the 'find a prediction function' problem might be:
            - a set of subset functions, indicating emergent phase shifts at different threshold values of the independent variable
            - a set of conditional functions connected by a network organized by input conditions
      - applying these solution-connection rules to find adjacent optimal solutions to sub-optimal solutions is a way to work around the problem of 'trial & error (trying every combination)' to filter the solution space
      - workflow fit: this is similar to the 'apply changes to solutions to find other solutions, based on differences in intent/structure associated with those changes' but applies the pattern interface to these solution structure connections to inject the useful interface component 'probability' into the success of solutions, given the applied solution success cause 'patterns indicate a consistent connection that may be useful as a prediction rule to reduce uncertainty' (so applying connection patterns as a guide of queries is a way to increase the probability of finding certainties like true variable connections)

    - identify & apply other important structures that offset error types (that are important across problems/systems) to problem/solution structures as a way of improving solutions given an initial sub-optimal solution
      - example:
        - applying 'probability' structures like patterns & other probability structures reduces the error types related to not considering probability structures
          - such as the logical fallacy of 'assuming there isnt value in a high-cost, low-reward direction bc of prior costs' which doesnt account for outliers, threshold values & resulting phase shifts, & other probability structures indicating a complex system that isnt governed by just that cost/benefit
      - workflow fit: this is a general variant of the above workflow 'apply rules/patterns of solution connections' wrapped in the function of identifying other important structures to consider when solving a problem optimally where they are not already known & deriving structures to neutralize that error type where there arent already known structures to neutralize it & applying those neutralizing structures
        - this is also related to the 'apply certainty structures & other useful structures' workflows, but in this case its applying structures that are 'required' to apply in order to avoid known error types, rather than just useful structures or structures associated with solutions or optimization structures like certainty (like 'logic', 'understanding', 'info' for a prediction problem)
        - error structures can be generated by applying 'difference' structures to solution metric or optimization structures ('different from solution' = 'error' which may be relevant, like a solution-neutralizing error type)

    - find or generate structures of difference between multiple solutions & derive solution success cause of each, and apply those differences when one solution doesnt work, based on changes in solution success cause (conditionally generate different solutions based on changing inputs)
      - example: different solutions to the 'find a prediction function' problem involve differences like:
        - differences in variability between data set points
        - number of traversed data set points of a function
        - difference between the function & corresponding data points
      - applying these variables to a sub-optimal solution when a solution is determined to be sub-optimal for a particular input condition (which may not be known) allows a rotation of the available/generated solutions to find one that is successful for a different input condition

    - apply the useful 'maximum difference' structure to all problem/solution components, like find 'maximally different solutions' and use those as an initial solution space to filter/adjust quickly, or 'maximally different solution component sets' or other problem/solution structures to assemble/filter/connect problem/solution components
      - variant of the 'apply maximally different solution filters' workflow

    - find a solution & apply error types to a solution to identify if the error types produce the expected output of an error type
      - example: 
        - for the 'find a prediction function' problem, identify an approximate prediction function & apply error types to it
          - apply the 'incorrect assumption' error type
            - does the prediction function have the expected errors if you change the assumptions (input variables & variable values, problem statement, other assumptions like that the independent variables are causative at all & not coincidentally correlated)
          - apply the 'incorrect causal structure' error type:
            - does the prediction function have the expected errors if you change its causal structures?
      - if applying these error types produces the expected errors (rather than improving the accuracy of the solution), the solution is likelier to be correct or approximately correct

    - convert problem to standard problem, find standard/base solution, and map difference types to intent to apply when a different problem is input that can be solved with differences applied to the standard solution
      - example: 
        - when a function has multiple variables, apply difference type 'partial' to a derivative function and 'subset' to the 'partial derivative' input (find a partial derivative for one of the multiple variables)
        - when you need to solve a different problem 'find a derivative function for a function of x, y, & z', that differs from a standard/base problem (like 'find a derivative function for a function of x'), apply the differences that map with the intents of those differences
          - the relevant 'intent' of adding 'multiple' structure to the 'input variable' structure (the intent relevant to the problem) is 'find a derivative for each variable'
            - to fulfill this intent, apply the intent map: 'multiple': ['partial', 'subset', 'iterate']
              - apply the 'partial' and 'subset' structures to the standard solution once the 'multiple' structure is added to the standard problem
              - in other words:
                - to achieve a 'multiple' difference type applied to the input variable count of the original standard problem, apply 'partial' to the standard solution component ('derivative') of a 'subset' of each ('iterate') of the input variables
          - an adjacent/direct intent of adding 'multiple' structure to the 'input variable' structure is ('add a variable' or 'vary an existing variable', where the variable is 'number of input variables')

      - workflow fit: this is simlar to applying the intent interface but adds a starting position of a 'standard solution' mapped to a 'standard problem', for problems where a standard solution is available, rather than for example assembling structures fulfilling various relevant intents, such as intents for sub-problem or problem component structures

      - solution success cause:
        - this works bc a standard known solution for a related standard problem offers an 'interface' problem to use as a base to apply changes to
        - it uses the fact that 'similar problems will often have similar solutions'
        - it also uses the fact that a structure 'mapping differences to intents' is useful for 'mapping solution differences to intents' where intents can be derived from the problem, as 'different solutions' is a relevant object in this workflow

    - apply useful vertex rules from other systems after standardizing to a problem system
      - example: a useful physics rule is 'like attracts like' 
        - what is a causative structure:
          - applying this to other systems indicates the usefulness of 'similarities'
            - similar objects are often found together bc they are adjacent transforms of each other, and adjacent transforms are likelier than non-adjacent transforms
            - this means 'adjacent transforms' (like minor changes to a sub-optimal solution to fit it to a new problem) are a useful structure to apply as well, as an initial solution
          - applying the 'similarity' structure to a problem system would generate workflows such as: 
            - 'apply solutions to similar problems & adjust to create similarities to the original problem system so the solution/problem fit/interact'
            - 'a similar structure to a similarity is a difference (which are only a few changes away, as they are almost opposite structures), so differences are also a useful structure that can be applied'
            - 'change the problem until its similar to the solution (connect problem/solution by equating them'
      - why is it useful (solution success cause):
        - this rule is particularly useful bc its:
          - core/fundamental (that can be used to build other rules or be used as a foundation for other rules to develop)
          - powerful (impacts many interactions)
          - abstract (can be applied to many layers/systems bc it interacts with a core concept/structure like 'similarity')
      - other useful rules can be identified using these & other attributes that differentiate useful rules
      - the useful structures causing the useful rules (solution success cause) can also be identified & applied to problem/solution components
      - workflow fit: this is similar to 'apply insights to implement a solution automation workflow', but is different in that it applies generally 'useful rules' (which have attributes like causative power, core importance, abstract structures) rather than insights ('rules useful for specific intents like generating new understanding'), and also involves applying 'solution success cause' as an attribute of useful rules that is an alternative to applying the rule itself & allows abstracting/structuring the rule so it can interact with more systems

    - find a solution that is at least partially correct (like a solution that almost works) and determine solution success cause, then apply that as a solution metric filter or a solution structure like a solution component
      - example: for the 'find a prediction function' problem, a partially correct solution function might work bc it has a 'similarity' to an 'average function'
        - once you know that, you can use that as:
          - a solution component & apply other workflows to construct the rest of the solution, while including that component as an input requirement to other workflows
          - a solution metric filter & apply that as inputs to other solution automation workflows, like:
            - 'create a structure of solution metric filters as solution requirements acting as limit structures in a solution template'
      - workflow fit: this is similar to the workflows of:
        1. 'solving one component of the problem at a time, then solving the next in the sequence'
        2. 'find a solution that is sub-optimal and apply changes to optimize it'
        3. 'apply inputs of solutions (like causes of solution success) to create solutions'
        but combines other components of the other workflows, like the 'starting position' of workflow 2, a 'function' used in workflow 1, and the general 'structure' of workflow 3

    - identify possible solution structures that are the most testable (like 'solution components'), as in the most testably true/false & apply those structures when building a solution
      - example: for the 'find a prediction function' problem, find the probable subset functions that can be proved as true/false the quickest & assemble a prediction function out of those functions or adjustments to them to fit in or fit together with the other functions (like in a subset function sequence or fit together for continuity/curvature or fit into the same function with adjustments)
      - workflow fit: this is similar to the solutions or workflows:
        - 'find the most different possibilities to form a solution space and start filtering/testing/adjusting those to find a solution'
        - 'find the vertex variables as an approximation to a complete function' 
        - 'construct solution template using requirements as limit structures'
        but optimizing for 'testability' (rather than 'important variables' or 'maximum difference in possible solutions' or 'solution requirement limits') as a solution filter to speed up finding a solution

    - apply structural interface to derive & build structures that will solve problem structures of a particular solution automation workflow and an organizing structure to integrate them once solved (like a 'problem state sequence' or a 'solution metric filter')
      - example:
        - just like the 'prisonners dilemma' structure is a structure that solves the question of 'which choice is more often optimal, as in producing better outcomes more often', and a 'pinball machine' structure solves the question of 'which structures will a ball traverse given input variable values like direction/speed', certain structures can resolve questions more efficiently than others
        - build a structure (like a network, maze, game, or sequence of gaps) to represent variables to resolve that are organized in a way that solves the problem according to the selected workflow
          - if the problem is 'resolving order of a set of variables', build a sequence of gap structures & apply changes until each variable is resolved in the right input/output sequence, such as to solve the problem of 'determining variables that cause each other in an input/output sequence'
          - if the problem structure is a 'complexity', apply complexity-reduction structures or organizing structures like mapping/sorting/clustering/prediction algorithms to organize & resolve problem structures that are complexities
          - if the problem is 'finding out which set of path steps is optimal', organize problem states in a maze structure, where error paths end in a barrier so an agent cant continue to the destination
      - these structures assign structure to workflow-specific problem structures (like sub-problems or interim problem states), then apply change & test functions until the problem structure is solved
        - 'break a problem into sub-problems & merge sub-solutions'
        - 'solve sub-problems one at a time in a sequence to help solve later sub-problems'
        - 'filter the solution space by applying highly reductive filters'
        - 'connect problem/solution with a format sequence'
      - fit with other workflows:
        - rather than applying only a specific solution automation workflow to the problem, this workflow designs a structure to solve relevant problem structures (like 'sub-problems' or 'the problem of connecting sub-problems' or 'changing problem state in a way that makes progress toward a solution metric') by applying changes (like 'move a ball around the pinball machine' or 'decide which route to go in the maze') and testing if a solution metric is fulfilled ('like hitting the right structures' or 'selecting a route that can exit the maze')
        - this is a 'mix' structure applied to solution automation workflows:
          - it injects a workflow 'apply changes & filter output with solution metric tests' into the workflow of 'apply structural interface to design a structure that can solve problem structures with available change functions in those structures' which can be applied to workflows where problem structures like sub-problems or interim problem states exist (like 'reduce problem' and 'connect problem with solution') instead of another workflow
          - other solution automation workflows can be generated by applying interaction functions like apply/inject to solution automation workflows & their structures/components, to fulfill a solution automation workflow like 'connect problem/solution' (connect them using solution automation workflows & their structures/components/interaction functions)

    - identify workflow fit attribute (how a workflow fits with or relates to other workflows) to identify new variables of workflows or change types that can be applied to generate workflows using an input workflow or identify missing workflows

    - derive other interaction functions/structures between problem/solution components to derive solution automation workflows from those interactions
      - example:
        - 'break a problem into sub-problems and solve separately, then merge/integrate into solution' works bc of the solution success cause:
          - interaction function: component function between components of a problem & the complete problem
            - a problem can be broken into components (like core functions, or components of inputs like problem variables) like anything else, and 'solving a component of the problem' makes progress toward fulfilling the intent of 'solving the complete problem'

          - other solution success causes:
            - another reason a 'component' structure works when applied to a problem is that there may be existing/adjacent solutions for sub-problems rather than the original problem, so this structure offers a different way to connect problem/solution
            - this also works bc it applies a known core interaction function of problems/solutions ('reduce') to the problem, 'reducing' it into sub-problems, so it's already moving closer to a solution given problem/solution interaction functions & their patterns

        - 'generate solution space of possible solutions & filter by solution metrics' works bc of the solution success cause:
          - interaction function: subset function between solution & solution space
            - 'a solution ia necessarily a subset of all possibilities in the solution space'
            - 'the solution space is a subset of all possibilities'
        - 'apply changes to existing solutions to similar problems & test' works bc of the solution success cause:
          - interaction function: similarity sequence
            - 'similar objects, like similar problems, will have attributes in common, and so will objects related to them in a similar way (their solutions)'
        - 'apply changes to existing solutions known not to work & test' works bc of the solution success cause:
          - interaction function: difference structure
            - 'by definition a solution that works will be different from solutions that dont work'
        - 'start from system of certainties and apply certainty interaction functions to generate or reach a solution' works bc of the solution success cause:
          - interaction function: certainty interaction layer
            - the solution is the target certainty, and applying interaction (connecting/changing) functions specific to the certainty interaction layer to an initial certainty set will generate other certainties, like the solution structure, and/or reduce uncertainties like the unfiltered solution space of possible solutions
      - these interaction structures (subset, component, similarity sequence, difference) offer different ways to connect problem & solution components, offering different ways to connect problems/solutions        
        - other interaction structures/functions can be derived/generated to connect problem/solution components in new ways
          - any interaction function applied to problem/solution components that doesnt violate their definitions is a possible problem/solution interaction function
          - filter these by which functions interact in a way that can make progress toward or fulfill a problem-solving intent (like 'connect problem/solution' or 'reduce problem')

    - apply other component structure patterns (like attributes/functions) as another problem-solution connection format
      - change a problem (input) structure until it fulfills an attribute in a problem-solution connecting attribute sequence like the following, then fulfill the next attribute, etc
        - attribute sequences
          - 'complex, organized, filtered, isolated, simple'
          - 'abstract, random, grouped, relevant, matched, compared, equated'
        - function sequences

    - apply interface analysis to identify different versions of an insight or insight pattern in different interfaces, as insights are typically inputs to other insights so they can be used to generate them

    - rather than generating/deriving specific rules to implement a workflow, pull & apply known specific rules to implement a workflow or components of it
      - example: "occam's razor" is a known rule that can be used to fulfill the 'filter solutions' component of the 'generate & filter possible solutions' workflow
        - other known/optimal attribute filters can be used as solution filters
        - solution filters that filter the solution space the most optimally for a metric like speed/completeness, in the right sequence/structure can also be derived & applied

    - generate other variants of 'solve a different problem bc of optimizations fulfilled by solving the other problem (like using existing/adjacent resources)'
      - find adjacent structures (like approximations/alternates/interchangeables/simplifications/subsets) of problem/solution components and apply those as inputs to the solution automation workflow or interface query instead
      - find overlapping problems with various problem components and solve for overlapping problems instead
      - solve for the adjacent problem of 'preventing problem inputs/outputs' or 'enabling solution inputs/outputs' instead of the original problem

    - identify optimal problem to solve & solve that instead
        
        - the 'find a prediction function' problem has a default sub-problem of 'isolate each variable' and 'check if this variable impacts the dependent variable'
          
          - this is the wrong sub-problem to solve, bc:

            - it may not be possible to isolate a variable's contribution to cause bc of a causal structure between causal variables that is neither totally independent or dependent
              - if variables are independent, they can be isolated, and if theyre totally dependent, one can be used as a substitute of another
              - example of a variable with various dependence causal structure:
                - variables considered independent:
                  - shape of the earth and the latest news headline
                    - one is very constant and the other seems highly variable, but is becoming more constant as fundamental attributes of the earth become more relevant to news
                - variables considered dependent:
                  - the function caller requiring an output of a function, & the expected function output reliably created by the called function
                    - this isnt perfect dependence bc the outputs of a function may not be produced even if the code is correct, bc of other variables like hardware, but its a good approximation of dependence given the definition route of input as a causal structure
                - variables with mixed dependence:
                  - variables involving structures of ambiguity may not be able to be isolated such as mixed causal structures like similar alternatives with unmeasurable differences having a conditional dependency between alternatives
                    - for a problem of 'predict which equivalent route gets to the destination more optimally':
                      - routes that seem independent (unrelated) may have built-in dependencies, like:
                        - 'structural similarities'
                        - 'opposite structures'
                        - 'adjacent position'
                        - 'route selection alternation preference, caused by a variation preference'
                      - if you take the left/right route around an obstacle, it may not be measurable whether you made a better decision to get to your destination, because the other outputs of your route (leaning or looking one way more frequently) may be so negligible as to 
                        - resolve themselves
                        - never be measured in the first place
                        - offset by other decisions (taking a different route next time for variation)
                      - the routes may be equivalent or the differences may be immeasurable, and the output destination is the same, but the routes may also have a dependency that makes the input route variables (like left route frequency & right route frequency) of the output destination impossible to accurately isolate
                      - they also cant be combined accurately into one variable (like 'route structure' or 'route adjacence') bc this erases the info about their dependency & any conditions impacting one route or a route's selection
                          - whether you take a route may depend subconsciously on whether you took a different route previously (with a built-in preference for variation)
                          - the route frequencies and other route variables like route structure would both have to be incorporated in this case bc they cant be reduced
                        - one isolated component of the route variable might be sufficient to predict some variables (like whether a person develops a bias toward left/right), but they wont predict other variables (like vulnerability to natural disasters only impacting one route)
                        - if you cant identify/measure the structures like prediction potential or differences/connections in the route variable structures, you cant isolate them
                      - the dependency between alternatives may also be conditional
                        - 'the left route only influences the right route if theres a condition changing their interaction or if an agent creates a dependency by choosing one based on the other'

            - everything has some connection to everything else
              - example:
                - 'temperature' or 'collusion' in a particular industry like pharmaceuticals may seem unrelated to a problem like 'predict financial instrument markets', and variables like 'stock prices' might seem more relevant, but:
                  - temperature can influence emotions, which are an important input to the stock market & other financial markets, and tropical temperatures lead to more tropical plants like coffee, and higher caffeine intake also leads to changes in emotions, and temperature also influences many commodity prices & prices influence other prices
                  - collusion can create unequal stress distribution, where market participants who play fair arent making fair gains relative to malicious players, which has an impact on the stock market & regulatory environment, which can influence other regulatory environments, which is an input to financial markets
            
            - causal variables can have different causal structures like a causal loop or causal alignments between interaction layers, but that doesnt mean the causal relationship where they cause the dependent variable is incorrect, its just incomplete
              - example:
                - incomplete causal loop
                  - 'high temperate causes lack of work ethic, causing rise in temperature from pollution'
                - incomplete causal interaction layer alignment
                  - causative variables can be causative on a different interaction layer like an abstraction level of the problem
                  - 'power is a causative concept and input is a causative structure but that doesnt mean they contradict each other - theyre aligning variables on different interfaces, bc power takes the form of inputs in the function format'
                  - 'gravity can cause storms and so can electric charge, which are aligning causes on different interaction layers'

            - causative variables can have alternate causes (they might cause the dependent variable, but they might also be replaceable with alternate causes that also cause the dependent variable, with/out them)
              - example:
                - 'any source of energy can cause a storm, not just one like wind or gravity'

            - causative variables may seem interchangeable with other variable sets, while a hidden dependency exists, so theyre both required in order to predict the dependent variable
              - 'a plant can develop according to the input variable of human intervention or the variable of biology rules' is incomplete bc human intervention is in a causal loop structure with biology, and may be considered a subset or output of biology

          - so even if you find out that a variable is correlated with the dependent variable, & created a prediction function that seems to work at some level of accuracy for now, you still havent solved the problem bc youve applied inaccurate structures/definitions/connections rather than those based on understanding
            - example:
              - hiring based on biases like race/gender may seem to work well for a while, until social mobility & economic factors change, bc those may be the real determinants of success of particular groups, as certain groups had better education bc of better economic status, and the prediction function used an adjacent cause of 'bias' instead of the root causes of 'economic status' and 'education'
            - this makes the default sub-problem of 'isolating variables & determining impact on dependent variable' a shortcut to solving the problem, but it wont always have good results, bc of these inaccuracies in handling causal structures built in to the assumptions of solving the problem that way
          
          - so the right sub-problems to solve include:
            - 'how direct is the cause of this variable on the dependent variable'
            - 'how easy would it be to convert this variable into a causative variable' (how much work would you have to do like 'applying changes' to make the variable cause the dependent variable)
          
          - this is where useful interface components like 'filters' can be applied
            - filters reduce the solution space, just like reducing the set of possible variables by 'directness of causation' is useful
        
        - to find the optimal problem to solve in this specific case, you would need to apply the causal interface to identify the accurate structures of causation (like directness, uniqueness, inevitability of cause) to identify causal relationships, rather than proxy signals of causation like 'correlation' and 'sequence'
        
        - to generalize finding the optimal problem to solve, you would apply interface components to determine if the original problem & problem structures like sub-problems are capable of solving the problem (fulfill solution metric like 'accuracy') or if there is potential for optimization by applying interface analysis
        
        - solution automation workflow:
          - in order to find out if the original/default problem structures are sufficient to fulfill a solution metric, analyze the assumptions of the problem & problem structures to check for error types in those structures, implying that optimizations in the problem structures are possible, where there are default problem structures embedded in the problem statement or pulled from definitions or common solution workflows for a particular problem
          - error types in problem structures include:
            - contextually accurate structures (like connections, such as when conditional/proxy variables are used instead of root causes)
              - like fragile/forced conditions, such as whether a correlation or an adjacent cause like bias is used as a cause
            - missing/incomplete interface components like cause structures
              - bias is caused by over-prioritization of simplicity and by economic uncertainty (finite/unequal resources, leading to resource competition, leading to the development & use of filtering rules, such as hiring decisions)
              - bias is not the only cause, as the primary root cause is economic status & education, which has a causal loop structure with bias (the ultimate root cause being physics, an interim root cause being brain structure, and a more direct root cause being lack of information/testing tools to offset bias)
              - bias & economic uncertainty are both caused by economic status
              - other causal structures exist between these variables, bc they encapsulate a vast degree of information (like history, decisions, agency, culture, habits, patterns, brain structures, and priorities), so can be treated as important or possibly even vertex variables
          - the problem structures & their error structures can be compared/connected/reduced/combined until the solution structures (like the 'accuracy' metric) are reached, to check if they can adjacently fulfill the solution metric
            - the 'isolating variable impact' sub-problem can create an 'accurate prediction function' solution format, but not in all cases of different input variable causal structures, so if the interim solution structure of the sub-problem structure of the "isolated variables' causal structures" have an error type (are incorrectly mapped to causal structures), they wont create the optimal 'accurate prediction function', fulfilling general optimization metrics like 'robustness' of the solution

    - finish applying solution automation workflows to the problem of 'generate solution automation workflows'
      - example:
        - applying 'break problem into sub-problems & merge sub-solutions' takes the form of the following when applied to this problem:
          - sub-problem: generate solution automation workflow components
            - sub-solution: to generate solution automation workflow components, find structures that can be used to build solution automation workflows (variables, structures like connection/interaction/difference structures)
          - sub-problem: find alternate inputs of solution automation workflow components
            - sub-solution: apply different interfaces & interface components like abstraction & system contexts to find alternate inputs of solution automation workflows
          - sub-problem: generate new workflows
            - sub-solution: apply interface analysis (& associated interface queries) to generate new workflows
              - example: 
                - apply the solution automation workflow 'apply useful interface components (like useful structures or system objects) to connect problem/solution'
            - sub-solution: solve the alternate problems of 'find new difference types to apply or find conversion functions between interfaces & find new interfaces to apply to find new workflows'

    - identify the errors of the perspectives generating each set of workflow variables & remove the errors to change the perspective to a new perspective that can generate other variables
      - example:
        - the perspective of problem/solution components has an error of 'over-prioritizing the interaction layer involving those components' which is an error bc it reduces the chances of finding workflows involving other components like 'differences'
        - to change this perspective into another (like a perspective where 'differences' are a core component that is likelier to be identified as an input to problem-solving components like workflows), apply interfaces or conversion functions between them
      - solution success cause: 
        - this works bc there are alternative variable sets that can generate solution automation workflows, like 'interactive components', 'function sequences', 'core interaction functions', 'causes of solution success', 'insights to optimize problem-solving', etc - all of them are not required to be used to generate a workflow, even if you can find these structures in any system bc of their abstraction level
      - solution requirement cause:
        - this solution is necessary bc over-focusing on structures that are too certain/static will prevent difference types from being injected that can identify other variables
        - its also necessary bc a variable thats adjacently structural on one interface may not be on another, so different variables on different interfaces makes sense as a requirement

    - identify causes answering the question of 'why is one problem format easier to solve than another format for a problem/problem space' & other questions relevent to problem-solving & apply them to make a problem easier to solve (optimize solutions)
      - example:
        - 'breaking a problem into sub-problems' makes a problem easier to solve bc of the cause that 'separates variables causing the problem and they are easier to solve in isolation'
        - apply this cause to generate other solution optimizations:
          - apply this cause to the 'connect problem & solution' solution automation workflow to generate a new workflow or implement (specify) a workflow:
            - isolate the variables of connection & connect them separately

    - generate inputs to causes of simplifying problems & other relevant process to problem-solving
      - example:
        - 'adjacent structures for one problem format are more interactive than those of another format' (adjacent functions interact in a way that fulfills one problem-solution format connection better than another problem-solution format connection)
          - this is another cause of why a problem is easier to solve in a particular format
        - this cause has inputs/requirements:
          - there must be adjacent structures
          - the adjacent structures in one format must be interactive
          - their interactions must enable connection of the problem/solution in that format
        - derive & generate the inputs to problem-simplifying solution success causes:
          - determine the requirements of a problem-simplifying cause
          - generate & apply those requireemnts
        - example:
          - identify that in order to find & apply adjacent interactive structures, they must exist
          - in order for these to exist, in some cases the program will need to generate them
          - in some cases, this will involve converting between formats, and the problem can be simplifed to 'converting to a format where adjacent interactive structures already exist'
          - this amounts to 'applying an interface', which this insight path has derived as the solution

    - identify structures with input/output structures like sequences that can be used to connect problems/solutions for a generated set of problem/solution formats
      - example:
        - the solution automation workflow 'generate possible solutions and filter them' applies a 'filter' structure bc the problem format involves 'many solutions' and the solution format involves 'one solution', the problem format being to 'find one solution out of the many possible solutions', and a filter can reduce the number of an object that is output, so it fulfills a problem-solving intent to connect these formats, given that in order to find one solution out of many possible solutions, a program would have to reduce the number of possible solutions in some way, so 'reduce' functions/structures like 'filters' are useful

      - generate possible problem/solution formats to connect by applying error structures
        - the above 'finding' problem has an error structure of 'excess possible solutions' or 'lack of solution filters'
        - most structures would be problematic in particular contexts
          - some structures are especially errors when applied to problem/solution components, like a 'lack of solution filters' as opposed to 'any lack of filters'
        - other error structures involve structures that can be solved with core interaction functions
          - 'connect' solves the error structure of 'lack of connection between problem & solution'
          - 'mix' solves the error structure of 'find new solution' or 'find a random combination to solve obfuscation problem'
          - 'break & combine' solves the error structure of 'complexity added by combined problem components' (where sub-problems are simpler to solve)

      - this isnt the same as 'apply core interaction functions like reduce/connect & basic structures known to solve problems like input-output sequences', its saying 'generate & apply all core structures/functions that are relevant to solve problems, given that error structures are also fundamental structures connectible to solutions with core interaction functions' and also 'generate & apply all possible problem/solution formats and find structures that connect them to generate solution automation workflows'

    - identify insights that optimize problem-solving, identify their variables & generate them to apply them dynamically to generate solution automation workflows

      - example:

        - the workflow 'break problem into sub-problems & combine sub-solutions' applies the insight 'smaller/simpler problems are easier to solve'
      - how to identify this insight:
        - pull patterns from problem-solving and identify that problem-solvers often apply the workflow of 'use unit/basic/simple case to solve the problem, then check if it holds with other cases'
        - pull definitions & fit them in a way that makes sense (doesnt contradict any factual rules)
          - 'small' is an adjacent term to 'simple', 'unit', 'basic', 'low-cost' or 'adjacent' because they are all similar to the concept of 'easy', so it fits into the rule 'smaller problems are easier to solve'
          - 'simple' is a synonym of 'easy'
        - test if changes to a problem make it easier to solve, and filter which changes succeed in making it easier to solve
          - if a problem is 'climbing a ladder', test if changing the problem to 'climbing a step' makes it easier to solve - if so, identify that the change was 'reducing' or 'simplifying' the problem to its 'unit' case, and test if this change simplifies other problems as well

      - how to identify/generate other insights that make problems easier to solve:
        - any change that has an opposite effect ('change', 'reduce', 'neutralize', 'remove') on a component/cause/variable/structure of an error structure, or its generative system, without causing other error structures
        - any function that connects inputs/outputs more efficiently than another function can make a problem of a relevant structure easier to solve (a more efficient 'reduction' function may be a better solution like 'filter' than a less efficient 'reduction' function like 'sort then filter')

    - solve problem for one component/variable/structure of the problem, then add other components of the problem and check if solution holds or modify it to fit the new component
      - this is a specific case of the general workflow 'simplify the problem, solve the simpler version, then check if the simple solution holds when complexity is added, or adjust the simpler solution for complicating structures'
      - its also a variant of the 'break problem into sub-problems & combine sub-solutions' solution automation workflow

    - find any missing workflows by applying change functions to workflows to find variants like general/specific versions of a workflow
      - apply a workflow to various problems to find changes to apply to workflows to adapt them to specific problems, and add those changes to a general solution automation workflow

    - convert workflows to other workflows to find any missing variables to generate one workflow from another

    - identify & apply commonly useful structures by standardized structures of usefulness (like 'which structures have outputs that have common inputs for other functions', 'which are capable of generating many other components', 'which are inputs to structures of usefulness') to all functions/variables/components of problem/solution components

    - apply error structures to problem/solution components like solution automation workflows (like 'missing' error structure applied to 'worfklows') & known solutions to those error structures, and generate/identify new/specific error types in the problem-solving system & apply solutions to those error types

    - generate structures of difference (like 'difference sequences') and apply as components of workflows (similar to applying interaction structures, solution structures, optimization structures, relevance structures, or not-error structures)
      - solution success cause: this works bc in order to get from problem to solution, you have to apply differences to the problem/solution until theyre equivalent, bc they start as different, which is the problem
        - a difference can be an error type: 
          - a value is different from another value, like an expected/required value
        - similarly, a problem is different from a solution
          - the problem 'find a value' is different from the solution of 'a value'
      - in order to find error types ('problematic' differences), you can generate difference structures & find optimal routes between the inputs/outputs as a source of solution automation workflows
        - to find solution automation workflows, first generate & identify problems in a known system and find optimal routes between inputs/outputs (formatted as starting/ending positions)
          - then identify the interface components interacting with those routes

    - apply differences to solutions that are known not to work (can be calculated as definitely not solutions, or have been tried and are known not to work) bc a solution that works would have to be different from these in order to solve the problem

    - derive patterns of differences between solutions that definitely dont work and solutions occupying structures like areas of ambiguity where the solutions in the area might work but are more difficult to calculate, and reduce solution space to those areas, and apply those patterns of difference to calculate solutions that might work given solutions that definitely are known/calculatable as not solutions

    - derive structures of solution spaces that position/structure solutions in a way that adjacence indicates probability of working, so areas can be ruled out with threshold metrics representing boundaries
      - rather than applying a simplistic similarity metric, apply a metric that determines actual similarities based on relevance to the problem
        - example of grouping methods to determine adjacence in a solution space:
          - structural similarities can indicate similar functionality, or they can be insignificant to a particular problem and caused by an unrelated factor (like two similar structures created in different positions by similar boundary structures but having different functionality bc of the different position), so grouping solutions by structural similarities is one way that can contextually represent similarity of solution success for a particular problem
          - combinations of components of workflows/interface queries (interactions, differences) that can act in isolation (a workflow can be formatted as a set of interactions)
          - vertex variables
          - apply solution ranges where solution formats can be reduced to approximations of solutions or adjacent components to solutions (a theorem can be framed as adjacent to a proof)

    - apply pattern-identification methods of differences between solution automation workflows, isolate into difference types, & add to variables determining difference between workflows to generate them

      - example of applying differences to generate alternate solution automation workflows (different routes to connect problem & solution)

        - standard basic workflow: 
          - trial & error
        - alternate workflow: 
          - apply 'trial & error' to filtered solution space of 'adjacent' solutions
        
        - the differences between these workflows include:
          - container structure (one workflow contains the other)
          - different position of components (position of 'trial & error' in one is different from position of 'trial & error' in another)
          - one workflow has an attribute applied to filter solution space ('adjacent')
        
        - these can be reduced to known interface component variables, even if the variables interact in a new way thats different from other workflows:
          - 'structure' variable including structures like containers & positions
          - 'workflow component' variable including other workflows, solution spaces, solution metric filters
          - 'core component' variable including attributes/functions/objects (like 'adjacent' attribute, which is relevant to intents like 'finding solutions quickly' or 'finding feasible solutions with existing resources')
          - 'interaction function' variable including interaction functions like 'apply' & 'filter'
        
        - so an example of generating a workflow from another workflow using differences between these two example workflows would involve applying three logic rules that can be used to connect the two example workflows, which can presumably connect/generate other workflows:
          1. 'apply workflow components as inputs of core interaction functions'
            - example application of this rule:'inject one workflow into the other'
          2. 'apply relevant core components like attributes to workflow components like the solution space to generate a different workflow'
          - apply any remaining general logic rules once the workflows are generated:
            3. 'filter generated workflows by whether they connect components in a way that can connect problem input & solution output'

        - other differences between alternate workflows may identify other variables that can be used to generate one workflow from another

        - solution success cause: why does this method work to generate different workflows?
          - analyzing 'differences' between workflows is by definition relevant to identifying variables between workflows, which can by definition be used to generate them
          - one workflow is a more abstract version of the other, and varying abstraction level is by definition applicable to many contexts like inputs, within a range

        - given these solution success causes (inputs of success of the solution), we can derive other methods to generate workflows:
          - 'abstract a workflow within a certain range of abstraction' (so it doesnt lose its meaning)
          - "apply definitions of relevant components to workflows like 'differences' with an interaction function like 'generate' that is relevant given their definition like 'variables'"

    - derive & apply workflow template/structure to fill with workflow variable values once interface analysis is fully applied to workflows
      - this means once components like standard/base workflows, common workflows & workflow patterns, & workflow variables are identified
      - this is an alternative to writing static function logic to design interface queries

    - derived alternate merged interfaces (like the meaning interface) to avoid sub-optimal metrics inherent to each interface perspective, where the problem can be adjacently solved
      - the 'survival' and 'evolution' perspectives have their own disadvantages, so merge them into an interface to avoid these disadvantages
        - 'survival' disadvantages include errors like 'over-identifying threats', from survival functions like 'constantly checking for threats'
        - 'evolution' disadvantages include errors like 'excess change, incompatible with other changes', from evolutionary functions like 'gene modification/activation/addition/movement'
      - applying the survival function 'check for threats' to identify a threat of the change type that is 'incompatible changes with other changes' is one way to merge those components on these interfaces (using the error of one interface to fix an error in the other interface, assuming no other errors are adjacent in these merged positions)

    - apply definition of any other components of the workflow that havent been applied in other solution automation workflows or workflow-generating workflows
      - an 'insight path' is a 'shortcut to find new useful info' so apply the definition of 'shortcut'
        - by definition, its a method that requires less work
        - so generate methods requiring less work as an initial solution space
        - solution success cause: this works bc of the overlap between the definitions of adjacence and efficiency
          - paths are 'efficient' bc they require less work, meaning they may use 'adjacent' resources (nodes or methods)

    - identify the shortest, lowest-cost, most adjacent or otherwise most efficient/optimized route/function to known solutions from problem definitions and identify patterns in these routes or the variables/components/structures/formats enabling them to be optimized (sub-interfaces, definitions, interaction levels), and generate function to iterate through those patterns based on usefulness for a problem definition, and apply those patterns

    - apply trial & error except with the injection of the concept of 'solution progress' as a filter of multiple methods attempted in parallel, derived from maximizing difference types based on filter capacity (solution progress assessed similar to learning from error/cost)
      - identify the most different structures you can apply (like directions of motion) and apply them iteratively, checking for progress toward the solution metric based on solution patterns of progress (accept costs of these types up to a particular threshold or other structure), and stopping the pursuit of any differences that dont match solution progress patterns

    - identify & apply alternative inputs (variables) of solution automation workflows to create other workflow-generating workflows, given the definition of 'generative' meaning 'an input to', and given that this workflow for the default inputs (variables) of workflows is already stored elsewhere, so this applies 'alternative' as a transform
      - example of alternative inputs:
        - to identify that a method is especially useful out of all the possible methods, you can use alternate variable sets:
            - start with solution metrics as limits creating the structure/template of a solution, and fill it in or work backwards
            - common components of useful solutions, or components of commonly useful solutions
            - adjacent combinations of available resources at the origin state (problem position)
            - core interactive components
          - these are alternates bc they have equivalent/similar input/output when applied to this problem of 'identifying a useful method in a large set of possible methods'
        - a function (structure of connections between specific inputs & outputs) can have alternate formats like:
            - a set of filters
            - a set of differences
            - a set of intents
            - a set of requirements
          - these are alternate versions of the function that dont lose info expressed by the function, and they can serve as alternate inputs to the function outputs, since the function itself is also an input

    - iterate through optimization priorities & apply other optimizations to workflows, like 'find alternatives to optimize for robustness', which when applied to workflows would generate the previous 'apply alternative inputs to workflows' workflow-generating workflow

    - apply useful interface components (like 'interactivity', 'ambiguity', 'incentive', 'contradiction', 'requirement') to fulfill core interaction functions (like connect, complete, reduce, merge) with interface structures for optimized querying
      - fulfill optimization intent 'avoid full interface standardization'
        - map interactive structures across interfaces for queries that support avoiding full interface standardization
        - map corresponding structures across interfaces to avoid standardization to an interface in case an isolated operation like 'identify one object' is needed
          - this allows for an efficient interface query that executes only the conversions necessary & keeps the processing on one base interface, pulling in isolated structures from other interfaces with sub-queries as needed

    - standardize interface queries & solution automation workflows to other interfaces (to avoid converting problem system to a particular interface just to implement a workflow)
      - apply other interfaces like 'structure' interface to specify a query/workflow and interfaces like 'concept' to abstract a query/workflow

  - finish list of useful interface components, including structures of useful interface components (like structures of specific useful concepts)
    - example: 'apply concepts to system interface to identify conceptual structures in system'
      - system
        - system structures of uniqueness: exclusivities
        - system structures of power: trigger, input

  - finish interface query design rules
    - 'if solution requirements arent given, derive/predict them or apply default requirements from related/similar problems'

  - example of different structures of an interface component on different interfaces
      - alternative
        - 'structural alternative': where one or more structures are options where one or the other or both if not mutually exclusive can be chosen (applied at a given time), with varying relevance/optimization, for a particular intent (like 'navigate in a direction', having structural alternatives in the form of a set of paths)
        - 'conceptual alternative': where one or more concepts can be applied at a given time with varying relevance/optimization for a particular intent (concepts with an intent in common)
        - 'structural conceptual alternative': alternative conceptual structures, like varying structures of power or balance
      - alignment
        - 'structural alignment': based in the structural interface, where a 'structural alignment' takes the form of an equivalence/similarity in components (attributes/functions/objects/structures), such as:
          - interchangeable attributes/functions/objects
          - a fitting/matching structure
          - a parallel structure
          - a structure having similar shape or other attribute like size
        - 'conceptual alignment': translated to the conceptual interface, an 'alignment' takes the form of concept such as 'equal' and/or related concepts like 'similar'
        - example of injecting the structural interface to components on other interfaces:
          - a 'structural conceptual alignment' is the 'alignment' in structures of concepts, like 'similar conceptual connections' or 'equivalent concepts'

  - document useful component/sub-structures of interface queries (interface components, interaction rules, cross-interface interactions, generative functions)

  - interaction rules of useful cross-interface or useful interface components (efficiencies/alignments)
    - to answer questions like:
      - with what 'frequency' can a 'random combination' of 'alignments' create an 'efficiency' in a given 'system'?
    - having variables:
      - solution formats
        - certainty (probability, frequency, average) 
          - format solution as 'certainty of a particular structure given inputs' rather than other formats like 'method to generate a particular structure given inputs'
      - solution filters
        - requirements
        - intents
      - problem space
        - system context
      - interactions
        - applicable connecting logic rules
        - attributes (random, adjacent, difference-maximizing, similar, opposite)
        - structures (combination, subset)
      - interacting components
        - useful components (alignments, efficiency)

  - identifying useful cross-interface interactions

    - examples:
      - 'merge difference types' function
      - 'common relevant efficiencies' structures
      - 'find simplifying/generative/change-generating function' function

    - how to identify useful cross-interface interactions:

      - structures of useful components from one interface applied to another interface
        - example: useful structure interface components (combinations) of useful system components (incentives, ambiguities) applied to other interfaces

      - useful interaction structures of relevant problem-solving structures (like core interface structures or problem interface structures like errors)
        - 'merge' is a useful interaction structure of error structures like 'difference types'
        - 'common relevant efficiencies' combines multiple useful interface structures/attributes to create a useful structure for 'fulfilling an intent', which is relevant to 'problem-solving'

  - document useful structures & generative functions of cross-interface interactions (like structure-concept interactions)
    
    - example:
      
      - structures that generate function to 'merge difference types'
      
      - structures with conceptual attribute 'relevance':

        - a 'database index' structure gathers & searches just the information useful for 'find' intents based on structures of standards like 'what is commonly searched for' and 'what varies across data' and 'what combination of fields uniquely identifies/differentiates data', so it can be used to fulfill intents like:
          - intent: 'identify unique records'
            - fulfills 'unique combination' standard
          - intent: 'find records quickly by only searching relevant data'
            - fulfills 'what is commonly searched for' standard
          - intent: 'differentiate records'
            - fulfills 'what varies across data' standard
        
        - applying the above structures of standards as solution filters can find the 'database index' structure in the 'search database' problem space

        - the solution creates an efficiency for the 3 'search database' intents, while creating inefficiencies for the 'minimize storage' & 'generalize solution' intent
          - these intents could be fulfilled with modifications to the 'database index' solution:
            - 'minimize storage': store static values in a nested index
            - 'generalize solution': apply 'database index' solution dynamically or for other queries or query types

        - interface query to generate implementation of this cross-interface interaction
          
          - identify variables
            - core variables
              - data set format
              - data set stores
              - data set store format
              - data set store fields
              - data set store records
              - search method
              - sort method
              - storage method
              - query
            - variable combinations
              - data set/store-query relation
              - search-sort relation

          - apply requirement filters to solution space:
            - iterating data of some format is required
          
          - apply variable expansions to solution space:
            - apply probability interface to 'input/output formats' structure: 
              - data doesnt have to be in original input format or output format of 'common' queries
            - apply change interface to 'input/output formats' structure: 
              - data doesnt have to be in a static format
            - apply structural interface: 
              - data can be in 'multiple' formats
              - data 'subsets' can be stored in addition to the 'complete' data set

          - apply structure filters: 
            - what structure in the 'search database' problem space can identify unique field combinations, enable quick searching for common searches, and differentiate data (even if it differentiates them incompletely, or to a contextual definition of 'differentiate')

            - apply differences to variable values to generate core adjacent combinations of variable values
              - store subset of rows for a query type (search only these rows for queries involving these fields/operations/conditions/values)
              - store subset of fields (search only these fields)
              - store subset of example rows with allowed variation (search for these examples for these queries & anything adjacent to the example)
              - store data patterns to search for a query (search for these patterns for these queries)
            
            - filter combinations by usefulness for 'search database' problem intents
              - apply filter with 'system optimization' ('only add required functionality')
                - which of the combinations fulfills the above 3 intents without fulfilling extra unnecessary intents (aligned demand/supply of intents)

  - ml explanation of finding coefficients of prediction function by applying distortions to coefficients & ruling out distortions that dont contribute to prediction accuracy
    - can be optimized with reductions like:
      - 'calculating the most different distortions that will reduce possible values the quickest & applying those distortions'
  
  - proof/determination structures
      - what makes something possible to determine/calculate
        - a solution structure where the solution metric is clearly defined (structural or having other structures of certainty like consistency or inevitability or requirement)
          - checking a path to see if it includes a node twice is clearly defined (it uses the structure of 'node visit counts' in the 'path' solution structure)
      - what makes something difficult to prove
        - where there are ambiguities (lack of certainty/structure/definition) between the input parameters & the output function value
          - ambiguities such as where multiple inputs produce the same output, like how different x-values can produce the same y value on a wave function
      - useful proof structures
        - apply possible components to create an absolute or scalable definition include components framed in terms of interactions with other components that can be used with a consistent measurement (like a stable structure across interfaces or dimension sets) & can also scale (boundaries), rather than framing them in terms that can have different meanings at different parameters (closed, hollow)

    - add to causation variables
      - ability to change (if a variable cant be changed, it is less causative for problem-solving intents)

    - give examples of identifying vertex variables
      - general vertex variables: topic, origin/destination, reason/cause/point/intent, errors, variables, types
      - comedy vertex variables: sincerity, stupidity, stakes, tension-resolution/expectation-subverting pattern variation
      - music vertex variables: tone, tension-resolution/expectation-subverting pattern variation, lyrics
      - optimization metric vertex variables: solution metric patterns (what other solutions optimize for, to determine optimization metrics to apply)

    - when is it optimal to store a mixed structure of varying specificity (like a type, intent, cause & a specific example)
      - when there are potential uncertainties to resolve, like whether the example represents a new error, type, or variable, bc the example doesnt fit known structures

    - all primary interfaces can act like the problem-solving interface (start solving problem from the concept or structure interface and integrate all info back into that interface & frame the solution in terms of that interface) but the meaning interface (the interface interface) is the most powerful

  - visualizing higher dimensions with changes in a network of visualizable variable subsets like:

    - dimension subsets: displaying dimension subsets in groups of sizes that are already visualizable (from 1 - 4 dimensions), where orthogonality is preserved across the network of subsets
    - dimension groups: grouping similar dimensional changes into a change type across a dimension subset, to visualize the change types
    
    - relevant (robust) dimensions
      - dimension invalidations: grouping invalidating/neutralizing change types
      - causative dimensions: just visualizing higher-impact/causal dimensions
      - vertex dimensions: graphing variables as differences from vertex variables
    
    - mapping dimensions: group value sets as other structures like points or networks in a space where change types like 'continuous change' are supported
      - embedded dimensions: dimensions graphed visually using extra dimensions as parameters
      - base dimensions: dimensions standardized to a base and graphed in alignment, like multiple functions on a graph with a common base
      - mapping other dimension metadata: interactions between dimensions units/change types/limits/definitions are graphed
      - abstract dimensions: abstract value structures are graphed ('a point on a line') instead of specific values in a dimension
      - constant dimensions: adjacent limiting constant dimensions are graphed instead of dimensions of change

    - dimension interactions: 
      - interactive dimensions: dimensions that interact are condensed into an input/output of the interaction structure, and input/output dimensions are graphed instead
      - dimension interaction structures: structures of interactions between variables (like direction/circuits/networks) are preserved, where values may be lost
        - dimensional difference: difference between dimensions is graphed instead of different dimensions & values, where dimension values are structures associated with graphed dimension interactions
        - conversion requirements: conversion requirements to a visualizable shape are graphed instead of actual dimensions/values
        - interaction structures between value structures like positions on dimensions when graphed as a standardized shape
          - example: with dimensions formatted as a standardized form like 'lines of equal length, & values as points on these lines', the interaction structure would be the lines connecting the points on the dimension lines, when arranged in any order

    - example of resolving a conflict between structure/limits using a structural similarity between a structure (gradient of function) & its container/limits (gradient of constraints)
      - https://en.wikipedia.org/wiki/Lagrange_multiplier
      - also an example of a solution space (the whole function is the solution space of possible minima/maxima) and a filter applied to it (constraint)

    - make a function network of math domains (inputs/outputs of geometry, algebra, calculus that align)

    - resolve definitions of components so you can finish organizing useful structures like combinations of concepts such as "format sequence", "solution automation workflow", "insight path", "reverse-engineer solution from problem requirements or opposite structures", "connect problem & solution"

    - example of how to generate monopoly case arguments
      - change variable 'location of power':
        - spotify is welcome to build their own app store with their own phones or team up with their coalition to do so
        - add variable 'time sequence' to 'location of power' change:
          - if spotify operates an app store someday, they will set rules to benefit themselves too, just like theyve done in the past
        - offer an alternative to charging app store rate
          - is there a one-click button to migrate from spotify to apple that could replace any difference in taxes on spotify
      - apply conceptual definition filter 'does concept of persecution (and related components of the definition like focus) apply to the behavior (does behavior have a specific target that is the focus of persecution)'
        - are apple's rules applied exclusively to spotify? if not, it's not anti-competitive behavior
      - apply intent filter
        - is spotify's mission nobler than apple's
      - apply system cost-benefit analysis
        - what features were improved bc spotify exists? are those features worth anything or required needs? did they develop those features better than competitors?
        - if spotify is just charging rent on a catalog, are they adding value to the market, so they should be allowed to dictate the market at all?
        - what products/features would apple develop if they didnt have to pay a fine, and what are those features worth, and are those features required?
      - apply logical fallacy filters
        - apply 'hypocrisy' filter
          - apply 'anti-competitive' conceptual definition structures & test if these structures fit the opponent
            - does spotify plan on raising prices at some point or will they keep prices low even if the app store rate holds? are they only keeping prices low to dominate the market & plan on raising prices later? isnt that anti-competitive behavior?
            - if they are so concerned about anti-competitive behavior, why arent they trying to compete by building their own app store? isnt there a risk that the apple app store is sub-optimal and needs to be improved with competition from spotify

    - value isnt created/lost by companies in the timespan of hype/short cycles, so stock market price swings aren't reflective of reality from a macro perspective
      - it takes years to build value, it doesn't happen overnight, excluding almost magical insights that create cascading efficiencies like my system
      - losing value also happens slowly, excluding extreme natural disasters, like the value of a community still being relatively high despite shared losses, bc of social network effects & organization/coordination effects
      - value can be calculated differently, using metadata like the lifetime & total possible value of a product
        - what is the total supply of the product inputs (fossil fuels)
        - what is the usability lifetime
        - what are the costs
        - what are the product intent alternatives (can intents fulfilled by the product be fulfilled by other products)
        - what is purchased with revenue from a product (research, insights, other more valuable resellable products, etc)
        - if this pricing method is applied to fossil fuels, oil companies would be paying people to use them

    - identify filters for definition routes

    - database polling/prompting user for update & predicting updates or searching for & receiving user-approved updates from other services, rather than being a passive receiver of input from user
      - based on local usage/change patterns or integrated usage patterns to identify expected transactions with other services
        - once a credit card is marked as lost in a banking service, a change of credit card numbers is expected by other services which can poll for updates to this flag
          - user option like 'yes, allow other approved databases containing my address poll to collect this update'
        - once a renters insurance policy is changed in an insurance service, a change of address might be expected by other services

    - make list of variable structure variables measured by algorithms & why they are measured by a network algorithm

  - make diagram of absolute reference connections with metadata structures like networks/paths
  - determine core graph variables (definition of adjacence/difference, connectivity, dimensions, info storage methods, interactivity of structures like sequences)
  - crypto as community consensus, where a decision can have value if backed by a community

    - examine connection between fractals, sequences, averages, origins, multipliers (self, as in power), & circles
      - fractals as a relevant structure for adding sequences of fractions (adding numbers similar to itself on a smaller scale, infinitely) as a way of producing inputs to circles created by transforming a fractal spiral, where the origin is the original number as a base for applying increasingly smaller scales
      - the set of points forming roots of an infinite negative number sequence (roots of unity, rather than roots of any negative integer number) as a way of producing a circle because of their common distance to their average (center) forming the radius
      - lines of equal length having a common average point (center/origin)
      - fractals & infinite sequences as a way of calculating area under a continuous line (increasing small subsets of structures with area calculatable with multiplication of x & y)
      - what continuous line segments would have an area equal to a circle of relevant proportions?

    - how to identify the killer counterpoint
      - point: 'election fraud claims'
        - counterpoint: you dont think the other party has members?
          - followup points:
            - how are they organizing? why do you even hear about them?
            - who's benefitting from investing massive funding in creating a false illusion, if its all fake?
            - why wouldnt they choose cheaper methods of doing so than an elaborate illusion?
      - identify most extreme false assumption of point by identify causes of the output metric (vote count)
        - the primary/basic false assumption of the point is that the other side doesnt have votes that are comparable in quantity
          - possible causes (inputs) of 'not having similar vote count' include:
            - not going to vote
            - not being able to vote
            - not having members to vote
          - the most extreme false assumption is the most extreme cause of 'not having similar vote count' (that the other side doesnt even have members (input of votes) that are comparable in quantity, let alone votes (output))
      - identify 'incentives', 'side effects of party/member/vote existence & size' as other relevant concepts to generate followup questions

    - the work of 'stealing my work' and 'pretending not to' doesnt produce efficient brains with a good grasp of concepts like 'meaning', so it emerges as an inefficiency bc the type of brains developed wont be good at finding solutions to output problems generated by granularly copying/pasting to a specific problem/solution & hoping it works better
            - 'understanding my work' is a better goal if you cant look away bc youre not done experiencing awe
              - once you understand it, you wont need to watch me work, youll be able to generate my work
  
  - apply nn to derive error types & bias incorporated into other nn data/parameters/algorithms/structures/models    


## general

  - integrate objects/.md text with interface implementations

  - apply to structures

    - concept of attention in structures
      - mixed interim high-variation & high-similarity structures tend to maximize attention
    
    - examine error type of conflating intent & requirement
    
    - consciousness as choice to move between neural nodes (rather than being directed) required:
      - the development of alternative node paths performing equal/similar functions, requiring:
        - the development of excess resources, delaying required decision time (making immediate decision unnecessary, avoiding a forced decision), requiring:
          - the existence & application of previous efficiencies & functions for alternative evaluation, energy storage, storage-checking, & energy requirement-identifying
      - the cause could be framed as structures such as an 'efficiency stack' or 'energy maintenance functions' or 'alternative options' or 'navigation/motion control' or 'lack of requirement/need'
    
    - examine similarity (alignment/overlap) structures between: 
      - extremely different components (when an error type is an incentive or a function used for other intents) 
        - when the solution format of some problem has similarities to the error type, like when you need randomness so errors generating randomness are a possible function to use for that intent
        - contradictory/opposite components (have some metric in common, with opposite values)

  - finish organizing lists of examples, functions, info objects (insight paths, definitions, questions), components for configuration

    - organize examples

      - label examples so they can be queried more structurally
      - query for logic in examples when implementing functions
      - organize examples of useful structures & questions in index.md
        - identify useful questions in notes
        - check reduced language components for any other useful functions (what terms cant be adjacently, clearly & accurately framed in terms youve defined) for completeness


## examples


  - examine the distortion vector paths that adjacently decompose a data set into a prediction function from a base point/function set

  - give example of mapping to structures & identifying contradictions its safe to ignore for applying a structure

  - example of permuting assumption: "reports of power consumption have to be exact measurements" 
    - a temperature monitor sensitive to a hundredth of a degree might provide similar but non-specific power reporting for important/extreme usage patterns without revealing such specific information as that which could infer exact operations being done, bc the interval of temperature measurements allows for greater variation in calculations that could explain it
  
  - query examples for use cases like:
    - lack of information stored (match problem of type 'information lack' with interface query 'check pattern interface for similar patterns')
    - query problem breakdown & integration diagram
    - calculating various different problem breakdown strategies first before executing normal query-building logic for each
  
  - add examples of system/object/rule/type change patterns
  
  - include example workflows with example problems
    - include example of how to generate other workflows (different starting/ending points & trajectories)

  - example of using set theory in query operations:
    - edges as core organizing/formatting operations (find/apply) & interfaces (connecting/explanatory concepts/functions)
    https://en.wikipedia.org/wiki/Hypergraph

## diagram
  
  - diagram with error types
  - diagram of the network of formats
  - make efficiency map
  - diagram of alternate interfaces (information = combination of structure, potential, change or structure, cause or structure, system)
  
  - give structural query example diagram for GANs + image compression problem

  - chart type: overlaying multiple 2-dimension variable comparisons to identify common shapes of variable connections (density of points added with a visible attribute like more opacity)

  - finish core function structure example diagrams

  - diagram with joke types
    - 'annoying when they bring up human rights in a conversation'
      - conversation system context
        - functions
          - change topic 
            - change topic structure (sequence)
              - introduce a topic (first time topic is included in conversation)
          - expected interaction functions
            - criticism of a behavior
              - 'conversation with dictator' system context
                - criticism of power abuse (law violation, specifically human rights violation, which are a related object to dictators)
                  - interpreted as right in the 'conversation with dictator' system context
                    - expected interaction in this context
                      - 'should bring up human rights to a criminal'
            - norms:
              - for low-stakes interactions & interaction errors (manners, annoyance, disrespect)
            - laws: 
              - for high-stake interactions & interaction errors (rights violations)
        - placing a norm (or related objects) in the place where a law (or related objects) would normally go:
          - 'its annoying when someone doesnt let you end the conversation'
            - 'its annoying when someone keeps going on & on about your previous conversations where you ordered deaths of a dissident'
              - 'its annoying when someone keeps going on & on about your previous conversations where you ordered deaths of a dissident for being annoying & then abruptly stops without explanation'
            - 'its rude when someone doesnt let you end a conversation with a laywer interrogating you for war crimes' 

  - diagram for structures of emergence
    - example: 1-1 input/output relationship up an interaction layer, where extra resources that dont dissolve immediately on the higher interaction layer aggregate & form core structures like combinations, where interactions between combinations & sequences have different dynamics than the individual output interacting with other individual outputs
    - emergent functionality/attributes come from interaction structures (sequences & layers)

    - add diagram for intent-matching
    - add structures to diagram: interface overflow (to sub-interfaces), interface foundation
    - diagram for workflow 1: 
      - function to determine relevance filter ('functions', 'required') from a problem_step ('find incentives') for a problem definition, to modify problem_steps with extra functions/attributes ('change_position') to be more specific to the problem definition ('find_incentives_to_change_position') for problem_steps involving 'incentives', so you know to use the function_name to modify the problem step if it's between the type 'functions' and the object searched for 'incentives'
    - add conceptual math interface query diagram
      - use lattice multiplication as standard example, other than core operations (add/multiply mapped to language, concepts like irreversibility/asymmetry mapped to math)
    - interface conversion, matching, starting point selection (applying structure, checking if relevant information is found)
    - diagram to document sub-functions of core functions with distortions
    - make diagram for dimension links higher than 3d that are depictable in the same network space
      - should show variables that impact other variables, the change rates of these relationships
      - overall impact should be calculatable from these relationships
      - should show similar movements for correlated variables
      - should show skippable/derivable variables (variables that can be resolved later than they normally are)
      - should show meta forces for overall trends in change rules (direction of combined variable forces)
      - should show limits of measurability & threshold metrics

    - diagrams for specific concepts, core functions, concept operations (combine, collide, connect, merge, apply), ethical shapes
        - variable accretion patterns (how an object becomes influenced by a new variable, complex system interaction patterns, etc)
        - make diagram of potential matrix to display the concept
          - map parameter sets to potential matrix shapes 
        - finish diagrams for cause (shapes & ambiguity), concept (evolution of concepts, networks, distortion functions)
        - diagram for argument
      - make a system layer diagram for each interface to allow specification of core interfaces & other interface layers (interface interface)
        - make a system layer diagram for structures to include layers of structures 
          (beyond core structures like curves, to include n-degree structures like a wave, as well as semantic output structures like a key, crossing the layer that generates info structures like an insight, a probability, etc)

    - map variable structures to prediction potential for problem types, given ratio of equivalent alternate signals

    - vertex variable structures
      - quantum physics, prediction/derivation tools, build automation tools, testing tools, learning/adaptation tools, system rules, computation power are all vertex variables of information, since they can generate/derive/find information
        - which structure (sequence, network, set, or cycle) of vertex variables is most efficient

    - core component attributes: identify any missing attributes/functions that cant be reduced further

# content/config

    - import insight history data to identify insight paths (info insight paths like 'lie => joke => distortion => insight', system insight paths like 'three core functions + combine function with this definition + n distortions to nearest hub')
    - define default & core objects necessary for system to function (out of the box, rather than minimal config necessary to derive other system components & assemble)
      - add default functions to solve common problem types
      - alternate utility function implementations have variation potential in the exact operations used to achieve the function intents, but there are requirements in which definitions these functions use because they are inherent to the system. For example, the embodiment may use a specific definition of an attribute (standardized to a set of filters) in order to build the attribute-identification function using a set of filters - but the general attribute definition is still partially determined in its initial version by requirements specified in the documentation, such as a set of core attribute types (input, output, function parameter, abstract, descriptive, identifying, differentiating, variable, constant), the definition of a function, and the definition of conversion functions between standard formats.
    - document time structures (concave time explaining compounding similarities up to a point of maximum concavity, a structure that can separate from the other space-times)
    
    - systematize definitions of info objects, to include analysis that produces relationships of core objects like opposites to their relevant forms (anti-symmetry) in addition to permuted object states (asymmetry), such as an anti-strategy, anti-information, anti-pattern
      - organize certainty (info) vs. uncertainty objects (potential, risk, probability)
      - make doc to store insight paths, counterintuitive functions, hidden costs, counterexamples, phase shift triggers
      - add technicality, synchronization, bias, counterintuition, & certainty objects leading to inevitable collisions
        - error of the collision of compounding forces producing a phase shift
        - lack of attention in one driver and false panic in a second driver leading to a car crash given the bases where their processes originate
      - define alignment on interfaces (compounding, coordinating, parallel, similar, etc)
      - add core info objects (core strategies, core assumptions) so you can make a network of graphs for a system
    - concept analysis:
      - how new concepts (gaps in network rules) evolve once structure is applied to prior concepts 
    - interface analysis:
      - limitations of interfaces & how to derive them
      - how rules develop on stability & how foundations are connected & destroyed
      - explainability as a space limited by derivable attributes from data set & cross-system similarity
      - vertex definition & give examples (as an intersection/combination of interface variables, such as determining/description(compressing)/generative/causative/derivation variables), around which change develops
    - change analysis:
      - generated object change types
        - constant to variable
        - variable to removal of assumption in variable type/data type
    - examine implementing your solution type (constructing structures (made of boundary/filter/resource sets) to produce substances like antibodies, using bio system stressors)
    - resolve & merge definitions into docs/tasks/implementation/constants/definitions.json
    - update links
    - integrate archive_notes/finder_info/functions
    - de-duplicate logic
      - organize interface analysis logic definitions
        - organize functions in problem/interface definitions, before organizing functions in implementations/*
      - integrate problem_solving_matching.md
      - integrate find/apply/build/derive logic from system_analysis/ & maps/defs*.json
      - separate interface analysis logic into implementation/functions (functions dont need unique info)
      - add functions from workflows & analysis (to do list, questions answered, problems solved, interface definition & functions) as files in functions/ folder
        - organize into primary core functions & list sample parameters (like objects to identify for the identify function)
      - integrate rules from diagrams in patent applications to relevant documents
            

- examples
      - joke mapping insight paths
        - unlikely hypothetical
          - several degrees of assumption chains to generate an unlikely hypothetical (sequence of assumptions from a starting assumption/premise, generating a background story/context)
            - serious + petty + important: 'none of us can figure out why he tucks in his tie'
              - implies that the problem was so serious that a discussion happened to investigate & research it to fix it
              - implies that no one is allowed to ask him or has the courage to ask him directly, implying he's powerful in some way & cannot be questioned, which implies these are his subordinates who are not doing work in order to discuss this, which implies this could cause their work arrangement to be invalid 
            - 'none of us ever figured out why he tucked in his tie'
              - repeated + important: implies that the discussion was repeated bc it was such an important matter
            - 'none of our lawyers or R&D staff ever figured out why he tucked in his tie'
              - important: adds another level of importance in that they hired an expensive legal team to investigate the matter for liability/indemnity/litigation potential as if it made the company look so bad they had to hire a legal team
            - "the tie-tucking survived ex-girlfriends' interventions"
              - important: it has ruined multiple relationships with people who cared about him who tried to stop him from doing this to himself
              - briefer than previous version & uses more evocative verb
              - different: 
                - add assumption: assumption that the audience is rooting for the tie-tucking to continue
                - add concept of 'agency': attributing personhood to the tie-tucking, which is fighting for its life against cruel monsters
            - 'even after being accused of being a double-tucker who tucks his tie but not his shirt, he persisted'
              - important + petty + similar: fashion is a petty thing to care about this much, and a special jargon term 'double-tucker' implies a whole community or sub-culture based on or caring about this issue or related issues, which he has caused controversy in, with added importance by association from term 'double-agent', typically reserved for high-stakes situations like foreign wars, as if he's betraying someone or his heritage or group or people who rooted for him, and rhymes with a curse word
            - 'the mysterious tie-tucker left the board of directors' 
              - important + reduced: condensing the entire story into a brief structure like a nickname and casually referencing it despite the importance implied in a problem that generates a nickname
        - topics
          - conspiracy theory (a muffling device to prevent the Chinese from listening to his balls chafe for blackmail material)
          - cults/ex's (definitely worshiping the wrong things)
        - total opposite: 'your fatal flaw wasn't so much all the excessive drunk online shopping purchases at the police store & the corporate sabotage so much as the curtains from korea that spied on us & posted our arguments to porn sites' (it was absolutely the excessive spending at the police store)
        - changing definitions to very different alternate definition
          - 'tucked in his tie' or 'used unnecessary protection' or 'packed heat'
        - resolving awkwardness
          - 'i dont hate your dick pics (introduces the problem, 'uh oh does she hate my dick pics'), I just think theyre (foreshadowing something that seems like a difference but is actually similar) more optimal when directed at enthusiasts (or professionals), such as doctors/researchers, who might appreciate it more than I ever could (optional: from a curiousity perspective)'
        - mixed contexts/styles
          - talking about an unimportant matter in the same terms used for important matters
            - 'his parents couldnt deal with the idea of confrontation so they gently let him lose touch rather than disowning him outright' 
        - adding relevant structures of meaning like:
          - aligning layers like double entendres
            - calling him a 'magician' bc they have a function of 'hiding scarves' which is similar to 'tucking a tie' bc 'tucking' has a related output of 'hiding'
        - defeating the purpose/self-defeating
          - listing all the manipulations youre using, while using them, to the target 
        - false dignity/over-generousity
          - calling him a 'international man of mystery' bc its a very dignified way to portray having mysterious fashion habits that defy analysis from subject matter experts
          - 'he must be doing it to scare away women bc theyre always chasing him'
        - injecting stupidity/extremes
          - he thought it would act like a talisman to protect him from rape or unwanted pregnancy
          - he was told by a foreign holy man (has association with 'wise foreigner' stereotype) that it would protect him from fertility like a 'cosmic condom' (repetition, catchy) 
        - removing a point/agency (its not an intent, he just had the clingiest underwear/reproductive organs known to mankind)
        - fitting with existing systems without obvious contradictions
          - 'using existing phrases in a new way with minimal distortions' is surprising bc its unlikely to find a new distortion of an existing component that someone hasnt tried, so the simpler the better for this type
