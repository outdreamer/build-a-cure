  - algorithm to mathematize (apply math structures to) an info problem

    - apply point structure: find examples
    - apply set structure: find combinations
    - apply boundary structure: find limits (systems, shapes, expectations)
    - apply gap structure: find possibilities (opportunities)
    - apply sequence structure: find paths
      - apply input structure: find assumptions (requirements)
      - apply output structure: find intent (side effects)
      - apply function structure: find connections (cause)
    - apply origin structure: find symmetries (equivalence)
    - apply vector structure: find differences (comparisons, opposites, errors, distortions/imbalances)

      - identify vertexes & transform input info to vectors for each vertex
      - identify interfaces & primary interface objects & transform input to vectors for each vertex
      - apply queries across vector spaces to find patterns of change that produce solutions optimally (quickest or most accurately)

      - integrated info format for formatting vectors across vector spaces representing differences within an interface/vertex variable
        space1.vectorA (magnitudeA, directionA) = space1.basis vector coefficient combination
        spaces.space1.vectorA = spacevector.vectorA = vector differenting from other spaces
        [space coefficient combination].[vector coefficient combination]
        [space topology position].[vector topology position]

      - in this format, you store info about the original vector with its relative position to other vectors given the basis vectors of that space, and info about the original space with its relative position to other spaces

        - each space offers a relative position for differences in an interface

        - given the set of vectors mapped within each space, the vertex vectors of the original differentiating vectors can be mapped as the vector space instead

      - alternative vector formats/variables
          - vector paths: store method to generate a particular vector
          - vector boundaries: store info about vectors with similar interaction layers (like 'interacting with a sphere of radius 1')
          - vector gaps: store info about a space lacking vectors in a vector space
          - vector bases (core sets): store info about alternate basis vector sets describing a vector space according to different bases of change units
          - vector shapes: shapes formed by vectors (points, polygons, shapes, corners, angles, centers, intersections)
          
      - the vectors may be more efficiently described in one format than another, within or across spaces
        - to integrate the vector spaces that have had these formats applied, you can:
          - maintain the original space and describe the vector variables with the new vertex vector sets
          - create new vector spaces to map the differences in that variable
        - if the differences dont hold across every vector space, you can:
          - calculate the contribution of that space in another space where it would contribute to those difference types (apply elements in a biological space)
          - find a space where both the non-contributing vector space and the contributing vector space can be differentiated & calculate it there (genes & elements in an evolutionary space)

    - example of mapping math to meaning formats
      - structural math info formats according to intent to calculate semantic operations (solve info problems) 
        - add to shape definition routes with matching intents supported by each
          - adjacent intents use the objects directly stated in the definition route:
            - endpoint alignment
              - adjacent intents associated with this format:
                - use endpoints & rotation/shifting transforms to build a shape
                - complete a shape using a line and an 'align endpoint' function
                - store just endpoint & alignment info
                - use an angle determining function to provide input to an alignment function
                - keep coordinate info intact after transform
                - track changes within space using endpoint/line coordinate changes
                - use core structure (line, angle) as a building block
            - coordinates of one corner & side length
            - side count & angle
        - these intents can be mapped to meaning
          - "align endpoints" = "connect" (such as in the case of "connect a line to a shape missing one line to be completed")
          
        - once mapped to meaning, it is clearer how these structures can be used to calculate other metrics
          - in the "connect a line with a shape to complete a shape" case, its good if we already stored info as coordinates & lines, bc then we can adjacently pick a line & place it in the right position to complete the shape, by aligning coordinates of endpoints
          - this structure can be applied to info problems
            - testing for obviousness of an argument:
              - 'obvious' math structure definition route:
                - adjacent change:
                  - if an argument can be made by connecting a line to complete a shape, that's an "adjacent" change, and it can be considered obvious using this math structural definition route
                  - forming a square with two triangles is an 'obvious' way to make an argument that 'two triangles are equal to a square'

                - example of formatting an argument as a shape
                  - a, b, c, d are points on a square, starting from top left and going clockwise
                  - side length: degree of difference
                  - side line: change type with direction from starting point to end point
                  - change type: straight line, constant, tangent, border, etc
                  - right angle: independence (difference in change type)
                  - ad is similar to ab by starting position, but different by independence (in change type & direction)
                  - ad is different from bc by starting/ending positions, but have similar change type & degree, and are connected in two ways by one degree

                - inevitable conclusions map adjacently to filters with one possible output structure indicating the relationship of the conclusion objects

                - logical conclusions are buildable from other logical conclusions or insights (known connections) with accessible transform operations applied

    - another example, in reverse (meaning to math)
        - relevance: 
          - info that fits in a system (connects coordinating inputs/outputs, changes on system variables, has an intent position/function in the system, doesnt contradict system intents)
            - info that is useful for a defined/structured input intent
              - implied in this definition, specifically the 'defined' part, where the structure of the input intent definition determines what can fit it, is the concept of 'focus', which has a 'filter' structure, meaning only some info will be relevant to the input intent, and other info needs to have the filter definition structure applied
              - so an implementation of a relevance testing function will incorporate a filter structure or an equivalent substitute

    - example of a vertex of a structure, like vertex vectors
      - the integrating structure organizing these structure formats (alternate, identifying) of a structure (vector) forms a complete description of a vertex, which can be indexed on a vertex vector space

      - abstraction
        - what vectors can be used to describe the vector generalization (like a vector in the vector type space)
      - alternate
        - what vectors can be an alternate for it (like an alternate route forming another vector)
        - substitute
          - what vectors can be a substitute for it, in what conditions
      - generative
        - what vectors generate it (input vectors + generative vectors)
      - determining
        - what vectors determine it (input vectors)
      - contradicting
        - what vectors oppose its direction
      - neutralizing
        - what vectors invalidate it
      - balancing
        - what vectors balance it (toward some equilibrium like a symmetry)
      - limiting
        - what vectors limit/bound/constrain it
      - grouping/integrating
        - how does it combine with other change types
        - connecting
          - how does it connect to other changee types
        - integrating
          - how does it merge with other change types
      - minimizing/averaging/maximizing
        - how to get to zero
        - how to get to average
        - how to get to infinity
      - causative
        - what vectors cause it (consistently triggering inputs)
      - optimizing
        - what vectors optimize it (generate it or maximize it efficiently)
      - core
        - what vectors can be used to construct it using a structure (like a sequence or set)
      - common
        - what vectors are common to it & other vectors
      - distorting
        - what vectors distort it from some base vector (like a core or common or average vector)
      - identifying
        - what vectors can be used to identify it 
        - differentiating
          - how to maximize difference
        - approximating
          - what vectors approximate it
        - compressing
          - what vectors efficiently compress it without losing info
          - what info is lost with what compressions
        - expanding
          - what vectors efficiently expand it
      - originating
        - what vectors connect it or position it at which origin