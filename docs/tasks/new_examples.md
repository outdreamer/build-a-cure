## definitions

	- 'error' may be used interchangeably with 'problem', except that 'problem' is intended to refer specifically to program input, unless used to indicate an 'error'

	- where the general structure (like 'problem-solving intents') is used, the specific structures (like 'applying solution filters') may also be referred to by default, and vice versa

	- interaction structures
		- connection structures
		- relating structures

    - problem-solving intents include:
      - core interaction functions
      - applying solution filters
      
    - problem-solution components include:
      - solution space
      - problem space
      - related problem network
      - problem input & solution output formats
      - solution metric filters

## solution automation workflow insight path variables

	- success cause metadata to solution automation workflows
	- counterexamples and/or contraindication structures
		- indicate where a solution automation workflow is contraindicated, bc of inputs like problem type or missing info or nonadjacent formats relative to other more adjacent formats
	- example application to a problem
	- example specific interface query implementing the solution automation workflow
	- associated interface query variables
		- standards to apply before applying the workflow
		- interface query variable values optimal for implementing the workflow
	- solution automation workflow implementation variables

## examples of solution automation workflow insight paths

	- specific examples of prior solution automation workflow insight paths referenced in patent application 17301942 & PCT application PCT/US21/70425:
		- solve problem by changing structures (like position) of interface objects, like functions & variables
			- solve problem by changing structures (like position & alignment) & relevant attributes (like complexity) of interface components, like functions & variables, using change optimizations (like adjacence), to find if updated structures fit the target structure
		- use exclusively solution with known biases & error types so output can be corrected with logic from the associated solution type
			- use only solutions with known biases & other error types so the output can be corrected with logic from the associated solution type to correct those errors, or only solutions that are different from solutions with known error types
		- identify similar systems & solutions used to solve the problem in those systems, then convert & apply solutions from similar system to original system
			- identify similar systems & solutions used to solve the problem in those systems, then convert & apply solutions from the similar system to the original system
		- apply solution format and reverse engineer solution:
			- apply solution format (or 'solution template structure') & reverse engineer structure (like sequence) generating solution
		- apply both the generate solutions method & solution format method and connect them in the middle
			- apply both the 'generate solutions' method (starting from problem definition) & apply 'solution format filter' method (starting from solution definition) and connect them in the middle (rather than connecting origin problem to target solution)
		- find an example & generalize
			- find an example/counterexample & generalize to find robust solution
				- find general method & specify to create a testable example
				- example of a successful prediction function & example of an unsuccessful prediction function & connect them to find changes applied to create either from the other, which will reveal causation of function success/failure
		- identify vertex variables first & approximate
			- identify vertex variables first & derive other variables with vertex variables to create approximation function
		- identify problem types & corresponding solution aggregation/integration method for that set of types, then apply
	 	- generate & apply other interfaces with interface components (connection, requirement, structure, abstraction, set, independence)
			- interfaces have common components/variables (like interaction functions, bases, concepts, structure, types) which can be used to create alternate interfaces
				- example:
				 	- combine info, 'time' base, & types to create a new interface, combination interface, or interface structure
				 		- 'type state network'
				 		- 'network of contexts/conditions/assumptions'


	- apply interface query that is likeliest to capture the most different/verifiable/incorrect info, which can be quickly tested for relevance or used to filter the solution space the most efficiently

	- solve problem by removing problem structures (remove structures of conflict, error, bias, limits, over-prioritization) or adding solution structures (add structures of organization, relevance, efficiency, like aligning with intent & connecting to/building on a logical foundation) and integrating these structures with neutral structures like interaction layers and systems
		- identify useful structures (like combinations) of useful cross-interface concepts (like difference, energy, vertex, random) to use as conceptual attribute interfaces to solve a problem on
	
	- identify useful structures for converting problem structures into solution structures, & apply to problem space to derive solution structures
		- attribute structures
			- opposite structures can produce solution structures bc problems may be completely different from solutions
				- for a problem like 'functionality overlap', the opposite structure is a potential solution structure 'separation of functionality using exclusivity/uniqueness'
			 	- efficiency/simplicity structures can produce solution structures bc problems may be inefficiencies/complexities
			 	- alignment structures can produce solution structures bc problems may be solutions once components like direction are aligned (like 'conflicts of interest' with conflict between incentivized & correct/required direction)
			- combination structures can produce solution structures bc problem combinations may be a solution
			- reduction structures can produce solution structures bc lack of problem variables may be a solution
			- filter structures can produce solution structures bc a problem space may be a superset of a solution (problem space is adjacent or equal to solution space, where filtering the problem space produces the solution set)
				- organizing structures can produce solution structures bc a problem may be a solution if organized in a different position
			- fitting structures can produce solution structures bc problems may be slightly different from solutions
				- for a problem like 'structure-input mismatch', a fitting structure like an 'remove/add distortion' function is a potential solution structure
			- apply multiple integrated solution attributes including concepts & structures like commonness, adjacence, simplicity, efficiency, alignment, usefulness to filter solution structures bc these are likeliest attributes to apply to solutions
		- function structures
				- standardizing structures can produce solution structures bc a problem may be a solution once standardized
				- intent structures can produce solution structures bc a problem may be a solution if used in a different way (for a different intent)
	
	- standard change-pattern interface insight path: 
		- identify patterns of distortions of existing solution components to select & apply distortions to existing solution components to handle problem with new components (like a problem with a new variable, complexity level, abstraction level, error type relationship, etc)
	
	- generate structures (like containers, shapes, sequences, networks, stacks, layers) of useful interface components like efficiencies, power/change sources, & organization structures, and see if they fit/interact with the problem & solution in a useful way, like achieving a problem-solving intent/sub-intent or related intents like problem-solution connecting intent
	
	- generate solution template structure based on solution requirements and apply to problem system to apply solving function like fill/reduce/generate (based on problem definition & solution requirements) the solution structure with problem system components
	
	- generate multiple solutions or solution template structures (like a function-generating function, or function-filtering limits) maximizing different alternative solution variable value sets & apply filters to reduce the set of solutions or solution templates
	
	- generate solution template structure based on solution requirements, identify variables of solution space, and map solution space variables to variables of solution structure
		- example: 
			- solution template structure based on solution requirements, like a set of boundaries/limits or filters ('a continuous function of x with integer coefficients & powers less than 3')
				- solution template structure variables:
					- coefficient number type, continuity, input/output variables, power value limit, input/output variable dependency direction
			- solution space, as in the 'functions of x producing reliable predictions of variable y that are possible in the problem system' - which when reduced will be the set of solution template structure variable values associated with such functions
				- solution space variables: 
					- alignment of predicted & actual output y, input/output variables, input/output variable dependency direction, difference types possible in problem space
			- connecting structures of solution requirement structure & solution space
				- solution structure to solution space
					- apply structure to solution structure variables to reduce the solution space possibilities
						- combine/change values of solution structure variables to most probable/different/filtering value combinations
				- solution space to solution structure
					- apply the solution space variables to filter the possible variable values of the solution structure
						- filter out functions having a specific coefficient pair for example
							- 'what types of difference are possible in the problem space'
						- difference types (variables) between input/output pairs
							- 'what variables & values applied to difference type A is present between (x1, y1)'
				- identify what structures of solution space variables can map to the solution requirement template structure variables
					- structures of solution space variables
						- components that can be combined or can interact in the problem space, between x & y
					- solution requirement template structure variables
						- solution metric requirement components
	
	- generate and/or apply solution structures (like structures of uncertainty reduction or organization) that generate the least entropy in the problem system & select between these structures as an initial reduced solution space
	
	- apply structures of system optimization & check if structures solve problem
		- example:
			- apply structure 'distribute generative capacity for resilience' to system that can fail at any point
	
	- align structures of organization (balance, connection, alignment) with certainties (constants) of a system and structures of disorganization (randomness) with uncertainties of a system to distribute flexibility where its needed
		- example:
			- apply a network structure (rather than a single value) to an uncertain variable like 'correct market regulation structure' until its clear (certain) which position each possible value has in what system contexts
	
	- identify error structures of existing solutions and apply as solution filters of solution space
		- example:
			- why do people want democracy? bc their needs arent met - 'needs met' is a solution filter of a solution space of all possible govt structures
	
	- change general problem-solving workflow variables to generate solution automation workflows
		- variables: solution process origin/target, solution process step, problem-solution connection, solution method, solution method for problem metadata, define components, apply general problem-solving workflow, problem origin, solution target
		- aim at different target (generate problem-solving structure from solution example, generate approximate/partial solution, identify error structures & problem-maximizing structures & apply as filters, etc)
		- start from different format (vectors, variable/object network)
		- start from different origin position
			- start from solution
				- solution components (available resources), solution interface, solution format, solution functions, sub-solutions (solving sub-problem) or partial solutions, solution space, solution filters, solution example/counterexample, solution type, or existing solutions
		- start at a particular step in general process (beginning at solution space)
			- apply solution filters to a solution space (where the problem-solving intent is to 'identify/define solution space & find a solution in this solution space')
		- connect problem & solution structures with changes (apply changes to match structure with target structure)
			- apply minor/granular changes that add structures of useful attributes
		- define problem/solution components (specify solution space)
			- identify attribute-fulfilling (adjacent/probable/reusable) solutions to make an attribute-specific (adjacent/probable/reusable) solution space & filter those solutions
		- solve different problem (reduce problem causes or more important/causative related vertex problem rather than original problem)
			- identify problem causes & apply structures to resolve those, then integrate those structures into a structure that is can be applied to solve the problem (doesnt contradict any rules)
		- apply known problem-solving methods for problem with known metadata (apply known solution methods for a problem type)
			- apply 'reduction' methods to problem type 'structure'
		- apply general problem-solution workflow/interaction methods (problem-solution connection methods)

	- apply opposite structures (like similarities) of error structures (like misalignments) to problem system to find solution
		- example: misalignment between actual/expected values can be resolved by methods to similarize, standardize, or otherwise connect the values
	
	- organize problem
		- sort problems (or problem components) in to a sequence that would solve the problems
			- general solution automation workflow: sort problems (or problem components) in to a sequence that would solve the problems (like input-output connection sequence of each problem), where the sequence is the solution, so the problems (or problem components) in the sequence are resolved once in the correct sequence
				- core function version: find sequence structure in which problems (or problem components) are equal to a solution


## example of implementing an insight path

	- example implementation of 'trial & error' insight path
		- insight path definition: 'try every combination of components to see what combination fulfills a solution metric value'
		- to apply this insight path programmatically (without human intervention), the program would:
			- pull definition of terms used in insight path definition (combination, square) & problem/solution components
			- problem definition: 'find combination of blocks to build a square'
			- problem space definition for the 'find combination of blocks to build a square' problem includes:
				- components like 'blocks of various sizes'
				- variables like:
					- block size, block count, block position, block combination structures (corners, layers, sequences)
			- 'combination' structural definition route: 
				- set of variable values without repetition (using existing resources like value ranges for each variable, or blocks in an available block set)
					- example combinations of variable values for problem space variables:
						- blocks of size 1 for block type x, blocks of count 2 for block type y, blocks in relative position 'top of previous block', blocks in combination structure 'layer stack'
			- apply structural definition routes of terms to problem space structures
				- structural definition of 'combination' in the problem space including differently sized blocks:
					- combination of blocks that can form a square (excluding block combinations that form structures with non-square attribute, like more than four sides), where combinations can be of blocks of varying size in varying position, and combinations can't include various combination structures that can't build squares
				- structural definition of 'every combination' in problem space, using problem space components
					- each possible (block identity in available block set) of every (type/size/shape) in every possible (position) in every possible (count) combined in every possible (combination structure)


## example of problem-causing structures of turing machine (with 'lack of input validation' problem)

	- lack of potential alignment in interpretating vs. applying a component
		- assumption: interpretation & application should be allowed to be different
		- potential for difference allowed in interpretation vs. application
		- potential for difference allowed in character string interpreted as input and character string used as input
	- difference in component attributes that shouldnt exist (should be equal)
		- assumption: 'length of input' equals 'length of string before a function in the form of a function character'
		- if these attributes are equal, the input fulfills the input definition
	- similarity in definitions
		- assumption: the definitions of input/function are not violated
		- if input has functionality or if functions are used as input, the definitions may be violated
	- lack of enforced relevance/meaning
		- assumption: position of function (rather than the meaning of the function, like position in relation to other components) is a reliable indicator of function signals, when only requirements can be used as a reliable indicator & position of functional characters after input string is not required
		- the meaning of the function positioned in the input is different from the meaning of the function after the input
			- the meaning includes different possible intents
	- lack of applied definition
		- assumption: that a structure like position can be used in place of a definition
		- that a variable with a value filter 'input = continuous initial string of characters that dont fulfill the "function" definition, if equal to length of input' shouldnt replace the constant structure 'position of input-terminating character' used to define or differentiate components
	- lack of exclusivity in component alignment (between 'character string' structure and 'input' structure, where 'character string' structure also aligns with 'function' structure, and where 'character string' contains 'position' structures which are used to differentiate input & function structures without interaction rules enforced for position/input/function contents stored in the 'character string' structure system)
		- assumption: that 'character string' is a structure that can be used to contain different components & that 'character position' is a structure that can differentiate them in isolation of other structures, and that those component positions & contents wont overlap, be switched, or otherwise be distorted or conflated
		- that input doesnt contain functional characters
		- lack of typical input validation in the form of variable value limits
	- lack of differentiation between components that should be different by definition
		- assumption: that position can differentiate components
		- that one problem space component (input) cant be adjacently converted into another (function) bc of definition violation
	- lack of enforced structural requirement (sequence of producing functionality by applying functions, rather than by reading input)
		- assumption: that a function not designed to produce functionality in all cases (like reading input) cant be used to produce functionality in all cases
		- that input strings should be convertible into functions without first being processed by a function
	- overlap in functionality that shouldnt exist
		- assumption: that one function cant be used to provide functionality associated with another function
		- conflation of functionality between 'read' function and 'execute' function
	- core problem structures, resolved with solution structures (system optimization rules)
		- excess/unnecessary components 
		- lack of alignment between required & implemented functionality (excess functionality)
		- lack of uniqueness/exclusivity of definitions (definitions shouldnt overlap)
		- system optimization: 
			- ensure that definitions dont overlap or allow ambiguities that are not useful
			- allow only intents that are useful, which dont allow non-useful intents
		- conflict between interpretation vs. application bc of difference that shouldnt exist
		- system optimization: 
			- ensure similarity of interpretation & application of definitions
		- lack of meaning in the form of contextual/system position
		- meaningful position of 'input with function character' differs from position of 'input without function character' in a system
		- system optimization: 
			- the meaningful position of components should be analyzed at other interaction levels, like at a 
			- system level (using system-level integrated metrics) rather than just locally (with local or granular metrics like 'position of function character')
			- function level (using function metrics like 'functionality potential of function convolution/product/sequence')
		- requirement as an indicator of info reliability
		- position isnt required to reliably indicate a component like input/function, but the definition of those components is required to reliably indicate a component
		- system optimization: 
			- apply definitions in identification functions
		- lack of exclusivity in structural intents
		- multi-purpose structure like 'character string' used for multiple purposes (input, function) without differentiating/separating structure (separating input from function)
		- system optimization: 
			- apply multi-purpose structures with differentiating structures to align usage with intent
			- apply multi-purpose containing structures (like 'variable' or 'template') with differentiating sub-structures to organize other sub-structures stored (like 'constant string')
		- lack of alignment between structural limits/potential
		- structural limit of 'character string' doesnt align with the structural potential of its contents (input, function, position, character)
		- system optimization: 
			- align structural limits with potential


## example of applying a problem to solve a similar problem

	- 'logistical resource allocation' problem
		- 'select a delivery method' problem
		- deliver to local warehouses rather than centralized warehouses & customers pick up (warehouses, stores, or locker boxes)
			- becomes a 'pick-up schedule allocation & reminder timing' problem
			- search version: decentralized data stores, CDN's, cached data, indexes based on common request metadata shared locally
		- deliver to local drop-off points rather than local warehouses (dropboxes in neighborhoods, like a designated safe house)
			- becomes a 'trust neighbor' problem
			- search version: decentralized servers hosting services
		- crowdsource using existing routes used for other errands
			- indirectly paid favors from social network
			- becomes a 'favor repayment finding & distribution' problem
			- search version: using patterns & other crowd-sourced knowledge to direct search or as a data source
			- directly paid favors from app network
			- this then becomes a 'ride-allocation & route-finding' problem
			- search version: paying for expert search routing
		- deliver with drivers & cars (standard method, other than using government delivery service)
			- becomes a 'fund car investment, monitor & insure drivers' problem
			- search version: fund investment in discovery/testing infrastructure, to test for & find info directly with experimentation
		- deliver with drones
			- becomes a 'test tech to avoid causing damage or being damaged and navigate regulations' problem
			- search version: build discovery/testing tools that can be purchased by users or run by groups/organizations
		- deliver to vault inside or near home
			- becomes a 'vault access & integration' problem
			- search version: distribute data based on permissioned access and intent
		- sell resource-generation tools (3d printing, gardening, other machines to produce products)
			- becomes a 'import product to resource-generation tool format' or 'create resource-generating tool for this product' problem
			- search version: tool to automate connecting question/answers with available methods like testing tools, applying patterns, or AI
		- sell info on how to build products (either original products or resource-generation tools)
			- becomes a 'index info & write clear documentation' problem
			- search version: info response to query is instructions on how to find info from data sources with other queries or processes
		- change delivery strategies based on how local conditions interact with global conditions
			- becomes a 'integrate local & global context like state/rules/processes' problem
			- search version: integrate search methods based on available resources, imminent/adjacent resources, reasons not to use resources, meaning of resource metadata like position, etc
		- 'select a route-finding method' problem
		- allocate delivery method components (origin, destination, method, required method resources), resources to be delivered, & assign costs
	- 'finding search path' problem
		- identify metadata of info being searched for (type, content, perspective, structure, purpose/intent)
		- identify info variables to generate info structures (completeness, language/phrasing, containing structure formats like lists, adjacent info structures found with the info)
		- identify info structures (partial info, info pattern, info beginning, info keywords) to search for
		- generate search strategies
		- search for info structures (content)
			- search for adjacent info like links to constitution when searching for text of declaration of independence
			- search for info structures like law reference format 1.2.3 or law keywords or law-specific terms
		- search for opposite of not-info structures (filters)
			- exclude logical fallacy structures when searching for facts
			- exclude anomalies in language patterns when searching for facts
		- use patterns of previous searches with similar inputs
			- use patterns of previous searches for similar topic or similar keywords or similar intents
		- search for relevant info containing structures (template containing content, html structures, logical trajectory like a 'intro-explanation-summary' sequence structure)
		- search indexes of info, organized by most efficient 'input keyword' to 'output content link' relationship
		- identify need for new efficient keyword-content link relationship, predict most efficient relationship, create new index for it, & search the index while creating it to optimize for future queries
		- predict likely sources of info & select interim points in likely sources to start search in (search at intervals of size n within likely sources of info)
		- select between search strategies
		- randomly select search strategy
		- diversify across search strategies until gains clarify optimal strategies to invest further searching in
		- dont search, just index info to optimize for this query
			- index info in a way that identifies possible uses/intents that apply to the query, and identify intent of search & conduct the search by the intent index going forward
			- example: 
			- if 'cost of product x' is a common query, index products by cost attribute by default
			- 'why does x happen' indicates a need for a 'cause' index ('cause' is the object being sought)
	- structural similarity of logistical resource allocation & search path-finding problem
		- allocating efficiencies & investments in various processes (like building, indexing info, moving resources, checking values, allocating resources to operate on resources)
		- preparing resources & resource distribution based on foreseeable requirements
		- allocating constants/variables where variation is predicted or occurs on demand
		- integrating attributes, functions, & objects at optimal interaction level (truck, package bundles by neighborhood, traffic - query pattern/type, info connections/abstraction)
	- 'adding variable to automated process' problem
		- identify timeline of solution lifecycle (when it will & wont be needed)
		- identify impact on related processes, based on interactions or common variables/inputs/outputs/dependencies
		- identify if a solution can be re-used for another process
		- identify existing functionality that can handle the task (configuration options that can do it like a database field type or built-in validation)
		- identify abstraction layer to inject variable at (whether to parameterize function, split function, copy function & modify logic to handle new variable)
		- identify if components (variable, function using variable, etc) are necessary or if connecting other components would resolve the problem
		- identify position of logic to inject variable at
		- identify format structure benefit/cost (keep in database for query advantages, store in csv's for data version tracking, store in dataframe for filtering query-like capacity)
		- identify problems to solve for each solution (add a variable, change function conditions to use parameter, etc)
		- identify optimizations like storing info & logic in as few positions as possible, ideally in one place
		- identify tests
			- structures of components:
			- variables
				- function parameters
				- assumptions
				- dependencies
				- context
			- variable values (ranges, types, sequence, uniqueness)
			- variable structures (components that use variables, like indexes made from a column, code modifying/using a column, or functions calling a function or using the same input elsewhere)
			- variable structure variables (how many conditions allowed in a condition statement, or levels of nesting allowed in a dictionary)

## example of applying structures from relevant system (like comedy) to a problem space (like 'correcting behavior' or 'fixing social norm violation')

      - if its a joke that means its by definitio at least partly untrue so is less likely to be a structure of truth & more likely to a structure of a combination of truth/falsehoods
      - surprising
        - different
        - opposite
        - extreme/exaggerated
        - nonsense (not incentivized/normal)
        - unusual/weird/unlikely
      - safe
        - reduce common experience/problem/fear or other negative emotion until ridiculous/unimportant/powerless
      - relevant
        - multiple alignments of relevant structures
          - self-fulling prophecy
            - multiple layers of relevance
              - prediction function
                - repeated concepts used in different ways
                  - add 'usage' concept while applying 'usage' function: use prediction function to predict usage
                - relevance cycle: 
                  - prediction function used to determine discussions, which are used to determine usage, which are an input to prediction function to predict usage
                - function usage makes it better at its usage intent
                  - 'prediction function of usage being used as an input to discussions which are an input to usage, so the function/paper is used more often, and becomes more accurate at predicting usage bc its usage predictions made it used more'
                - relevance in the form of usefulness/efficiency structures:
                  - function output (usage predictions) created a function input (usage)
                - the opposite would be ridiculous self-defeating structures:
                  - function output (high access & site crash from server overload) prevented a function input (using the paper)
        - aligning
          - actual intent & stated intent align (sincerity)
          - relevance structures align (at same intervals/points)
        - useful
          - connected
          - common/relatable
          - timely
          - efficient
          - similar
          - true (obvious, sincere)
      - important
        - emotional
        - petty
        - serious
      - easily understood
        - brief
        - uses references that are commonly known
      - ridiculous
        - invalid/illegitimate
        - self-defeating
        - pointless/not useful
        - irrelevant
        - ineffective
        - drastically/obviously false
          - conspiracy theories connect objects that are obviously not connected

      - insight paths
        - unlikely hypothetical
          - several degrees of assumption chains to generate an unlikely hypothetical (sequence of assumptions from a starting assumption/premise, generating a background story/context)
            - serious + petty + important: 'none of us can figure out why he tucks in his tie'
              - implies that the problem was so serious that a discussion happened to investigate & research it to fix it
              - implies that no one is allowed to ask him or has the courage to ask him directly, implying he's powerful in some way & cannot be questioned, which implies these are his subordinates who are not doing work in order to discuss this, which implies this could cause their work arrangement to be invalid 
            - 'none of us ever figured out why he tucked in his tie'
              - repeated + important: implies that the discussion was repeated bc it was such an important matter
            - 'none of our lawyers or R&D staff ever figured out why he tucked in his tie'
              - important: adds another level of importance in that they hired an expensive legal team to investigate the matter for liability/indemnity/litigation potential as if it made the company look so bad they had to hire a legal team
            - "the tie-tucking survived ex-girlfriends' interventions"
              - important: it has ruined multiple relationships with people who cared about him who tried to stop him from doing this to himself
              - briefer than previous version & uses more evocative verb
              - different: 
                - add assumption: assumption that the audience is rooting for the tie-tucking to continue
                - add concept of 'agency': attributing personhood to the tie-tucking, which is fighting for its life against cruel monsters
            - 'even after being accused of being a double-tucker who tucks his tie but not his shirt, he persisted'
              - important + petty + similar: fashion is a petty thing to care about this much, and a special jargon term 'double-tucker' implies a whole community or sub-culture based on or caring about this issue or related issues, which he has caused controversy in, with added importance by association from term 'double-agent', typically reserved for high-stakes situations like foreign wars, as if he's betraying someone or his heritage or group or people who rooted for him, and rhymes with a curse word
            - 'the mysterious tie-tucker left the board of directors' 
              - important + reduced: condensing the entire story into a brief structure like a nickname and casually referencing it despite the importance implied in a problem that generates a nickname
        - topics
          - conspiracy theory (a muffling device to prevent the Chinese from listening to his balls chafe for blackmail material)
          - cults/ex's (definitely worshiping the wrong things)
        - total opposite: 'your fatal flaw wasn't so much all the excessive drunk online shopping purchases at the police store & the corporate sabotage so much as the curtains from korea that spied on us & posted our arguments to porn sites' (it was absolutely the excessive spending at the police store)
        - changing definitions to very different alternate definition
          - 'tucked in his tie' or 'used unnecessary protection' or 'packed heat'
        - resolving awkwardness
          - 'i dont hate your dick pics (introduces the problem, 'uh oh does she hate my dick pics'), I just think theyre (foreshadowing something that seems like a difference but is actually similar) more optimal when directed at enthusiasts (or professionals), such as doctors/researchers, who might appreciate it more than I ever could (optional: from a curiousity perspective)'
        - mixed contexts/styles
          - talking about an unimportant matter in the same terms used for important matters
            - 'his parents couldnt deal with the idea of confrontation so they gently let him lose touch rather than disowning him outright' 
        - adding relevant structures of meaning like:
          - aligning layers like double entendres
            - calling him a 'magician' bc they have a function of 'hiding scarves' which is similar to 'tucking a tie' bc 'tucking' has a related output of 'hiding'
        - defeating the purpose/self-defeating
          - listing all the manipulations youre using, while using them, to the target 
        - false dignity/over-generousity
          - calling him a 'international man of mystery' bc its a very dignified way to portray having mysterious fashion habits that defy analysis from subject matter experts
          - 'he must be doing it to scare away women bc theyre always chasing him'
        - injecting stupidity/extremes
          - he thought it would act like a talisman to protect him from rape or unwanted pregnancy
          - he was told by a foreign holy man (has association with 'wise foreigner' stereotype) that it would protect him from fertility like a 'cosmic condom' (repetition, catchy) 
        - removing a point/agency (its not an intent, he just had the clingiest underwear/reproductive organs known to mankind)
        - fitting with existing systems without obvious contradictions
          - 'using existing phrases in a new way with minimal distortions' is surprising bc its unlikely to find a new distortion of an existing component that someone hasnt tried, so the simpler the better for this type

      - these structures can be used to filter for other non-comedy problems
        - surprise as a learning/prediction tool
          - structures of surprise & truth are useful insight paths to generate solutions
          - structures of surprise & falsehood are useful solution filters
            - conspiracy theories are so unlikely bc they go against incentives or apply an inefficient connection path
              - why would someone go to all that trouble to do that when its way easier to use this other method
        - structures of disincentives (that go against incentives) can be used to find info hiding spots
        - agent behaviors that are extreme in most ways (extremely dignified, pointless, ineffective) are less likely (uncommon) so theyre a source of surprise/comedy
        - structures of safety/stability can be used as a filter to identify possible/probable interactions

## example of deriving formula by applying definitions of components 

    - problem metadata
      - problem statement (formula to derive):
        - expected value of the random variable f(x) = actual average of distribution
      - definitions of components:
        - average definition: 
          - sum of all values divided by number of values
        - expected value definition: 
          - average of all possible values, weighted by probability of each possible value
          - expectation is linear
        - p(x) probability density 'distribution sample' definition
          - independent & identically distributed values
      - solution statement:
        - independently & identically distributed samples (data points) from a distribution inside the boundary of the area to estimate, divided by the total number of data points in the distribution is a way to fulfill intent 'approximate area inside boundary'

    - definition connections
      - identify 'probability' as a useful concept to map to problem space:
        - because of structural similarity in probability structures & problem definition (proportion)
        - or as a useful method to find a representative subset to avoid trial & error (or combinationatorial) calculation of area
      - connect concepts of core components ('probability', 'average value', 'sample size', 'data points', 'area') using definitions
        - this should produce the concept of 'convergence' as sample size variable is changed & average value approaches actual area
      - definitions of concept interations
        - 'area' is a related concept to 'probability' when:
          - data points are mapped to possible outcomes
          - problem-solving intent is either:
            - general structure: estimate the proportion of a subset relative to a whole
              - specific structure: estimate the probability of a subset of possible outcomes relative to all possible outcomes

    - alternate routes to derive formula
        - apply conceptual structures
          - apply 'opposite' structure
            - probability of being in the area to estimate
            - probability of not being in the area to estimate
          - apply 'random' structure
            - reduce 'trial & error' solution structure in this problem space of 'testing all possible points' to a subset of all possible points
              - how to select a subset of points
                - extreme points
                - evenly distributed points
                - random selection of points would produce a representative sample of points in a bounded area with increasing accuracy given increasing number of points
                  - randomly distributed points are a way around trial & error of all possible points
        - generate counter-arguments (questions) as filters to reduce error types
          - question every decision, with decision defined as 'variable selections that impact future decisions (future variable selections)'
            - variables
              - method of selecting points
                - beginner question: 
                  - why not just generate integer or .1 points starting at origin until all possible outcomes have been covered by an even lattice of points
                - beginner answer:
                  - this introduces bias in the form of an anchored starting point & applies unnecessary meaning to the sequence of points added, which means estimates with low number of points would be biased towards the area around the origin graphable with that number of points
                  - this bias represents a structure of certainty, rather than a way of estimating probability, which by definition is uncertain
                - generate beginner question
                  - apply error type "lack of concept of 'probability'" (indicating an uncertainty like a random distribution, rather than a certainty like a constant in the form of an origin)
                - generate beginner answer
                  - generate differences in between structure posited by beginner and actual requirements
                    - meaning assigned to the origin/sequence is unnecessary and even the opposite of what is required (independent samples that are not connected to subsequence samples in the sequence)
                - advanced question:
                  - wouldnt this take a lot of data points to converge to the actual mean
        - apply concept of 'probability' to 2d graph problem space to solve the problem of 'estimating 2d scalar multiplication or summing of 2d scalar multiplication' 
          - probability definition route: 
            - observed x outcomes in proportion to all possible outcomes = probability of x outcome
          - applied concept of 'probability' to 2d graph problem space: 
            - subset of 2d structures (points) in proportion to total set of 2d structures (points) = bounded area

## example of calculating possible/adjacent/relevant functions with core functions applied to function structures like combinations (convolution of function structures)
    - ai functions
      - categorize
      - generate text
      - falsify realistic data
      - identify anomaly
    - core functions applied to ai function structures
      - ai function structures
        - ai function combination
          - categorize & generate text
          - structures generated by core function applied (a convolution of a function structure using core function operations)
            - categorize text generated by an algorithm
            - generate text of a category function input
            - generate missing interim category text
        - ai function sequence
          - falsify realistic data, categorize, generate text
            - falsify realistic image to fool a categorizer used to generate standardized text

## example of calculating possible questions/problems that are solvable using metric filters
    - convolution of metric structures to determine what can be measured
      - example metrics
        - specificity of solution
        - reusability of solution
        - accuracy of solution
      - example metric structures
        - apply metric filter combination as equal priorities
          - specificity of solution & reusability of solution
        - apply metric filter sequence
          - reusable solution, specific solution
      - example problem structures that can be solved with metric structures
        - a problem of 'find approximation' can be solved with metric structures like accuracy & specificity':
          - apply filters of specificity (to make sure the problem solved is the right problem to solve, like 'find an approximation for a prediction function' rather than finding an approximation for another object)
            - apply filters of accuracy (to make sure input/output values are within a range that can be fit to the definition of accuracy in the problem space)
          - in other words, because we can measure specificity & accuracy, we can solve problems like 'find an approximation function'

## example of calculating possible error types & finding relevant solution structures
    - error type:
      - a 'structural alignment' error type can result from an unexpected emergent error
        - core example: stacking layers in a filter opening can eventually fill the opening, preventing the filter from working (like arteries lined with fat)
        - apply structure of error type to AI problem space
          - multiple stacked or sequential pre-processing alignments of data that:
            - standardize data too much and make the data so homogeneous (self-similar) & similar to the filter node's threshold value that everything passes or fails, or pass/fail is equally likely bc it injects randomness through equality
            - aggregate fail values into a pass value or vice versa
    - find & apply a solution:
      - apply solution structure (like a 'structure filter') that has relevant structures to the error type, such as the insight:
        - 'prevent functionality/structures/attributes that has no valid/relevant/useful intent' (like 'aggregation' or 'alignment' intents)
        - this solution structure is relevant because the error type 'structure has no valid intent', so a 'prevention' function should be applied to it

## example of applying solution metric filters such as 'requirements' to find/derive/generate a target solution structure like a 'proof'
      
      - interface query implementing a solution automation workflow having the 'connect' core interaction function 
        - connect a function 'specific example' or 'rule' input with 'general or absolute proof' output on the math interface by applying the logic interface
      
      - apply 'proof' structure requirements:
        - describes all possible variation in the output in terms of components capable of producing that variation
        - complete set of test cases or representative example test that can scale absolutely
        - connects components using only logic rules & definitions
          - example: if we have connections 'a is a subset of b', and 'b is a subset of c', then we can derive new connections by applying the definitions of 'subset', 'equal', and 'container' to the components
            - 'a is a subset of c'
            - 'c is a container of b & a'
            - 'b is a container of a'
            - 'b is not equal to a is not equal to c'
          - definitions:
            - container: if a is a subset of b, b contains a
            - subset: if a contains only elements that also appear in b, but b has more elements that dont appear in a, a is a subset of b
            - equal: if a and b have the same elements and no different elements, a is equal to b
          - we've applied the logic of the 'subset-container' connection in the definitions to the subsets a & b, to identify their connected container components (b & c, and c)
          - proofs also have this restriction, in that they can apply definitions/rules to identify connections between components, if the rules specify certain (having certainty attributes like absolute, constant, required, or definitive) connections like equivalence
          - proofs are a combination of rules with certain connections
          - 'proof templates' (structures) can be constructed using connectible/interactive rule sets (applying structures like combinations to core components of a proof like rule sets)
          - you can match input-outputs (like question-proof) using proof templates (connection sequences between question & proof), if there's a proof template that matches the input question & output proof, but you may not know the proof in advance (like if doing combinatorial analysis on functions to see if anything can be proven about the functions)
            - example question: prove that 'a is a subset of c', given rules 'a is a subset of b' and 'b is a subset of c'
            - example proof: 
              - prove: 
                - 'a is a subset of c' = 'a has only elements that appear in c, but c has more'
              - apply definition of 'subset'
                - 'a is a subset of b' = 'a has only elements that appear in b, but b has more'
                - 'b is a subset of c' = 'b has only elements that appear in c, but c has more'
                - 'a is a subset of c' = 'a has only elements that appear in c, but c has more' (arrived at proof using 'subset' definition)
            - proof template:
              - specific template:
                - to prove that an attribute is transitive for a standard case (three input components),
                  given example connection rules regarding the component with the attribute (subset) & the component giving it that attribute (set), 
                  and given a definition that makes testing for definition fit as simple as a set of basic calculations ('does a only have elements that appear in b', and 'does b have more elements')
                  where the connection rules connect two different component pairs in the set of three input components,
                  and the proof requirement is to prove that the remaining pair is also connected in the same way,
                  apply the definition of the connection rule to the remaining pair to test for definition fit
              - general template:
                - to prove that an attribute applies to all subsets in a set, 
                  find a standard case that is extensible to other formats/inputs,
                  and apply the definition of the attribute connection rule to all subsets in the set for the standard case
              - if you have inputs like a set of components, and rules connecting a subset of components, and a proof requirement of determining if the same rule can connect the remaining component subsets, these proof templates are applicable
