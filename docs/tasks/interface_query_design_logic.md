  - use isolatability/inevitability/uniqueness as a structural foundation for interface conversion/generation logic

    - identify 'inevitable' definition routes that are unique which can be used as a default generation intent for the core data included for app functionality
      - example: a definition route that cant be used as a definition of both balance & power, just one
      - unique intents are also a useful foundation structure for the intent interface

    - apply structures to overlaps in definition routes
      - find the adjacent structure without contradictions, that doesnt resolve to either specific option, within the limits of both definition routes
        - lack/limit :: resource 
        - function :: resource 
          - resource-generating function :: resource
            - resource :: function

  - organize examples of logic for functions (interface query design logic)

    - document locked objects that are inputs to core objects (like functions & concepts)
      - core functions like 'change', with locked objects which should be generated as inputs to other functions and should not be removed bc they enable other rules & core objects
        - a 'check for errors' function
        - a concept of 'self-correction/optimization'
      - these locked objects can be used to generate rule-generating/deriving/finding structures, by forming an initial structure of locked objects and filling that structure with conditional & changeable structures
        - these rule-generating/deriving/finding structures can be used as solution automation workflows

    - examine function topologies (structures & structure change metadata that can maintain a particular function)
      - document intent structures (like intent sets) associated with function topologies
      - even if a structure maintains a particular function, its other metadata like adjacent interaction/change types & intents may change with the structure change
      - intent topologies dont necessarily match metadata of function topologies
      - interaction of interface object topologies as a source of variance reduction

    - design an optimal sorting structure for general interface queries to apply to problems manually
    - example of how to predict most interactive/causal concepts in a system
    - list interface selection (based on inputs like available APIs/data sets/definitions)
    - problem interface structures: solution constraints/metrics, problem space variables, available functions, useful formats/structures
    - function to translate interface query logic into interface language (combination of core functions (find/build) & other core components)
    - function-usage-intent::output or demand::supply combination/merging/building/matching functions (alternatively formatted as a solution-finding query for a problem or lack-resource matching function) as an alternative solution to ads
    - finish list of interface implementation problem type structures (suboptimal interface queries, incomplete definition routes, sub-optimal or mismatched formats) 

    - decision points (required/optional resolution of variables to constants, as in selecting a variable value)
      - identify when a method & data set can be determined to be capable of deriving the answer to a prediction function problem

    - different interfaces to solve problem on:
      - interfaces to format problem on:
        - structure: what are the problem structures
        - cause: what are the problem causes
        - info: what info is missing to solve the problem
        - potential: what alternative options are available to solve the problem
        - functions: what functions can construct (and by implication, deconstruct) the problem
        - logic: what structures like connections fit (make sense), given how logic can be used to filter info structures (like by checking for multi-interface alignment such as aligning facts with logical connections)
        - intent: what intents (of which functions, like 'find info') can the problem be represented as
        - change: what changes to the problem can convert it into a non-problem or solution, what variables of the problem are relevant on some interface
        - interface: what structures of randomness or organization can be applied to the problem interface objects to make them relevant/useful for the problem-solving intent
        - core: what core functions can be used to standardize the problem components
      - questions:
        - how can structures of these interfaces be changed/organized to reduce/remove the problem or convert it into a solution

      - all of these primary interfaces are relevant for interface query design:
        - potential: is the problem possible to solve with adjacent resources, what alternative queries can be run in parallel to reduce solution space the quickest
        - structure: what is the adjacent format for this problem
        - info: what info should be found/derived/generated in what structure (like sequence)
        - cause: what causes can be used to justify interface query design intents & decisions
        - change: what changes should the interface query support, and at what structures (like points in the logical sequence or tree)
        - logic: what logical fallacies are possibly present or possible for this interface query? does it comply with logical rules like connecting info across interfaces (facts, assumptions, implications)
        - interface: how are these questions organized in a way to design the interface query optimally? (apply 'potential' filter first to make sure it's possible to solve)
        - intent: what are the input/output intents of the interface query (input intent to solve a particular problem, output intents like emergent side effects of the interface query, like program optimization)

    - alternative intent coordination & compatability of metrics
      - calculating interactivity by coordinating/adjacent/convertible structures
    - use exclusively solution with known biases & error types so output can be corrected with logic from the associated solution type
      - algorithms that dont have a mechanism to offset/correct biases from data can be used with a correcting function to improve output likelier to be an error type
      - this is an interim solution (algorithm/model + correcting logic of error types) while other algorithms are tested
      - every algorithm has limitations - those with known limitations can be an asset in some problem types (like to discover biases in data), while other algorithms with unknown limitations can be an asset in other problem types (like to add uncertainty or delegate responsibility for unfair decisions)

  - add structural queries to insight paths
    - alignments present in security innovations (like alignment in inputs like keys)
    - source of rule development as structures of conflict between forced interactions like change causes & constant structures like limits
      - incomplete inevitability of interaction as a decision structure
    - other examples  
      - group device history authentication: authenticate credit card by proximity to cell phone & continuity applied to user usage history pattern
    - functionalize insight paths & integrate functions in optimized program with parameters to select function subset & structure for input problem

  - add insight-fitting interface query for error type avoidance
    - when a new discovery is made, apply insight paths formatted as questions to spot error types before they occur
      - could this violate any assumptions/requirements/dependencies we rely on for other tasks like calculations or applying systems of understanding
      - could this cause cascading (self-sustaining) errors
      - could this cause emergent errors, given other knowledge like probably interactive trends or rules
      - what are triggers of this? what can it trigger with certain interactions, how likely are those interactions
