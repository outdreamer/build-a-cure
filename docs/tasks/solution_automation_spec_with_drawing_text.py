TITLE OF INVENTION 

Solution Automation 

 

FIELD 

[0001] Embodiments of the disclosure relate to automation of problem-solving for clearly defined problem statements using interface traversals. 

 

BACKGROUND OF THE INVENTION 

[0002] Problem-solving is usually done manually, without context about prior solutions, common solutions, or a way to graph the standardized problem & solution, or a systematic method to translate them into other standard formats that are more amenable to being matched using standard structural operations like map, filter, combine, etc. Any prior art relating to mathematical methods of solving problems or a protocol to generate solutions would be outputs of this invention, or stored in the database component of this invention as a prior identified solutions for a problem type, with associated intents, insights & other information relating to the solution. 

  

 

 

 

 

 

 

 

ABSTRACT 

[0003] This invention translates a problem definition into a structure that allows for resolution of the structure into the corresponding solution format with a set of queries (formatted as a query of the interface network - a set of standardizing filters applicable to format information in way that it can be analyzed with interface-specific logic, which may also be a problem-solving automation workflow, if problems can be solved with the format sequence indicated by the interface traversal). 

  

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

BRIEF SUMMARY OF THE INVENTION 

[0004] One or more embodiments of the present disclosure may include a method that involves obtaining a problem statement from a user, optionally including solution metrics (such as priorities, functionality, or attributes); identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; traversing interface network (optionally including such interfaces as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; finding components on the interface that match the problem structures (optionally including related objects like insights, patterns, & functions); compressing the problem statement into its most accurate structure containing the found interface objects; iterating the origin interface selection & interface traversal process for the solution space; identifying & reducing the solution space from this standardized problem format; traversing subsequent interfaces to obtain additional information; reducing the solution space by the problem & problem space definition; returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/patterns/system/standardized description related to the problem if no solutions are found. The attached specification appendix named methods.pdf optionally includes a list of alternative optional implementation methods which may be integrated into the invention or used to develop other methods. The object and advantages of the embodiments will be realized and achieved at least by the elements, features, and combinations particularly pointed out in the claims. It is to be understood that both the foregoing general description and the following detailed description are merely examples and explanatory and are not restrictive.   

 

CLAIMS 

1. A method comprising: obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes); identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; traversing interface network (including interfaces such as information, insight, structure, math, concept, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/ answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions); compressing the problem statement into its most accurate structure containing the found interface objects; iterating the origin interface selection & interface traversal process for the solution space; identifying & reducing the solution space from this standardized problem format; traversing subsequent interfaces to obtain additional information; reducing the solution space by the problem & problem space definition; returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/patterns/system/standardized description related to the problem if no solutions are found. 

2. The method of claim 1, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms, converting passive to active language, and removing words that don't change the meaning of the statement. 

3. The method of claim 2, wherein identifying the problem & problem space metadata includes: identifying the problem type given the most adjacent type (such as an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and the minimum information required to solve the problem (inputs like alternate attribute sets; solution requirements; constant assumptions & other dependencies), then mapping the inferred or stated assumptions describing the problem space to a multi-dimensional structure, usually bounded by assumption limit or filter conditions, & indicating possible interactions between the problem objects & the other system objects, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure). 

4. The method of claim 3, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, differentiation potential) of the given & directly inferable information, which interfaces should be traversed in what sequence, and whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface for example). 

5. The method of claim 4, wherein traversing the interface network includes: converting the problem definition to the interface using the conversion function which applies system- mapping, position-finding, & object-fitting logic, & looks for common attributes between problem objects & interface objects & their structures (like transformations, subsets, & paths) so that interface object relationships can be used to infer relationships about associated problem objects, where the traversal may start from various points on the interface, including core objects & functions, or directly mappable objects to the problem objects, or important or required interface objects. 

6. The method of claim 1, further comprising iteratively repeating the traversal method on other interfaces, given the achieved distance from the minimum information required to solve the problem, fulfilled solution requirements, & progress in compressing the problem, where information output by each traversal may include information, interface objects, functions, or attributes compressing the problem. 

7. The method of claim 1, wherein the solution metadata is identified & the interface network traversal process in claims 3 - 5 is repeated for reducing the problem space to a solution space & then deriving, finding, matching, applying, or building a specific solution or general solution method that compresses the problem into a form that is more adjacent to its final solved form (occupying a point rather than a multi-dimensional structure in the problem space definition), where the solution method may be executed on other interfaces and is then converted to a vector or other object impacting the formatted problem on an interim interface used for calculations, and is then converted to an object impacting the original problem in the problem space structure. 

8. The method of claim 1, wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution definitions & associated space definitions, including system analysis (fitting of system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, and conflicts to problem definition); information problem type composition (mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack); insight path application (using insight paths from other fields to optimize insight generation); problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions); concept-structure application (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts); a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship); a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape); structure-math mapping (a multi- interface traversal to map problem structures to math objects to apply math insights to problem structures); a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network); problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied). 

9. The method of claim 1, further comprising determining the success of a particular solution, given the solution requirements stated or inferred from the problem statement & iterating if solution requirements are not met, or if the problem is not fully compressed, or if the solution created other problems in the problem space. 

10. A non-transitory computer-readable medium containing instructions that, when executed by a processor, cause a device to perform operations, the operations comprising: obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes); identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; traversing interface network (including interfaces such as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions); compressing the problem statement into its most accurate structure containing the found interface objects; iterating the origin interface selection & interface traversal process for the solution space; identifying & reducing the solution space from this standardized problem format; traversing subsequent interfaces to obtain additional information; reducing the solution space by the problem & problem space definition; returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/ patterns/system/standardized description related to the problem if no solutions are found. 

11. The non-transitory computer-readable medium of claim 10, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms, converting passive to active language, and removing words that don't change the meaning of the statement. 

12. The non-transitory computer-readable medium of claim 11, wherein identifying the problem & problem space metadata includes: identifying the problem type given the most adjacent type (such as an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and the minimum information required to solve the problem (inputs like alternate attribute sets; solution requirements; constant assumptions & other dependencies), then mapping the inferred or stated assumptions describing the problem space to a multi-dimensional structure, usually bounded by assumption limit or filter conditions, & indicating possible interactions between the problem objects & the other system objects, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure). 

13. The non-transitory computer-readable medium of claim 12, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, differentiation potential) of the given & directly inferable information, which interfaces should be traversed in what sequence, and whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface for example). 

14. The non-transitory computer-readable medium of claim 13, wherein traversing the interface network includes: converting the problem definition to the interface using the conversion function which applies system-mapping, position-finding, & object-fitting logic, & looks for common attributes between problem objects & interface objects & their structures (like transformations, subsets, & paths) so that interface object relationships can be used to infer relationships about associated problem objects, where the traversal may start from various points on the interface, including core objects & functions, or directly mappable objects to the problem objects, or important or required interface objects. 

15. The non-transitory computer-readable medium of claim 10, wherein the instructions are further configured to iteratively repeat the traversal method on other interfaces, given the achieved distance from the minimum information required to solve the problem, fulfilled solution requirements, & progress in compressing the problem, where information output by each traversal may include information, interface objects, functions, or attributes compressing the problem. 

16. The non-transitory computer-readable medium of claim 10, wherein the solution metadata is identified & the interface network traversal process in claims 3 - 5 is repeated for reducing the problem space to a solution space & then deriving, finding, matching, applying, or building a specific solution or general solution method that compresses the problem into a form that is more adjacent to its final solved form (occupying a point rather than a multi-dimensional structure in the problem space definition), where the solution method may be executed on other interfaces and is then converted to a vector or other object impacting the formatted problem on an interim interface used for calculations, and is then converted to an object impacting the original problem in the problem space structure. 

17. The non-transitory computer-readable medium of claim 10, wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution definitions & associated space definitions, including system analysis (fitting of system objects like symmetries, sub-systems, sub- interfaces, false assumptions, correlations, and conflicts to problem definition); information problem type composition (mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack); insight path application (using insight paths from other fields to optimize insight generation); problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions); concept-structure application (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts); a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship); a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape); structure-math mapping (a multi-interface traversal to map problem structures to math objects to apply math insights to problem structures); a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network); problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied). 

18. The non-transitory computer-readable medium of claim 10, the operations further comprising determining the success of a particular solution, given the solution requirements stated or inferred from the problem statement & iterating if solution requirements are not met, or if the problem is not fully compressed, or if the solution created other problems in the problem space. 

19. A system comprising: one or more processors; and one or more non-transitory computer- readable media containing instructions that, when executed by the one or more processors, cause the system to perform operations, the operations comprising: obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes); identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; traversing interface network (including interfaces such as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions); compressing the problem statement into its most accurate structure containing the found interface objects; iterating the origin interface selection & interface traversal process for the solution space; identifying & reducing the solution space from this standardized problem format; traversing subsequent interfaces to obtain additional information; reducing the solution space by the problem & problem space definition; returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/patterns/system/ standardized description related to the problem if no solutions are found. 

20. The system of claim 19, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms, converting passive to active language, and removing words that don't change the meaning of the statement. 

21. The system of claim 19, wherein identifying the problem & problem space metadata includes: identifying the problem type given the most adjacent type (such as an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and the minimum information required to solve the problem (inputs like alternate attribute sets; solution requirements; constant assumptions & other dependencies), then mapping the inferred or stated assumptions describing the problem space to a multi-dimensional structure, usually bounded by assumption limit or filter conditions, & indicating possible interactions between the problem objects & the other system objects, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure). 

22. The system of claim 19, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, differentiation potential) of the given & directly inferable information, which interfaces should be traversed in what sequence, and whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface for example). 

23. The system of claim 19, wherein traversing the interface network includes: converting the problem definition to the interface using the conversion function which applies system- mapping, position-finding, & object-fitting logic, & looks for common attributes between problem objects & interface objects & their structures (like transformations, subsets, & paths) so that interface object relationships can be used to infer relationships about associated problem objects, where the traversal may start from various points on the interface, including core objects & functions, or directly mappable objects to the problem objects, or important or required interface objects. 

24. The system of claim 19, further comprising iteratively repeating the traversal method on other interfaces, given the achieved distance from the minimum information required to solve the problem, fulfilled solution requirements, & progress in compressing the problem, where information output by each traversal may include information, interface objects, functions, or attributes compressing the problem. 

25. The system of claim 19, wherein the solution metadata is identified & the interface network traversal process in claims 3 - 5 is repeated for reducing the problem space to a solution space & then deriving, finding, matching, applying, or building a specific solution or general solution method that compresses the problem into a form that is more adjacent to its final solved form (occupying a point rather than a multi-dimensional structure in the problem space definition), where the solution method may be executed on other interfaces and is then converted to a vector or other object impacting the formatted problem on an interim interface used for calculations, and is then converted to an object impacting the original problem in the problem space structure. 

26. The system of claim 19, wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution definitions & associated space definitions, including system analysis (fitting of system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, and conflicts to problem definition); information problem type composition (mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack); insight path application (using insight paths from other fields to optimize insight generation); problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions); concept-structure application (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts); a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship); a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape); structure-math mapping (a multi- interface traversal to map problem structures to math objects to apply math insights to problem structures); a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network); problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied). 

27. The system of claim 19, further comprising determining the success of a particular solution, given the solution requirements stated or inferred from the problem statement & iterating if solution requirements are not met, or if the problem is not fully compressed, or if the solution created other problems in the problem space. 

  

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

BRIEF DESCRIPTION OF THE DRAWINGS 

[0005] Example embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which: 

[0006] Figs. 1A - 1J contain diagrams of an overview of an example implementation 100 described herein. 

[0007] Fig. 1A User Interaction Module 110 is a diagram of an example user interface implementation to gather input about a problem & program configuration for Solution Automation Module 140. 

[0008] Fig. 1B Solution Automation Module 140 is a diagram of example components (such as functions & constants) of a program to automatically find/derive/generate a solution for a problem, to implement the general execution workflow of Fig. 4. 

[0009] Fig. 1C Machine learning system 120 is a diagram of an example wrapper component that would call a machine learning system to predict a variable. 

[0010] Fig. 1D API finding/calling system 130 is a diagram of an example wrapper component that would call an API finding/calling system to retrieve data. 

[0011] Fig. 1E Solution Output 150 is a diagram of an example output of the process in Fig. 4 that could be displayed & edited in the User Interaction Module 110. 

[0012] Figs. 1F - 1I contain diagrams of an example problem-solving automation workflow (such as problem space structurization (formatted as filters/limits/functions/networks/vectors)) detailing a particular interface traversal format sequence that can be used to solve most problems. 

[0013] Fig. 1F Finding matches between problem & interface components is a diagram of an example implementation of step 404 - 406 of the process of Fig. 4 (converting a problem to an interface, mapping between components of the problem & interface). 

[0014] Fig. 1G Applying matching interface components to relevant problem system components is a diagram of an example implementation of step 407 of the process of Fig. 4 (applying matching mapped objects from the interface to the problem system). 

[0015] Fig. 1H Applying solution metric structures to solution structures is a diagram of an example implementation of step 408 of the process of Fig. 4 (applying solution metric structures to solution structures). 

[0016] Fig. 1I Example Object Definition Structures is a diagram of example structures forming the definition routes of an example system object on the structural interface. An example of a definition route is documented here: https://github.com/outdreamer/build-a-cure/blob/52c3461fdd3ff38284b63f8c2e71542f415d88d9/find_existing_solutions/system_analysis/maps/definition_routes.json 

[0017] Fig. 1J is a diagram of an example usage of the system. 

[0018] Fig. 2 is a diagram of an example environment in which systems and/or methods, described herein, may be implemented, including solution automation module 220 in FIG. 2 which refers to solution automation module 140 in FIG. 1. 

[0019] Fig. 3 is a diagram of example components of one or more devices of FIG. 2. 

[0020] Fig. 4 General Execution Workflow is an overview of an example process 400 for implementing problem-solving automation workflows in steps 402 - 410, from initial problem formatting to solution matching to solution application & analysis. 

  

DETAILED DESCRIPTION OF THE INVENTION 

[0021] As used herein, terms used in claims may include the definitions: 

    - interface: a useful standard for comparison consisting of the filtering object's definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface. Abstract interfaces include cause, concept, structure, etc, whereas specific interfaces are other foundations where change develops in a clearly defined range that can be found in specific systems. The traversal of an interface implies finding a map between objects, functions, & attributes inherent to that interface to the problem objects, functions, & attributes. The application of an interface is an operation in an interface combination, mapping, injection, or other operation. 

    - function: a set of inputs, a sequential list of rules or rule lists (logic tree) applied to the input set, an output set created by changes to the input set executed by the sequential rule list, optionally including side effects from execution. A function may be formatted in a different way, such as a list of attributes, filters, or a network. The function definition includes: 

        - attributes: 

            - alignment: enforced/optional, core, required, emergent/output (built from core functions, with or without associated intent) 

            - interaction: cooperative/conflicting 

            - intent: generative, filtering, grouping, organization/delegation/ distribution/matching/grouping/filtering, classification, differentiation/ transformation 

            - scope: use case, context, range, host system 

            - related objects (like host spaces/systems & object positions in those) 

            - types: 

                - core functions 

                - meta (rule-modification/generation rules) 

                - attribute rules (state, scope) 

                - interaction rules (competition, binding, combination, sharing, collaboration, intersection, conflict resolution, trade rules) 

                - assessment rules (metric, difference, definition, validation) 

                - processing rules 

                - change rules (update, distortion, maintenance, adjacency, conversion) 

                - filtering rules (find, identify, define, alternate, organize, learn) - matching rules (fitting a structure, filling a structures) 

                - application rules (inject, embed, apply) 

                - derivation rules (structure, navigate, abstract) 

                - decision rules (prioritize, select, compare) 

                - formatting rules (standardize, isolate, cluster) 

                - destruction rules (replace, invalidate, neutralize, remove, merge, de- duplicate) 

                - government rules (monitor, correct, enforce, maintain, stabilize) 

                - system rules (incentives, variance handling, optimization) 

                - interface rules (change, intent, type, pattern, concept) 

                - info rules (problem, strategy, insight, game, perspective) 

                - variance (injection, leaks, combination, replacement, causal direction, uncertainty, risk, potential, probability, prediction) rules 

                - information handling (storage, versioning, replacement, merging, monitoring, indexing, communication, interpretation, processing) 

                - solution rules (variance/stressor/error detection, tracing, identification & handler) 

                - structure rules (gap, boundary, system, limit, hub, object, link, network, filter)     

    - intent: any of an abstract goal with direction, a reason to use something, or an output such as the intended result or an unintended side effect, which can be an abstract priority like fairness, a concrete goal, and can have a starting & ending position. 

    - game: a set of intents/alternatives/limits/incentives/exploits/rules/risk & a definition of distance from intent fulfillment (position), usually resulting in the resolution of a clearly optimal route. The game definition includes: 

        - a game is a type of system & a mixed set, which can exist as a component of a system 

        - games can have many different structures like: 

            - a directed graph with a vector set representing possible agent intents/ functions/resources 

            - a system of nodes & links where agents need function input resources to traverse 

            - a decision tree where certain tree info becomes accessible only at certain nodes (adding uncertainty/risk) 

            - a set of trade options between nodes with different info change/update rules in a system to optimize a resource/trade/market metric 

    - concept: set of unique objects remaining once objects from other spaces have their context & contradictory attributes removed. For example: power is the object left when objects implementing it: resources => energy => input => potential) have their context removed, navigating up the abstraction stack from: 

        - the info layer (resources & energy), removing their contextual attributes/rules - to the abstract structural layer (input) 

        - to the abstract layer (potential, which is a related concept of power) 

        - so that the final object is defined in terms of other abstract objects on the top layer 

    - problem: may include any context or condition that causes a negative position or state determined by a metric for an agent in a system. The problem definition includes problem types like dependencies, leaks (variance, resource/info),  injection (assumptions/variance/control/randomness), mismatches, conflicts, imbalances, inefficiencies, incorrect metric, misidentification, gaps, limits, side effects: whether it's a closed system or leaks variance (function side effect example: before execution: pre-computing, during: memory access/overflow, after: process re-starting), specific problems like an enforcement gap (should have enforced rule but did not), an unintended use (involves integrated third party tech not under review), a malicious alternative route to get same output, a legitimate/alternative route to get malicious output. 

    - problem space: context relevant to a problem; the containing system(s) of a problem that may include related problems 

    - solution: may include any combination of events, methods, or steps that reduces the negative position or state for the specified agent. The solution definition includes solution types: 

        - solution-metadata solution: evaluating & comparing solution metadata for solution selection 

        - problem-metadata solution: evaluating problem metadata to evaluate metrics like problem-solving postponement 

        - generative solution: solution that generates solutions 

        - solution framework: provides starting point & structures for solutions to be built in/with 

        - problem decomposer: solution that reduces a problem's root causative (as opposed to just varying) parameters 

        - solution automator: solution that automates solutions of a type 

        - interim solution: clearly suboptimal solution while optimal alternative is built 

        - solution query constructor: solution that builds new solutions out of known solution types (existing structural solutions or core functions) 

        - structure-finding solution: solution that assigns a structure to information 

        - structure-fitting solution: solution that matches the gaps/limits in a problem structure to neutralize them 

    - solution space: set of possible solutions in a problem space, which may be reduced by applying interface traversals like solution space-reducing insight paths 

    - network: standard network graph containing nodes (sometimes called vertices) & linking functions (sometimes called edges), with or without node attributes, function relationship determining function shape, and direction as an indicator of intent or another metric. 

[0022] Method described in claims includes: 

    1. obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes) 

    2. identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem) 

    3. identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject 

    4. traversing the interface network (including interfaces such as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions/objects/attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface 

    5. finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions) 

    6. compressing the problem statement into its most accurate structure containing the found interface objects 

    7. iterating the origin interface selection & interface traversal process for the solution space 

    8. identifying & reducing the solution space from this standardized problem format 

    9. traversing subsequent interfaces to obtain additional information 

    10. reducing the solution space by the problem & problem space definition 

    11. returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/patterns/system/ standardized description related to the problem if no solutions are found 

    12. if solutions are found, compare solutions with filters, risk contribution, & problem space visualization 

[0023] System described in claims wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution & space definitions, including: 

    - system interface traversal (fitting of system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, and conflicts to problem definition)  

    - information interface traversal (with logic such as mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack) 

    - insight path application (using insight paths from other fields to optimize insight generation) 

    - problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions) 

    - concept-structure traversal (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts) 

    - a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship) 

    - a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape) 

    - structure-math interface mapping (a multi-interface traversal to map problem structures to math objects to apply math insights to problem structures) 

    - a question-answer interface traversal (where a question defined as missing information is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network) 

    - problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied, and selecting between solutions) 

[0024] The present disclosure relates to the use of interfaces & custom logic automation for constructing a solution automation system. A combination of the core structures referenced or general mathematical objects, functions, or attributes may be used to graphically visualize: 

    - a problem space depicted as a set of boundaries indicating limits creating the problem space (like limited tech creates a problem space) 

    - the problem space dimensions maximizing variance between related problems - a network of related problems in the problem space & their state 

    - the origin problem occupying a position on the problem network, which can be represented differently according to the type & the solution generation method, for example: 

        - if the user's problem object is represented as a 3-d shape like a cube (indicating it has three main variables expanding each other from an origin corner & forced to create a closed system to maintain state, or 6 limits interacting with each other but not overlapping), the solution would need to be in a vector format to remove dimensions of the shape or reduce the size of the problem shape 

        - if the user is representing their problem on the information interface, they may want to represent it as an information problem type within a system context, like how: 

            - a conflict between system incentives & agent intents could be represented as two vectors with the same origin or two vectors going in different directions 

            - an information imbalance would look like extra information in different positions 

            - an information asymmetry would look like information in a position where it's not needed & can be exploited to charge rent 

            - an information market would have some trust structures embedded so information can be bought instead of derived for conveniences, similar to how concepts like delegation would look like a node sending calls to other nodes that run tasks & return response data  

    - problem types have structure once they're framed as an information problem, and once concepts are converted to more structural interfaces, they also have default structural forms reflecting their definitions 

    - the solution space for the origin problem (and for all related problems on the network that the solution space applies to), where the solution space is a reduced version of the problem shape or structure or the set of possible solutions 

    - solutions to the origin problem, represented as: 

        - a subset of the problem shape (like a path answering a question, where the solution space is all possible routes between origin & destination nodes) 

        - a structure within a system containing the problem (an optimal route with a required attribute like efficiency, or a combination of objects reducing variance in a rule gap, or a filter sequence that creates a function optimally while storing minimal code) 

        - a structure (other than reductions) to aim for when transforming the problem and the available resources implied in its definition (a solution defined as an optimal version of the problem structure, like the optimal structure to represent a concept) 

        - a compressing transform of the problem shape (solution vectors removing problem dimensions until it's a point) 

    - the impact of solutions on the problem network or the origin problem (depending on the problem & solution format as stated above) 

    - the expansion & compression of embedded objects (such as problems, solutions, systems, concepts, and interfaces which change on other dimensions than the problem space dimensions) to the embedded graphs in the problem space using vectors 

    - alternate versions of the problem space with other attribute sets as dimensions, to isolate impact of a solution on other attributes 

    - concepts having structure in a problem space depending on the context determining that space 

        - example of structure applied to a concept: dependence is a form of the power concept with nodes running tasks for a powerful node 

    - interfaces represented as a filter converting objects to a foundation where vector sets representing different unit core functions of change possible on that interface (where core interface functions are depicted in embedded graphs or adjacent converted graphs of a problem space, and including a function to convert other objects to combinations of the vectors in that interface's vector set 

        - example: converting objects to the type interface involves identifying attribute sets that are unique, and then identifying types that can describe multiple unique objects as variations of an attribute in the attribute set 

[0025] A problem-solving effect may be measured based on whether a solution contains or comprises a vector that: 

    - neutralizes a problem vector 

    - reduces the problem shape size 

    - removes a problem dimension or variable 

    - does any combination of the above for the origin problem & related problems, potentially neutralizing the problem space itself or converting it to another problem space. 

[0026] This system enables the identification of solution spaces, solution sets achieving different solution metrics within the solution space, and may also identify optimal solutions for a particular problem, problem type, or problem network in a particular problem space. This enables the automation of finding solutions that optimize specific solution metrics defined in a problem statement in a discoverable system (where relevant system objects can be described, core system functions can be derived, solutions can be tested, & success can be measured with some metric & threshold or target value). This enables arriving at insights sooner, building products optimally sooner, inventing products sooner, and predicting patterns sooner, with less data & computational capacity. 

[0027] This system relies on the dependencies: 

    - a database including tables to store found associations & objects in queries, as well as tables storing data sources & solution sources, as well as standard objects & their metadata (such as definition routes & conceptual queries) following the schema specified in my repository: https://github.com/outdreamer/build-a-cure/blob/52c3461fdd3ff38284b63f8c2e71542f415d88d9/docs/objects/schema.md  

    - an example of an object definition includes attributes like: 

        - core spaces: default sets or other structures where this object can develop - core structures (points, filters, limits, boundaries) 

        - core objects 

        - core functions 

        - dependencies: required objects or alternative object sets that can build this object 

        - optimization potential 

        - conceptual attributes (completeness, relevance, randomness, importance, complexity, reusability, independence, modularity) 

        - abstraction: abstraction level should reduce misunderstandings while optimizing reusability 

        - automation potential (resource investment, rule stabilization) 

        - applicable definitions (like for equivalence) 

        - minimum object identification information (required identity attributes) - relationships 

        - adjacent/related objects of same/different type 

        - problems with adjacent objects & how those problems are generated by adjacent object metadata 

        - order/position in chains & networks of this type 

        - interface queries that can produce this object 

        - related interface objects (problems, questions, strategies, insights, perspectives, filters, intents, concepts, patterns, structures, functions, types, incentives, assumptions, limits, state, problems, potential, games) 

        - context (use cases, extreme cases, examples) 

    - a graphical user interface (GUI) providing inputs to provide problem statement, solution metrics & other metadata described below 

    - logic including: 

        - a set of definitions, set of core objects, and a set of functions (converting, filtering, applying core interface functions, traversing interface network) for each interface 

        - a set of functions to select filters to display in the GUI, and validate input (for example, if the problem statement doesn't match problem type specified) 

        - a set of functions to convert a problem statement (and problem space context if provided) into the problem object metadata 

        - a set of functions for core operations like: 

            - find (function to apply filters to a structure) 

            - build (function to assemble components given a particular definition of combine) 

            - derive (function to identify possible paths, compare them, and select one given a solution metric) 

            - change (function to apply an object, function, or attribute to another) 

            - define (function to identify & define attributes, functions, & objects (given minimal information like their position in a system or their set of attributes compared to other system objects)) 

        - a set of utility functions, including: 

            - a function to convert an object between formats (function => attribute sequence, function => filter sequence, etc) by mapping attributes & functions & other metadata of the objects & removing attributes that don't fit in the target format definition (for example, if the user is converting to a type, the output should be in an attribute set format) 

            - a function to identify structure matching a pattern (like identify a structure embodying a mismatch, which is a problem type, given a system network definition, where the system could represent an object, function, or attribute) 

            - a function to identify sub-components or system context of a component (a component which could be either a function, object, or attribute) 

        - a set of graphing functions 

            - to graph the problem space, problem, related problem network, solution space, solution, embedded graphs, interfaces, and other relevant objects 

        - a set of problem & solution functions 

            - a set of functions to evaluate & select between comparable solutions, including selecting solutions based on input preferences selected (avoid using ML in solution, use a particular interface, use pre-computed solutions, etc) 

            - isolate the solution space in the problem space 

            - break the problem space into sub-problems that can execute their own interface traversal & solution-matching process to find sub-solutions 

            - reduce the solution space 

            - apply the solution to the problem space 

            - a function to check if a solution reduces a problem or fulfills a solution metric 

            - a function to check if a solution fits a structure such as input assumptions & limits 

        - a set of specific functions for each interface, for example: 

            - intent: a function to derive intent as a dependency of the intent interface conversion function 

            - core: a set of functions to generate the set of possible combinations in an interaction space to conduct core combination analysis & identify probable important objects like an incentive would be identified as an important system object given the system filters it passes after being generated by core combination analysis) 

            - type: a function to identify the type an object belongs to, given its metadata 

            - system: a function to identify system objects given their definition, such as a variance gap (a gap in rule enforcement) 

            - concept: a function to identify concepts given their definition & a system network (either structures applies to abstract concepts - or useful combinations of objects, functions, & attributes that are causative or interfaces in a system) 

        - a set of functions to analyze prior queries, optimize & maintain the program, such as: 

            - removing duplicates 

            - analyzing solution statistics 

            - optimizing an interface traversal once found 

            - pre-computing & storing frequently requested traversals 

            - optimizing data storage & logic given how other users are using the program 

[0028] A standard workflow for this system may involve: 

    - inputs: 

        - required: 

            - the problem statement 

            - the interface definitions 

            - logic functions to traverse interfaces, visualize the impact of a solution on the problem/problem space, & test for adherence to a solution metric, check input for validity 

        - optional: 

            - the problem space context, without which the program will make API calls to fetch data & definitions (including data like alternate definition sources, object behavior rules, latest version of an open-source solution 

    - process: 

        - database storing example objects (example insights, problems, solutions, questions, patterns, functions, causes, concepts, types, systems, etc), as well as previous queries if configured to do so 

        - process 400 executed, conditionally making calls to the machine learning system and the API finding/calling system if predictions, data, or definitions are needed 

    - outputs: 

        - solution information, including any of the following: 

        - a particular solution implementation of a strategy 

        - a solution set of solutions that were not reducible given input filters 

        - a solution space identifying that a solution is possible in the problem space 

        - a set of information objects about the problem, problem network, or problem space that clarify the problem to some degree, such as causes deemed not likely or additional problem metadata derived or a problem- invalidating event identified 

[0029] One or more example embodiments are explained with reference to the accompanying drawings. 

[0030] 

    As shown in FIG. 1A, and by reference number 110, the solution automation module 140 may include a user interaction module that may include any device or system or components thereof configured to receive user input and/or provide information to the user. For example, the user interaction module 110 may present an input to enter the problem statement and a set of filters (to refine the problem statement, or attach problem and/or problem space metadata such as expected complexity, known problem sub-problem, known problem factor, or preferred problem definition) as well as an input for common & other solution metrics (such as solution- finding time/cost, solution-implementing time/cost, accuracy, using pre-computed solutions or deriving solutions from scratch, using a particular data source for definitions & other API calls inserted into the workflow rather than using system-generated data sources from the initial or previous queries, etc) to a user. In these and other embodiments, the user may utilize the user interaction module 110 to identify problem & problem space metadata & solution metrics as an input filter to reduce the solution space and evaluate output solutions. In these and other embodiments, the user may additionally utilize the user interaction module 110 to identify output solutions of varying types (including optimal, low-cost, reusable, able to reduce other problems, able to invalidate a problem space, able to change a problem space to a very different one, etc) to create a score to store the output in the database as a solution (if the score is high) or a problem (if the score is low) associated with the origin problem statement. For example, the user may designate an output solution as optimal for solving a sub-problem of the origin problem, and the database will store a link between the sub-problem and the output solution as one of the sub-problem's optimal solutions. 

    In some embodiments, user input may vary, such as where the problem statement may be an abstract statement, a statement about a problem type, or missing necessary information. The output may be incomplete or otherwise sub-optimal, in which case the user can state the problem differently or add information or their own theory about the cause or solution, or expand the allowances of the configuration to include more pattern & derivation computations than more direct problem-solving methods or pre-computed solutions that may need updating. The problem statement validation will return a message if the program cannot correct the problem statement or return a validation question to prompt the user to enter specific information. Deriving problem metadata such as the minimum information to solve a problem or deriving solution requirements would take the form of logic such as identifying required probable solution structures necessary to solve the problem & information necessary for filtering solutions in that format or for a particular intent (if it's a shape, the solution needs to be in vector format and the dimensions need to be identified). The validation will also validate other input fields like problem metadata, so that a problem statement that doesn't match the specific problem type will return an error indicating that mismatch. 

[0031] 

    As shown in FIG. 1B, and by reference number 140, the example solution automation module 140 may be used to automate finding a solution for a problem statement, in accordance with one or more embodiments of the present disclosure. The solution automation module 140 may include a user interaction module 110 and a machine learning system 120 and an API finding & calling system 130 that may provide input to a solution automation module 140. The solution automation module 140 may facilitate determination of the solution 150 associated with the problem statement, and output the solution 150 to the user interaction module 110. 

    In some embodiments, such solution automation may lead to a solution for the problem, such as the cause of a problem, the intents fulfilled by a problem and/or the solution, a set of steps to reduce the problem, or a set of steps to neutralize or change the problem space containing the problem. In these and other embodiments, if a user is dissatisfied with the provided solution 150 (e.g., the solution is incomplete or no solution was found), the user may interact with the solution automation module 140 (e.g., to add more information or remove assumptions) and the solution automation may be run again. 

    The solution automation module 140 may include any device or system or components thereof configured to utilize the inputs from the machine learning system 120 or the API finding & calling system 130 and from the user interaction module 110 to output the solution 150. 

  

[0032] 

    As shown in FIG. 1C, and by reference number 120, the solution automation module 140 may include a machine learning system. In some implementations, the machine learning model, used to predict a variable, may include a supervised machine learning model (e.g., a decision tree learning model, a learning classifier systems model, a nearest neighbor model, a support vector machine model, and/or the like), an unsupervised machine learning model (e.g., a clustering model, a neural network model, a latent variable model, and/or the like), or a combination of the aforementioned, described elsewhere herein. 

    The machine learning system 120 may include any machine learning system configured to identify relationships and/or correlations from a data set. For example, the machine learning system 120 may be configured to identify a set of most likely factors contributing to a problem or sub-problem or solution, whether directly or indirectly, by analyzing data sets. As an example, the machine learning system 120 may analyze all solution examples and predict which solution would be the best implementation for a problem definition, or analyze all sub- problem & problem associations stored in the database & predict which sub-problems would be the best way to break down a problem, or analyze all previous queries on the solution automation module 140 and predict which factors will be used the most as inputs to show on the user interface module 110 (in the absence of functions on interfaces described above, or if machine learning is specified as a preferred solution method on the user interface module 110 before running the solution automation module 140). In these and other embodiments, the machine learning system 120 may provide the correlations and/or the factors contributing to an input to the user interaction module 110 and/or the solution automation module 140. 

    In some embodiments, the machine learning system 120 may operate using any machine learning technique or deep learning technique, such as decision tree learning, association rule learning, clustering, reinforcement learning, representation learning, genetic algorithms, etc. In some embodiments, the machine learning system 120 may be utilized to perform a task, such as providing a recommendation of input filters to show in the user interface module 110 based on previous queries of the solution automation module 140. 

  

[0033] 

    As shown in FIG. 1D, and by reference number 130, the solution automation module 140 may include an API finding/calling system. 

    In some embodiments, the user may want to use alternate data sources for the definitions & object metadata, or use data sources rather than deriving information, in which case API finding/calling functionality will be executed to discover public or permitted data sources matching target objects, or the data can be generated (or the definition predicted) using a standard machine learning model. Similarly these standard methods can be used to retrieve or generate the latest implementation or pre-computations for a solution or utility function (like sorting or indexing algorithms or testing tools), when local assets are compromised or when the user sets a preference for crowd-sourced or new tools. 

  

[0034]  

    As shown in FIG. 1E, and by reference number 150, and referenced in process 400 steps 410 - 411, the solution automation module 140 may include solution output 150. The program output may include: 

    - input filters 

    - risk contributed by input filters 

    - risk contributed by traversals (using a pattern instead of an insight contributes risk) 

    - solution(s) and/or solution space 

    - solution implementation steps 

    - solution components 

    - visualization of solution impact on problem space 

    - set of queries used to generate/find/derive solutions 

    - methods to generate optimizations of those queries which the system will store for any future users with a similar problem 

    - other solution information, like solution statistics, success probability, ratio of patterns to insights used in the solution, etc. 

    - any non-fatal errors encountered, such as missing optional information or components, or patterns/predictions made in the absence of clarity 

    - any problem space information derived during the traversal, such as identified possible/probable insights, questions, strategies, patterns, causes, etc. 

    *new
    For a prediction function problem, the solution space is the range of likely prediction functions. 
	The problem space is the route between independent variables and the dependent variable on a network - it can also be framed as the route between common prediction function terms for a data set like the input data set, and the prediction function. The original problem structure is also depicted as a subset of this problem space visualization.
	The solution function can be a route on the problem space if the problem space is formatted as a network, for example.
	*eonew


[0035]  

As shown in FIG. 1F, and referenced in process 400 steps 404 - 407 & 409, the solution automation module 140 may include a method to traverse an interface (convert, iterate, match, & apply), by first converting problem systems (such as the problem space, related problems, or problem) to interfaces (such as the concept, system, intent, function, pattern, cause, change, potential interfaces), by mapping problem components to interface components. 

    For example, after converting a problem statement & problem object to the system interface, the problem should be framed as a network, so that it's easier to identify system objects within the problem such as conflicts. This function may act as a filter, isolating attributes of the problem that are specific to the interface, but may also convert the problem so that it's in a different format. This function may execute similar logic to the function to derive a definition of an object, which involves finding an alternate route (such as using the interface-specific terms) to output a set of attributes/functions (such as the problem object). If the problem cannot be mapped to an interface, log the error to be output with the final solution metrics ("error: could not translate problem 'create schedule' to the attribute interface"), and skip to the next interface in the specified sequence - if there is no next interface, return to interface selection, sequence & query design in step 403 by translating the problem to a more standard interface like the system or function or pattern interface. If it's not translatable to any interface, return an error and suggestion for additional information that could create a translatable problem that can be framed on an interface. This error may be added to a store of information generated/derived/found during traversal if the problem statement cannot be mapped to a particular interface, to be included in the output with the final solution metrics, for example "error: could not translate problem 'create schedule' to the attribute interface"). 

    Once the program has formatted a problem as a system, it iterates through objects, attributes, & functions in the problem system, checking for anything in the problem system that looks like a system object, such as a false similarity, an incentive, or an efficiency, with a particular focus on system objects that are associated with the problem type (if there are any insights relating that problem type with system objects such as imbalances relating to the info asymmetry problem type). 

    *new
    FIG. 1F depicts an example of determining a possible match between the problem system intersection object and the system conflict object.

    The system on the top left depicts a subset of the Problem System containing the Intersection Object, formatted as a network.

    The intersection & conflict object on the top right are integrated to produce an example of labeling a problem system component (like an intersection) with the possible matching component in the system interface (and a level of certainty added by each matching attribute/function) - the matching system component here is a conflict object, based on certain conflict attributes from its definition like diverging intents and resource competition.
    *eonew

    As shown in FIG. 1G, and referenced in process 400 steps 404 - 407, the solution automation module 140 may include a method to convert matching mapped interface components to problem systems. 

    *new
    FIG. 1G depicts an example visualization of applying interface object components to the problem object, where potential attributes/functions are included outside of objects and probable attributes/functions are contained in the objects.

    It also depicts the transformation of the intersection object formatted as an object to the intersection object formatted as a system in a network structure. Now that the intersection is formatted as a network, and the system objects like conflict (and its sub-components, patterns, objects, etc) have been applied to the intersection network. In the network format, position & other types of connections have semantic value. Now it's clearer that the intersection has an ambiguity in the position sequence attribute (a variant of the position overlap where only one agent can possess the resource at a given time), creating a possible conflict (determined by which agent arrives in the position first and which agent gets the position resource first). The diverging direction attribute inherent to the intersection has not been converted to a diverging intent, but it could be if the different directions indicate different intents, and if that difference is relevant to the resolution of the conflict about which agent is allowed in the position first.The mapping function has also identified a possible trade-off in the ambiguity, indicating that only one agent can occupy the position at a given time, so only one agent can go first (a scarce resource of occupation sequence or saved time that may be causative in the system, especially if the agent changes the intersection or removes some of its value by occupying it first).
    *eonew

    If while iterating through the problem system, if the program finds a possible similarity between a system conflict object and the problem system intersection object in step 406 (a similarity in shape or other attribute value), apply the system conflict objects, functions, & attributes to the problem system intersection object. This means if the system conflict object has an associated function in its definition like 'diverging intents' or 'trade-off' or 'resource competition' or 'antagonistic agent', apply those to the problem system intersection and see if they fit in the problem system intersection. An intersection is an overlap at the intersection point involving different directions, so it's likely to match the 'resource competition' and 'diverging intents' components of the system conflict object definition, but may not depending on the problem definition (the intersection may just be an incidental routing object, rather than a competition for that position, and may allow multiple objects occupying the same position, and the directions may not indicate different intents if similar objects are in both directions). Then the program would follow this analysis for example with a query to the insight interface, applying any insight objects matched there to the problem system once the system objects were identified & applied. 

[0036] 

As shown in FIG. 1H, and referenced in process 400 step 408, the solution automation module 140 may include a method to apply solution metric structures to solution structures. 

    For example, once the program formats the problem as a system, identifies system objects in the problem, & applies their objects/functions/attributes, it checks for a clear way to solve the problem or determines if other functionality needs to be applied? In some embodiments, the program may run processes like identifying all the conflicts & incentives in the problem system & applying insights moving derived/generated/found information toward the minimum information to solve and/or fulfilling the solution metrics, then checking if there is a clear route or transformation that removes the problem as it was defined. For example, once the intersection object has had the system interface applied, checking if it's clear from the system interface application which agent should go first, or whether there is an optimization possible in the intersection that will invalidate the conflict of who goes first, or whether other functionality need to be applied, such as other conflict sub-systems such as finding substitutes of a resource (like an alternate route) to invalidate a conflict of the resource competition sub-type. 

    In some embodiments, this step may return to interface selection, sequence & query design at step 403, to apply standard interface origin/sequence/queries stored, after retrieving them from the database, translating the problem to a more standard interface (like the system or function or pattern interface), if there is no next interface in the sequence/query. 

    In some embodiments, this step may check if the standard interface origin/sequence/query have been applied already, and if there is also no next interface in the sequence, it may skip further traversals & return any information generated/derived/found, including the processes tried & results, to the user interaction module 110. 

    In some embodiments, this step may also involve calculating some solution statistics given stored information in the database such as information about previous queries or feedback on solutions entered by user on returning to the solution output in the user interaction module (stored as its own problem output report & accessible with the user interaction module). 

    In some embodiments, this step may also allow the user to download solution steps, optimize the system or the traversal (skipping unnecessary nodes & so on), examine the queries that generated the solution, review the risk contributed by each filter or pattern or other risky object depended on by the solution or solution generation process, & execute other actions on the output information. 

    After a solution has been generated/derived/found by the program, the program may include a secondary workflow involving an edit to the solution output. 

    In some embodiments, this step may also allow the user to edit the problem space visualization component & examine the impact of other solutions, drill down into embedded object graphs in the problem space, move or otherwise change problem objects, & adjust displayed dimensions of the space like intent, which may trigger an execution of the problem definition, interface conversion & traversal process depending on the edits made. 

    In some embodiments, as the edit may optionally involve an edit to the problem space visualization, the edit may trigger a function to evaluate if a re-calculation of the solution is necessary, or if problem space visualization logic or solution output is sufficient to handle the edit (such as removing a dimension of the visualization). 

    In some embodiments, if the re-calculation function is called & determines that a re-calculation is necessary, the program may determine which step contains the functionality for that re-calculation, and returns to that step, to create a new version of the solution output sent to the user interaction module 110. For example, in some embodiments, the program may determine if the edit requires returning to step 402 to re-define the problem definition, step 403 to execute interface selection, sequence & query design, or step 404 to convert to the same interface or a standard interface and execute the traversal generating the solution output. 

    In some embodiments, if the re-calculation function is called & determines that no re-calculation is necessary, the program may adjust the solution output according to the edit, using visualization logic & output information. 

    In some embodiments, solutions that optimize metrics not specified by the user may be included in the output, such as solutions optimizing the user-specified solution metric and metrics that impact other problem-solvers, like the environment. For example, even if a user didn't request clean energy solutions for their traversal to find the optimal implementation of a Air Conditioning unit, the program may still return energy-conserving solutions like automatically shutting itself off when target temperature is reached, given that this energy- conserving solution optimizes more metrics than the requested solution, or that other users preferred the energy-conserving solution metric, or that the program identified energy- conserving solution metrics as conserving available resources, which would not only improve cross-system design for many agents using the program but also increase the likelihood that the program would have energy to run parallel processing or large queries or self-maintenance & self-optimization logic. 

    In some embodiments, after being presented with the solution 150, the user may be dissatisfied with the solution 150. In these and other embodiments, the user may modify or adjust one or more of the input filters provided to the solution automation module 140 regarding the problem/problem space/solution metadata derived and the origin interface & the formats selected for the problem-solution matching process. 

    By iteratively repeating the process of adjusting the input filters by the user, the solution automation module 140 may repeatedly generate different solutions 150 until the user is satisfied with the solution 150. In some embodiments, the user may be dissatisfied with the solution based on preference the user has about their preferred optimal solution for the problem statement. In that case, they can add a filter to reduce the solution output, and if the program can find or derive the definition for that metric, it will apply it in the next query. If some metrics or formats contribute to uncertainty in the problem/solution filtering, formatting, compression, interface traversal, or other processes run by the program, the program will return output about the contribution of risky metrics to the uncertainty in the solution output. For example, if the user adds a custom filter like 'importance' and the program were to retrieve or derive an over-specific definition such as 'number of hub connections', it would cause distortions in the output, which would be included in the report as a risky filter that can be removed. Otherwise the solution may speed up the user's problem-solving process, to identify improvements to a product design, prediction function, or route with just a problem statement. 

    *new
    FIG. 1H depicts Solution Metric 1 on the top left, which is where the agent position occupation sequence is determined. 

    It also depicts Solution Metric 2, where the agent position occupation sequence is determined as needed with an intersection change (such as by adding a decision function to the intersection). An example solution fulfilling solution metric 2 (the Sequence decision function attached to the intersection object) is on the top right of FIG. 1H.
    
    This step identifies whether the output of step 407 in Fig. 4 creates information that is easily transformed into the solution metric, given the relevant objects/attributes/functions of the solution metric. Is it clear which agent goes first, or whether the intersection can be changed in a way that determines which agent goes first?

	If the solution metric 1 is fulfilled, the agents have no antagonistic agent attribute & there is no trade-off because no variance from a decision is allowed at the intersection.

	If the solution metric 2 is fulfilled, the intersection loses its position overlap attribute & the diverging direction attribute doesn't matter anymore, but it does have a decision function at the intersection.

	If the intersection object with the system interface is applied can be easily transformed into having one of the solution metrics fulfilled, that transformation can be considered a possible solution.

	This step can involve user edits to the problem space visualization component of the user interface module 110, including edits like changing the position or other attributes of problem objects & their attributes/functions, applying different solutions in the solution set, changing the dimensions of the problem space. When the user edits the problem space visualization, the changes are sent to step 402 or later (depending on whether adjustment of the problem definition or conversion to the interface needs to be done & so on), where the calculations are executed to return the output of the new impact those edits would have on the problem space.
    *eonew

[0037]  

As shown in FIG. 1I, the solution automation module 140 may include a method to map a definition as a set of routes on interfaces such as the structural interface. 

	*new
	FIG. 1I describes example structural component definitions, depicting a subset of the structural definitions of the conflict object.

	The Resource Competition structure depicts an alignment of intent across agents in a sub-system of the conflict object.

	Descriptive Ambiguity 1 depicts an example format of a decision sub-system, specifically the decision between equivalent or similar alternates in different directions.

	Descriptive Ambiguity 2 depicts an example format of a decision sub-system, specifically the decision between equivalent or similar routes.
	*eonew

[0038]  

As shown in FIG. 1J, and by reference number 145, the solution automation module 140 may include a solution automation module repository, containing: 

	*removed
    - an index of info objects (insights, problems, solutions, functions)
    *eoremoved

    *new
    - an index of info objects (a data store containing info objcts like definitions, formats, concepts, insights, problems, solutions, functions, strategies, patterns, etc)
    *eonew 

    - program configuration (data sources, query & usage statistics, optimization configuration, prior queries & related objects) 

[0039]  

As shown in FIG. 1J, a user may be associated with a client device, a server device, and a solution automation module 140. In some cases, the user may wish to utilize the client device to access information (in formats such as a text document or data set) provided by the server device. As further shown in FIG. 1J, and by reference number 105, the server device may provide document information to the client device. In some implementations, the information may include information associated with the document, such as textual information provided in the document, information indicating locations of the document at the server device (e.g., uniform resource locators (URLs)), information indicating folders storing information associated with the document in the server device, information indicating files associated with the document that are stored in the server device, and/or the like. As further shown in FIG. 1J, the client device may receive the document information, and may provide a user interface (e.g., a web browser) that displays the information to the user. As further shown, the user interface may include a mechanism (e.g., a button, a link, a browser plugin, and/or the like) which, when selected, may cause the client device to generate a request to find, derive, or generate solutions to the problem statement, using the document information. As further shown in FIG. 1J, and by reference number 110, if the user selects the mechanism, the client device may provide, to the solution automation module 140, the document information and the request to find, derive, or generate solutions. The solution automation module 140 may receive the document information and the request to find, derive, or generate solutions to the problem statement. In some cases, the user may alternatively wish to utilize the client device to access information provided by an API or website, which could be downloaded to the client device & uploaded in the user interaction module 110, just like the document information could be uploaded. 

[0040]  

As indicated above, FIGS. 1A-1J are provided merely as examples. Other examples are possible and may differ from what was described with regard to FIGS. 1A-1J.  

[0041]  

FIG. 2 is a diagram of an example environment 200 in which systems and/or methods, described herein, may be implemented. As shown in FIG. 2, environment 200 may include a client device 210, an solution automation module 220, a network 230, and a server device 240. Devices of environment 200 may interconnect via wired connections, wireless connections, or a combination of wired and wireless connections. 

Client device 210 includes one or more devices capable of receiving, generating, storing, processing, and/or providing information, such as information described herein. For example, client device 210 may include a mobile phone (e.g., a smart phone, a radiotelephone, etc.), a laptop computer, a tablet computer, a desktop computer, a handheld computer, a gaming device, a wearable communication device (e.g., a smart wristwatch, a pair of smart eyeglasses, etc.), or a similar type of device. In some implementations, client device 210 may receive information from and/or transmit information to solution automation module 220 and/or server device 240. 

Solution automation module 220 includes one or more devices that utilize machine learning models to predict a variable (e.g., provided by server device 240 to client device 210). In some implementations, solution automation module 220 may be designed to be modular such that certain software components may be swapped in or out depending on a particular need. As such, solution automation module 220 may be easily and/or quickly reconfigured for different uses. In some implementations, solution automation module 220 may receive information from and/or transmit information to one or more client devices 210 and/or server devices 240. 

In some implementations, as shown, solution automation module 220 may be hosted in a cloud computing environment 222. Notably, while implementations described herein describe solution automation module 220 as being hosted in cloud computing environment 222, in some implementations, solution automation module 220 may not be cloud-based (i.e., may be implemented outside of a cloud computing environment) or may be partially cloud-based. 

Cloud computing environment 222 includes an environment that hosts solution automation module 220. Cloud computing environment 222 may provide computation, software, data access, storage, etc. services that do not require end-user knowledge of a physical location and configuration of system(s) and/or device(s) that hosts solution automation module 220. As shown, cloud computing environment 222 may include a group of computing resources 224 (referred to collectively as "computing resources 224" and individually as "computing resource 224"). 

Computing resource 224 includes one or more personal computers, workstation computers, server devices, or other types of computation and/or communication devices. In some implementations, computing resource 224 may host solution automation module 220. The cloud resources may include compute instances executing in computing resource 224, storage devices provided in computing resource 224, data transfer devices provided by computing resource 224, etc. In some implementations, computing resource 224 may communicate with other computing resources 224 via wired connections, wireless connections, or a combination of wired and wireless connections. 

As further shown in FIG. 2, computing resource 224 includes a group of cloud resources, such as one or more applications ("APPs") 224-1, one or more virtual machines ("VMs") 224-2, virtualized storage ("VSs") 224-3, one or more hypervisors ("HYPs") 224-4, and/or the like. 

Application 224-1 includes one or more software applications that may be provided to or accessed by client device 210 and/or server device 240. Application 224-1 may eliminate a need to install and execute the software applications on client device 210 and/or server device 240. For example, application 224-1 may include software associated with solution automation module 220 and/or any other software capable of being provided via cloud computing environment 222. In some implementations, one application 224-1 may send/receive information to/from one or more other applications 224-1, via virtual machine 224-2. 

Virtual machine 224-2 includes a software implementation of a machine (e.g., a computer) that executes programs like a physical machine. Virtual machine 224-2 may be either a system virtual machine or a process virtual machine, depending upon use and degree of correspondence to any real machine by virtual machine 224-2. A system virtual machine may provide a complete system platform that supports execution of a complete operating system ("OS"). A process virtual machine may execute a single program, and may support a single process. In some implementations, virtual machine 224-2 may execute on behalf of a user (e.g., a user of client device 210 and/or server device 240, or an operator of solution automation module 220), and may manage infrastructure of cloud computing environment 222, such as data management, synchronization, or long-duration data transfers. 

Virtualized storage 224-3 includes one or more storage systems and/or one or more devices that use virtualization techniques within the storage systems or devices of computing resource 224. In some implementations, within the context of a storage system, types of virtualizations may include block virtualization and file virtualization. Block virtualization may refer to abstraction (or separation) of logical storage from physical storage so that the storage system may be accessed without regard to physical storage or heterogeneous structure. The separation may permit administrators of the storage system flexibility in how the administrators manage storage for end users. File virtualization may eliminate dependencies between data accessed at a file level and a location where files are physically stored. This may enable optimization of storage use, server consolidation, and/or performance of non-disruptive file migrations. 

Hypervisor 224-4 may provide hardware virtualization techniques that allow multiple operating systems (e.g., "guest operating systems") to execute concurrently on a host computer, such as computing resource 224. Hypervisor 224-4 may present a virtual operating platform to the guest operating systems, and may manage the execution of the guest operating systems. Multiple instances of a variety of operating systems may share virtualized hardware resources. 

Network 230 includes one or more wired and/or wireless networks. For example, network 230 may include a cellular network (e.g., a fifth generation (5G) network, a long-term evolution (LTE) network, a third generation (3G) network, a code division multiple access (CDMA) network, etc.), a public land mobile network (PLMN), a local area network (LAN), a wide area network (WAN), a metropolitan area network (MAN), a telephone network (e.g., the Public Switched Telephone Network (PSTN)), a private network, an ad hoc network, an intranet, the Internet, a fiber optic-based network, and/or the like, and/or a combination of these or other types of networks. 

Server device 240 includes one or more devices capable of receiving, generating, storing, processing, and/or providing information, such as information described herein. For example, server device 240 may include a laptop computer, a tablet computer, a desktop computer, a server device, a group of server devices, or a similar type of device, that provides a social media application for access by client device 210. In some implementations, server device may receive information from and/or transmit information to client device 210 and/or solution automation module 220. 

The number and arrangement of devices and networks shown in FIG. 2 are provided as an example. In practice, there may be additional devices and/or networks, fewer devices and/or networks, different devices and/or networks, or differently arranged devices and/or networks than those shown in FIG. 2. Furthermore, two or more devices shown in FIG. 2 may be implemented within a single device, or a single device shown in FIG. 2 may be implemented as multiple, distributed devices. Additionally, or alternatively, a set of devices (e.g., one or more devices) of environment 200 may perform one or more functions described as being performed by another set of devices of environment 200. 

[0042] One skilled in the art, after reviewing this disclosure, may recognize that modifications, additions, or omissions may be made to the environment 200 without departing from the scope of the disclosure. For example, the operations of the process 200 may be implemented in differing order. Additionally or alternatively, two or more operations may be performed at the same time. Furthermore, the outlined operations and actions are provided as examples, and some of the operations and actions may be optional, combined into fewer operations and actions, or expanded into additional operations and actions without detracting from the essence of the disclosed embodiments. 

[0043]  

FIG. 3 is a diagram of example components of a device 300. Device 300 may correspond to client device 210, solution automation module 220, computing resource 224, and/or server device 240. In some implementations, client device 210, solution automation module 220, computing resource 224, and/or server device 240 may include one or more devices 300 and/or one or more components of device 300. As shown in FIG. 3, device 300 may include a bus 310, a processor 320, a memory 330, a storage component 340, an input component 350, an output component 360, and a communication interface 370. 

Bus 310 includes a component that permits communication among the components of device 300. Processor 320 is implemented in hardware, firmware, or a combination of hardware and software. Processor 320 is a central processing unit (CPU), a graphics processing unit (GPU), an accelerated processing unit (APU), a microprocessor, a microcontroller, a digital signal processor (DSP), a field-programmable gate array (FPGA), an application-specific integrated circuit (ASIC), or another type of processing component. In some implementations, processor 320 includes one or more processors capable of being programmed to perform a function. Memory 330 includes a random access memory (RAM), a read only memory (ROM), and/or another type of dynamic or static storage device (e.g., a flash memory, a magnetic memory, and/or an optical memory) that stores information and/or instructions for use by processor 320. 

Storage component 340 stores information and/or software related to the operation and use of device 300. For example, storage component 340 may include a hard disk (e.g., a magnetic disk, an optical disk, a magneto-optic disk, and/or a solid state disk), a compact disc (CD), a digital versatile disc (DVD), a floppy disk, a cartridge, a magnetic tape, and/or another type of non-transitory computer-readable medium, along with a corresponding drive. 

Input component 350 includes a component that permits device 300 to receive information, such as via user input (e.g., a touch screen display, a keyboard, a keypad, a mouse, a button, a switch, and/or a microphone). Additionally, or alternatively, input component 350 may include a sensor for sensing information (e.g., a global positioning system (GPS) component, an accelerometer, a gyroscope, and/or an actuator). Output component 360 includes a component that provides output information from device 300 (e.g., a display, a speaker, and/or one or more light-emitting diodes (LEDs)). 

Communication interface 370 includes a transceiver-like component (e.g., a transceiver and/or a separate receiver and transmitter) that enables device 300 to communicate with other devices, such as via a wired connection, a wireless connection, or a combination of wired and wireless connections. Communication interface 370 may permit device 300 to receive information from another device and/or provide information to another device. For example, communication interface 370 may include an Ethernet interface, an optical interface, a coaxial interface, an infrared interface, a radio frequency (RF) interface, a universal serial bus (USB) interface, a Wi-Fi interface, a cellular network interface, and/or the like. 

Device 300 may perform one or more processes described herein. Device 300 may perform these processes based on processor 320 executing software instructions stored by a non-transitory computer-readable medium, such as memory 330 and/or storage component 340. A computer-readable medium is defined herein as a non-transitory memory device. A memory device includes memory space within a single physical storage device or memory space spread across multiple physical storage devices. 

Software instructions may be read into memory 330 and/or storage component 340 from another computer-readable medium or from another device via communication interface 370. When executed, software instructions stored in memory 330 and/or storage component 340 may cause processor 320 to perform one or more processes described herein. Additionally, or alternatively, hardwired circuitry may be used in place of or in combination with software instructions to perform one or more processes described herein. Thus, implementations described herein are not limited to any specific combination of hardware circuitry and software. 

The number and arrangement of components shown in FIG. 3 are provided as an example. In practice, device 300 may include additional components, fewer components, different components, or differently arranged components than those shown in FIG. 3. Additionally, or alternatively, a set of components (e.g., one or more components) of device 300 may perform one or more functions described as being performed by another set of components of device 300.  

[0044]  

As shown in FIG. 4, the solution automation module 140 may include a general execution process 400 to implement a problem-solving automation workflow in steps 402 - 410. 

The general workflow (structure) of process 400 that implements these problem-solving automation workflows (implemented in steps 402 - 410, starting from problem validation & metadata extraction, to interface query design, to applying the interface to the problem, to generating & evaluating solutions) is as follows: 

        401. In this step, the problem statement is obtained from user in user interaction module 110, with optional filters such as the origin interface, inputs for known metadata like the problem type, and inputs for solution metrics like a certain object structure or an attribute value. 

        402. In some embodiments, this step may also include checking the user input for validity, with regard to considerations like whether the input problem type matches the problem statement, then checking if the user input is valid (with regard to considerations like whether the input problem type matches the problem statement). If not, return error message or correction suggestion to the user interaction module 110, so the user can edit the inputs & re-submit the form. If valid, convert to concise problem statement & derive problem metadata not specified by user, such as problem variables (such as agency involved in the problem, etc), optimal problem format, sub-problem types, required information to solve, solution metrics to filter successful solutions, definition of solution success, etc. 

        403. Identify optimal origin interface to start traversal from (based on what information the user input or was derived in step 402, such as if it's a social problem, the best problem format is probably a system format, & starting traversal on the system interface to identify agent intents & incentives), optionally including: 

            - interface sequence (such as start from the pattern interface if there isn't enough information & then convert to the system interface by fitting the patterns identified into a system) 

            - query (such as 'map the concept interface to the structural interface') 

            Alternatively, if none is determinable, use the standard origin interface, sequence & query, which may be: 

                - start from origin system interface, checking for components fitting the object, attribute, & function interfaces (as well as structural interfaces & objects frequently found in systems like symmetries and equivalences), applying the insight interface where there is uncertainty and the pattern interface where the insight interface cannot reduce uncertainty. 

            In some embodiments, it may not be clear which interface should be the origin interface, in which case multiple processes can be run if allowed by user configuration (for example, if they selected 'performance' as a metric to optimize, meaning the user requests a quick solution, multiple parallel processes wouldn't be allowed), and may periodically stop and check if the other process has useful information or is nearer to the solution, at which point the slower process can stop. 

            In some embodiments, this step may use a standard interface origin, sequence & query, if none are determinable from the problem statement - a standard interface origin, sequence & query which may be similar to: "start from origin system interface, checking for components fitting the object, attribute, & function interfaces (as well as structural interfaces & objects frequently found in systems like symmetries and equivalences), applying the insight interface where there is uncertainty and the pattern interface where the insight interface cannot reduce uncertainty". 

            In some embodiments, alternate default core interfaces may be selected than the abstract interfaces such as function, system, type, etc. Some embodiments may organize these interfaces by type, so that function/pattern/insight/strategy are all stored as sub- interfaces of the rule interface, and the same for information/structure/math being related interfaces with minor transformations. 

            In some embodiments, alternate implementations of the functions may determine the system functions such as: 

                - visualization of problem space & problem dimensions, composition, & solution application 

                - utility functions like identifying unique & conceptual attributes given a system definition 

                - high-level logic functions like determining whether a solution reduced a problem or achieved an intent 

            In some embodiments, alternate default interface trajectories may be determined to be optimal using analysis of previous queries run on the solution automation module, if the user configures the program to self-optimize in the GUI, such as starting from an interface that generally solves the problem of a certain type more quickly, which is determined by querying the insight table pre-traversal once the problem type is identified, as opposed to searching for new solutions or optimizing known solutions for that problem type, or converting problems to a problem type with many known solution methods, like a route optimization problem. 

            The origin interface selection process may also output a interface sequence and/or an interface operation to map one interface to the other, combine them, or apply one to the other. The origin interface may also be in the form of a query across multiple interfaces. For example: 'find the patterns of associated solutions for this problem type, and convert problem to patterns, and iterate through patterns, applying them one at a time to the problem pattern'. 

            Different traversals are associated with different starting information and/or different problem type and/or different solution intent. For example, framing a problem on the change interface may help predict how the problem will change better than framing it on other interfaces. Example interface traversals include: 

        - system interface traversal 

          - general: fit system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, and conflicts to problem/solution/space definition 

          - specific: find the lowest-cost path in a system (maximizing the number of efficiencies used) using incentivized paths 

        - information interface traversal 

          - general: use logic such as mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack 

          - specific: frame a 'find a particular record in a data set' problem as a combination problem of a missing information problem type (composed of a filter-selection problem, an indexing problem, and a sorting problem) or a route optimization problem type (starting point in data set, search/split/sort method selection, and cost-minimization problem for worst-case destination given starting point) 

        - insight path application 

          - general: use insight paths from other fields to optimize insight generation/finding/derivation, where insight paths can contain questions, strategies, insights, & other information objects that are usable across systems to generate/find/derive insights in a semi-unknown system 

          - specific: use insight paths from gene editing to automate inventing by mapping gene editing functions (switch, remove, alter) to inventing problem space functions (switch components, remove assumption, alter variable) 

        - intent interface application 

          - general: convert inputs/outputs/functions, objects, & attributes to intent to check progress toward solution intent or avoid side effect intents, where adjacent reasons to call the operation & operation outputs are assumed to be included in the intent stack of an operation 

          - specific: convert inputs/outputs/functions, objects, & attributes to intent, to check progress toward target solution metric or avoid side effects 

        - structural interface application 

          - general: find a standard structure & format the problem using that structure 

          - specific: convert functions to standard structures like paths, networks, filters, or attributes to check if a function fulfills a solution metric 

        - core interface traversal 

          - general: use combinations of core functions (find, build, apply, derive), objects (layer, filter, gap, limit), and attributes (equal, similar) to create a core interaction space & system layer diagram and find target objects quickly using structural definitions of concepts like optimal or applying system filters, or predict missing objects on other layers 

          - specific: use the core functions of the 'combine' or 'organize' intent to predict the next generation of products invented 

        - concept-structure traversal (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts) 

          - general: 

            - find a structure for a certain intent that matches a conceptual priority (like relevance, organization, robustness, equivalence, or trust) 

            - modify a structure with a certain intent so it matches a conceptual priority (like power or a conceptual structure like power distribution) 

          - specific: 

            - find a structure in the finance space that minimizes trust in transactions  

            - modify a multiplication method to find a method minimizing larger calculations 

            - a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship) 

        - pattern interface traversal 

          - general: select patterns related to stated objects and traversal for patterns or pattern generators linking them to generate an origin solution space to begin compressions at 

          - specific: select patterns related to variable relationships & probability distributions to predict the likeliest ways a function will change 

        - a causal interface traversal 

          - general: match problem structures to causal structures (like tree/network/loop/layer) to infer probable causation metadata like directness of cause, degree of cause, inevitability, ambiguity, uniqueness of cause, causal shape 

          - specific: 

            - find the set of causal objects, functions, and attributes describing a relationship to create a prediction function or reduce input features 

            - apply causal structure relationships to determine if the data is missing information 

        - structure-math interface mapping 

          - general: use a multi-interface traversal to map problem structures to math objects to apply math insights to problem structures 

          - specific: if the problem is 'predict the shape of the boundary of an even distribution of change across directions from the same origin' (for problems like 'finding a container needed for an experiment growing microorganisms given the requirement of the same origin and non-overlapping paths', or 'predicting the threshold marker needed for comparing speed metrics'), apply the 'circle' definition route using the 'evenly distributed outward motion' route to infer that the boundary could be circular, with variable advantages depending on problem metadata 

        - problem interface traversal, specifically a problem vectorization framing the solution as a path in the problem space (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions) 

          - general:  

            - infer important interim concepts of a problem system (like the 'duplicate line' concept for building a 'merge files' function) and use intent- mapping to connect stated problem objects & target outputs using available functions 

          - specific:  

            - infer the relevant 'duplicate line', 'similar line', 'similar', & 'equal' concepts of a 'build a function to merge files' problem system and use intent-mapping to connect stated problem objects (line, file, string) & target outputs (one file without duplicate lines) using available functions (iterate, check, is_similar, is_equal) 

            - a question-answer interface traversal (a sub-interface of the problem interface) 

              - general: frame a question as missing information structured as a source position and a target position on a network, and the answer as the most robust path, the most relevant path for a particular intent & objects related to it, the path that moves the nearest to the target position, or the quickest path that moves in the prioritized direction on the network 

              - specific: 

                - frame a question like 'how to build a filter' as an optimal path-finding problem on the network between some undefined starting component set & the destination filter object 

                - frame a question like 'why would you build a filter' as a adjacent object 

                - finding problem to find objects that can be produced if the filter is the starting point (input) or to find intent directions moved in when you follows paths to build the filter (reasons to build it) or subsequent paths using the filter (other applications of the filter) 

            - the problem interface includes other sub-interfaces like problem space analysis (analyzing a system composed of resources, agent intents, & problems) which is the problem interface with information & structural & system interfaces applied, to make problems & solutions visualizable within a system context 

              - general: analyze whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied, anticipating cascading, self-sustaining & self-solving problems, and selecting between solutions 

              - specific: organize a set of resources into a problem space system with dimensions indicating primary factors of change that are also interfaces (as a foundation where changes can develop and be described in other embedded graphs) or cross-system attributes (like relevance), for standardized comparison of solution impact on all problems in the problem space system 

 

        404. Convert the problem object to the interface using the interface conversion function, so that the problem is framed in terms defined on the interface. For example, after converting a problem statement & problem object to the system interface, the problem should be framed as a network, so that it's easier to identify system objects within the problem such as conflicts. This function may act as a filter, isolating attributes of the problem that are specific to the interface, but may also convert the problem so that it's in a different format. This function may execute similar logic to the function to derive a definition of an object, which involves finding an alternate route (such as using the interface-specific terms) to output a set of attributes/functions (such as the problem object). If the problem cannot be mapped to an interface, log the error to be output with the final solution metrics ("error: could not translate problem 'create schedule' to the attribute interface"), and skip to the next interface in the specified sequence - if there is no next interface, return to interface selection, sequence & query design in step 403 by translating the problem to a more standard interface like the system or function or pattern interface. If it's not translatable to any interface, return an error and suggestion for additional information that could create a translatable problem that can be framed on an interface. This error may be added to a store of information generated/derived/found during traversal if the problem statement cannot be mapped to a particular interface, to be included in the output with the final solution metrics, for example "error: could not translate problem 'create schedule' to the attribute interface"). 

        405. Traverse the interface, looking for mappable objects, attributes, and functions between the problem object and the interface objects. For example, once the user has formatted a problem as a system, iterate through objects, attributes, & functions in the problem system, checking for anything in the problem system that looks like a system object, such as a false similarity, an incentive, or an efficiency, with a particular focus on system objects that are associated with the problem type (if there are any insights relating that problem type with system objects such as imbalances relating to the info asymmetry problem type). 

        406. If mappable objects are found between problem objects & interface objects, map the problem to the interface by labeling the problem object & a degree of certainty in the identification, as well as the attributes/functions/objects found to be similar. For example, if while iterating through the problem system, the program finds a possible similarity between a problem system intersection object & a system conflict object (a similarity in shape or other attribute value), apply the 'system conflict' label to the problem system intersection object. 

        407. Apply interface object components (functions, patterns, attributes) to problem objects. For example, if the program finds a possible system conflict object in the problem system in step 406, apply the system conflict objects, functions, & attributes to the problem system intersection object. This means if the system conflict object has an associated function in its definition like 'diverging intents' or 'trade-off' or 'resource competition' or 'antagonistic agent', apply those to the problem system intersection and see if they fit in the problem system intersection. An intersection is an overlap at the intersection point involving different directions, so it's likely to match the 'resource competition' and 'diverging intents' components of the system conflict object definition, but may not depending on the problem definition (the intersection may just be an incidental routing object, rather than a competition for that position, and may allow multiple objects occupying the same position, and the directions may not indicate different intents if similar objects are in both directions). Then the program would follow this analysis for example with a query to the insight interface, applying any insight objects matched there to the problem system once the system objects were identified & applied. 

        408. Check if solution metrics are fulfilled with applied interface object components. For example, once the program formats the problem as a system, identifies system objects in the problem, & applies their objects/functions/attributes, it checks for a clear way to solve the problem or determines if other functionality needs to be applied? In some embodiments, the program may run processes like identifying all the conflicts & incentives in the problem system & applying insights moving derived/generated/found information toward the minimum information to solve and/or fulfilling the solution metrics, then checking if there is a clear route or transformation that removes the problem as it was defined. For example, once the intersection object has had the system interface applied, checking if it's clear from the system interface application which agent should go first, or whether there is an optimization possible in the intersection that will invalidate the conflict of who goes first, or whether other functionality need to be applied, such as other conflict sub-systems such as finding substitutes of a resource (like an alternate route) to invalidate a conflict of the resource competition sub-type. 

        409. If solution metrics are not fulfilled, the program may move on to next interface in sequence identified in step 403 if there is one, and iterates through steps 403 - 407 as needed to execute functions like adjusting interface sequence or query, converting objects to the interface, finding similar objects between the problem & interface, applying interface objects, & checking if the solution metrics are fulfilled by that application. In some embodiments, this step may return to interface selection, sequence & query design at step 403, to apply standard interface origin/sequence/queries stored, after retrieving them from the database, translating the problem to a more standard interface (like the system or function or pattern interface), if there is no next interface in the sequence/query. In some embodiments, this step may check if the standard interface origin/sequence/query have been applied already, and if there is also no next interface in the sequence, it may skip further traversals & return any information generated/derived/found, including the processes tried & results, to the user interaction module 110. 

        410. In some embodiments, the program may return problem metadata derived or found, as well as solution space, solution set, or specific optimal solutions found, either ranked or as comparable alternatives or otherwise formatted. For a prediction problem, this may mean returning the function definition if a specific optimal function (solution) was found, or the function & variants with varying bias or other error metrics optimized (solution set) or a range of functions (solution space).  

        411. In some embodiments, the program may compare & evaluate solutions, visualize problem space, describe solution steps & traversals to generate them, and optimize the traversal & program execution, in the user interaction interface 110. This step involves listing some processes & components used as well as interim information derived during the traversal(s), and errors found or risk contributed by processing. 

  

[0045]  

As further shown in FIG. 4, process 400 may include utilizing a machine learning model to predict a variable. For example, solution automation module 220 (via computing resource 224, processor 320, memory 330, and/or the like) may utilize a machine learning model to predict a variable. In some implementations, the machine learning model used to predict a variable may include one or more of a decision tree learning model, a learning classifier systems model, a nearest neighbor model, a support vector machine model, a clustering model, a neural network model, a latent variable model, and/or the like. 

A decision tree learning model may use a decision tree data structure to perform machine learning. A decision tree data structure classifies a population into branch-like segments that form an inverted tree with a root node, internal nodes, and leaf nodes. For example, the decision tree learning model may use a decision tree as a predictive model to map observations about an item (e.g., represented in the branches of the tree data structure) to conclusions about a target value of the item (e.g., represented in the leaves of the tree data structure). The process of building a decision tree may include partitioning the data set into subsets, shortening branches of the tree, and selecting a tree (e.g., the smallest tree) that fits the data. In some implementations, a decision tree model may be a classification tree (e.g., where the target variable can take a discrete set of values) in which leaves represent class labels and branches represent conjunctions of features that lead to those class labels. Alternatively, a decision tree model may be a regression tree (e.g., where the target variable can take continuous values, such as real numbers). 

A learning classifier systems model may use learning classifier systems to perform machine learning. Learning classifier systems are a paradigm of rule-based machine learning methods that combine a discovery component (e.g. typically a genetic algorithm) with a learning component (e.g., performing either supervised learning, reinforcement learning, or unsupervised learning). Learning classifier systems seek to identify a set of context-dependent rules that collectively store and apply knowledge in a piecewise manner in order to perform functions such as classification, regression, data mining, and/or the like. Learning classifier systems allow complex solution spaces to be broken up into smaller, simpler parts. 

A nearest neighbor model may use a k-nearest neighbors model to perform machine learning (e.g., pattern recognition). A k-nearest neighbors model is a non-parametric method that may be used for classification (e.g., where the output is a class membership) in which an object is classified by a majority vote of its neighbors, with the object being assigned to the class most common among its k nearest neighbors, or may be used for regression (e.g., where the output is a property value for the object) in which the value is the average of the values of its k nearest neighbors. Additionally, weights may be assigned to the contributions of the neighbors, so that the nearer neighbors contribute more to the average of the values than the more distant neighbors. 

A support vector machine model may use a support vector machine (also known as a support vector network) to perform machine learning. A support vector machine is a supervised learning model with associated learning algorithms that analyze data used for classification and regression analysis. Given a set of training examples, each marked as belonging to one or the other of two categories, a support vector machine training algorithm builds a model that assigns new examples to one category or the other. A support vector machine model represents examples as points in space that are mapped so that the examples of separate categories are divided by a clear gap. New examples are then mapped into that same space and predicted to belong to a category based on which side of the gap they fall. 

A clustering model may use cluster analysis (also known as clustering) to perform machine learning. Cluster analysis is the task of grouping a set of objects in such a way that objects in the same group (called a cluster) are more similar to each other than to objects in other groups. Cluster analysis can be achieved by various methods that differ significantly in their notion of what constitutes a cluster and how to efficiently find them. Different cluster models may include connectivity models (e.g., where hierarchical clustering builds models based on distance connectivity), centroid models (e.g., where the k-means algorithm represents each cluster by a single mean vector), distribution models (e.g., where clusters are modeled using statistical distributions, such as multivariate normal distributions used by the expectation-maximization algorithm), density models (e.g., where clusters are defined as connected dense regions in the data space), and/or the like. 

A neural network model may use an artificial neural network to perform machine learning. An artificial neural network utilizes a collection of connected units or nodes called artificial neurons. Each connection between artificial neurons can transmit a signal from one artificial neuron to another artificial neuron. The artificial neuron that receives the signal can process the signal and then provide a signal to artificial neurons connected to it. In some artificial neural network implementations, the signal at a connection between artificial neurons may be a real number, and the output of each artificial neuron may be calculated by a non-linear function of the sum of its inputs. Artificial neurons and connections typically have a weight that adjusts as learning proceeds. The weight may increase or decrease the strength of the signal at a connection. Additionally, an artificial neuron may have a threshold such that the artificial neuron may send a signal if the aggregate signal satisfies the threshold. Artificial neurons may be organized in layers, and different layers may perform different kinds of transformations on their inputs. 

A latent variable model may use latent variables (e.g., variables that are inferred rather than directly observed) to perform machine learning. A latent variable model may infer the latent variables (e.g., through a mathematical model) from other variables that are observed (e.g., directly measured). In some cases, latent variables may correspond to aspects of physical reality that can be measured, but may not be measured for practical reasons. In such cases, latent variables may be referred to as hidden variables. In other cases, latent variables may correspond to abstract concepts, such as categories, behavioral or mental states, or data structures. In such cases, latent variables may be referred to as hypothetical variables or hypothetical constructs.   

[0046] One skilled in the art, after reviewing this disclosure, may recognize that modifications, additions, or omissions may be made to the solution automation module 140 without departing from the scope of the disclosure. For example, the designations of different elements in the manner described is meant to help explain concepts described herein and is not limiting. Further, the solution automation module 140 may include any number of other elements or may be implemented within other systems or contexts than those described. 

[0047] The foregoing disclosure is not intended to limit the present disclosure to the precise forms or particular fields of use disclosed. As such, it is contemplated that various alternate embodiments and/or modifications to the present disclosure, whether explicitly described or implied herein, are possible in light of the disclosure. Having thus described embodiments of the present disclosure, it may be recognized that changes may be made in form and detail without departing from the scope of the present disclosure. Thus, the present disclosure is limited only by the claims. 

In some embodiments, the different components, modules, engines, and services described herein may be implemented as objects or processes that execute on a computing system (e.g., as separate threads). While some of the systems and processes described herein are generally described as being implemented in software (stored on and/or executed by general purpose hardware), specific hardware implementations or a combination of software and specific hardware implementations are also possible and contemplated. 

Terms used herein and especially in the appended claims (e.g., bodies of the appended claims) are generally intended as "open" terms (e.g., the term "including" should be interpreted as "including, but not limited to," the term "having" should be interpreted as "having at least," the term "includes" should be interpreted as "includes, but is not limited to," etc.). 

Additionally, if a specific number of an introduced claim recitation is intended, such an intent will be explicitly recited in the claim, and in the absence of such recitation no such intent is present. For example, as an aid to understanding, the following appended claims may contain usage of the introductory phrases "at least one" and "one or more" to introduce claim recitations. However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles "a" or "an" limits any particular claim containing such introduced claim recitation to embodiments containing only one such recitation, even when the same claim includes the introductory phrases "one or more" or "at least one" and indefinite articles such as "a" or "an" (e.g., "a" and/or "an" should be interpreted to mean "at least one" or "one or more"); the same holds true for the use of definite articles used to introduce claim recitations. 

In addition, even if a specific number of an introduced claim recitation is explicitly recited, those skilled in the art will recognize that such recitation should be interpreted to mean at least the recited number (e.g., the bare recitation of "two recitations," without other modifiers, means at least two recitations, or two or more recitations). Furthermore, in those instances where a convention analogous to "at least one of A, B, and C, etc." or "one or more of A, B, and C, etc." is used, in general such a construction is intended to include A alone, B alone, C alone, A and B together, A and C together, B and C together, or A, B, and C together, etc. For example, the use of the term "and/or" is intended to be construed in this manner. 

Further, any disjunctive word or phrase presenting two or more alternative terms, whether in the description, claims, or drawings, should be understood to contemplate the possibilities of including one of the terms, either of the terms, or both terms. For example, the phrase "A or B" should be understood to include the possibilities of "A" or "B" or "A and B." 

However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles "a" or "an" limits any particular claim containing such introduced claim recitation to embodiments containing only one such recitation, even when the same claim includes the introductory phrases "one or more" or "at least one" and indefinite articles such as "a" or "an" (e.g., "a" and/or "an" should be interpreted to mean "at least one" or "one or more"); the same holds true for the use of definite articles used to introduce claim recitations. 

Additionally, the use of the terms "first," "second," "third," etc. are not necessarily used herein to connote a specific order. Generally, the terms "first," "second," "third," etc., are used to distinguish between different elements. Absence a showing of a specific that the terms "first," "second," "third," etc. connote a specific order, these terms should not be understood to connote a specific order. 

All examples and conditional language recited herein are intended for pedagogical objects to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions. Although embodiments of the present disclosure have been described in detail, it should be understood that various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the present disclosure. 

The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present disclosure. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the disclosure. Thus, the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein. 

  

[0048] 

The foregoing disclosure provides illustration and description, but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above disclosure or may be acquired from practice of the implementations. 

As used herein, the term component is intended to be broadly construed as hardware, firmware, or a combination of hardware and software. 

Certain user interfaces have been described herein and/or shown in the figures. A user interface may include a graphical user interface, a non-graphical user interface, a text-based user interface, or the like. A user interface may provide information for display. In some implementations, a user may interact with the information, such as by providing input via an input component of a device that provides the user interface for display. In some implementations, a user interface may be configurable by a device and/or a user (e.g., a user may change the size of the user interface, information provided via the user interface, a position of information provided via the user interface, etc.). Additionally, or alternatively, a user interface may be pre-configured to a standard configuration, a specific configuration based on a type of device on which the user interface is displayed, and/or a set of configurations based on capabilities and/or specifications associated with a device on which the user interface is displayed. 

It will be apparent that systems and/or methods, described herein, may be implemented in different forms of hardware, firmware, or a combination of hardware and software. The actual specialized control hardware or software code used to implement these systems and/or methods is not limiting of the implementations. Thus, the operation and behavior of the systems and/or methods were described herein without reference to specific software code--it being understood that software and hardware may be designed to implement the systems and/or methods based on the description herein. 

Even though particular combinations of features are recited in the claims and/or disclosed in the specification, these combinations are not intended to limit the disclosure of possible implementations. In fact, many of these features may be combined in ways not specifically recited in the claims and/or disclosed in the specification. Although each dependent claim listed below may directly depend on only one claim, the disclosure of possible implementations includes each dependent claim in combination with every other claim in the claim set. 