'''

- definition: 

  - a function can be any of the following general types:
    - rule: a static function
    - function: rule tree, composed of:
      - conditions (if/for/while/validation/organization)
      - assignments/relationships (equate an attribute with a value)
      - processes (an altering process like format, a routing process like return, etc)
    - intent: purpose for a function (at granular layers or in strict environments, purpose can be tightly aligned with the function logic, with no side effects)
    - role: function & a position in a system
    - pattern: sequence or other relationship structure of specific/identified objects (like a sequence of rules, filters, or values)
    - connection: causal relationship (some type of interaction occurs)
    - insight: important/relevant/new/unique/abstract/cross-system relationship
    - strategy: insight & a plan intent on how to implement it, usually to achieve a specific goal intent
  
  - this interface extends the core function definition of the object format, which refers to any logical rule, and applies a comprehensive definition that can standardize & describe the function potential of other objects
  - the function interface can include patterns, logic, strategies, rules, and any other set of operations/objects that has order 

- concepts (contextual fit: a function is not completely defined without usage contexts) 

- answers questions like: 
  - why are position & charge able to determine phase shift change rules?
  - are there multiple directions to approach function derivation from? 
        - can patterns in metadata-generators (difference generators) be used to derive the function generators (core functions)? 
        - does it loop around to the start, just like lowest math/structural interface (symmetry, equivalence) loops around to highest conceptual interface (balance, power, random)? 
        - the shape of the interface nexus should be a circuit feeding itself  
          (fractal inputs to itself, where input interfaces are similar in that they can both generate & be generated by the current interface) 
        - this means you can select an optimal interface to start from & a direction to navigate in on the standard order of interface traversal, and an optional interface-organizing metric (like difference) to order interfaces to traverse 
  - how to evaluate change with respect to function/intent or other function metadata: 
    - as change increases, does functionality/intent change and in what direction? 
  - is this function applicable to itself
  - is this function optimized
  - is this function usable for a range of intents or specific intents
  - what is the best format for this function
  - should this function have multiple formats or structures which are called in different contexts
  - should this function be stored as an abstract structure or code query and generated/retrieved at run-time or stored as a specific implementation
  - function-system interface question: is this function necessary for the system
  - what functions are adjacent to this function (similar to the function, or efficiently buildable with the same core functions or associated/available distortion functions)
  - examine how functions accrete into chains - how does one function get selected when it has the same input/output as another function?
    - common metrics like efficiency/availability or something more complex
    - having function metadata similarities beyond input/output
    - having core functions in common
    - having common intents
    - having enough difference to be useful to cooperate with, given inefficiency of regenerating other function on its own

- attributes:
    - state
    - context
    - complexity
    - environment
    - optimization potential
    - alternative potential
    - function type (core/boundary/abstract/change/potential)
    - alignment: enforced/optional, core, required, emergent/output (built from core functions, with or without associated intent) 
    - interaction: cooperative/conflicting 
    - intent: generative, filtering, grouping, organization/delegation/ distribution/matching/grouping/filtering, classification, differentiation/ transformation 
    - scope: use case, context, range, host system 
    - related objects (like host spaces/systems & object positions in those) 
    - interface attributes
      - intent: network of side effects (vectors, value sets, probability distributions, ranges, & complexity)
      - change: 
        - network of transformation distance/angles in relevant spaces
        - network of change responses to set of all possibly relevant transforms (capable of impacting at least one attribute or rule of the operation or its inputs) done on the operation itself
        - relevant attribute-maximizing dimensions
      - structure:
        - structure required to hold info at any given point & full set of info states
        - structure required to hold sub-operations (vector shape) 
      - function: 
        - position in function network (starting from origin & navigating outward by minimal incremental steps or attribute improvements)
        - related functions
          - alternative operations with no undesirable side effects
          - alternative operations with irrelevant undesirable side effects
          - reversing operations
          - optimizing operations

- functions:
  
    - interface-specific functions (find logical fallacy, organize, solve a problem, derive an intent, find dependencies, inject variance, maximize potential, conceptualize) 
    
    - interaction functions 

    - function metadata (responsibility, meaning, cause, intent, permissions)

      - add 'because' operator to link each decision to an intent, implication, interpretation, or assumption
      - add 'meaning' operator to index functions by meaning in addition to intent/cause/assumption/implication/context
        - "object.attribute1 = 'value' means "users can configure a variable that they will probably have different preferences on that will not add excess complexity or vulnerability to the system"
        - 'what does it mean' translates to 'what structure does it have in a relevant system' (such as relevance to users' system of use cases & preferences), or 'how does it fit within this system'
        - functions/libraries/applications should be indexed by meaning so they can be fit into a global function system across applications ("we're building this app because there's a need for this degree of difference given user intents, which means there is a mismatch in supply & demand for that market")
      - 'responsibility' as a software concept to align with 'intent', to tie functions to input/processing/output resources/processes and the associated tasks, like cleaning up resources, deleting temp resources, optimizing a memory store, setting a cache, resetting a timer, changing permissions, etc - as a method of correcting incomplete functions
      - 'integration' as a software concept to calculate interface metadata for integrated functions forming an app/site/workflow
      - this is analogous to how there are intrinsically related info object dependencies, like:
        - an argument is associated with underlying facts & logic
        - a suggestion/idea is associated with implementation details
        - a criticism is associated with a solution on how to fix it
        - similarly, functions have power that involves associated responsibility to use that, in the form of permissions (to access inputs, processing requirements, & outputs), relevance (in cleaning memory), prioritization (in process sequence or rank)
        - integrating these responsibilities with other functions isnt automated - a function doesnt check if another function with similar power has a gap in relevance-checking responsibility before leaving information unprotected, to make sure another function cant access irrelevant resources
        - responsibility is tied to relevance of the function intent 
      - privacy/permissions are relative to intent (for deriving permissions that should go with a request/function/context)
        - can you submit a 'reassure' or 'send funny meme' or 'post photo from event' intent to your messaging app, and it generates/finds a re-assuring message or meme or photo at an event using predictive logic & user decision history/algorithm on their device, instead of you sending the message, and the intents you allow are pre-approved by you or from a standard open source intent & context package, contextually applied in conversation (when 'reassure' is contextually appropriate given the prior message history or the open source context package)

    - info functions:
      - alternate
      - limit
      - enable
      - format
      - organize
      - generalize/specify
      - validate
      - track
      - decide
      - enforce
      - conflict/resolve
      - learn/optimize/correct/update
      - neutralize
      - store/restore
      - equate/differentiate (key points of difference)
      - interface functions (change, intent, type, pattern, concept, problem, strategy, insight, game, perspective)
        - uncertainty/risk/potential/prediction functions
        - solution functions (variance/stressor/error detection, tracing, identification & handler)
      - change
        - update
        - distort (gap creation, divergence)
        - standardize
        - maintain/regulate
        - potential 
          - conversion (adjacence, or what can it be transformed into using available functions)

    - core functions
      - foundation functions: enable other functionality to develop on foundation structures
      - granular functions (reverse, shift, add)
      - general functions:
        - convert (change)
        - apply (format, filter, function, etc)
        - find (find important objects/rules/variables/layers/systems)
        - identify
        - generate (using limits, filters, logic objects, structures, interfaces, symmetries, variables)
        - derive (a combination of deconstruct, match structure, assemble/isolate structure, fill structure)
        - define

    - structure functions
      - compress, expand, limit, position, convert, route, mark, distribute
      - format
      - match
      - fill (gap closing, convergence)
      - fit (path/structure derivation, path evolution in isolation & with other factors)
      - filter (reduce)
      - map (using various versions of structure/fit/format/convert functions like position/combine, and various identification functions like calculate/approximate/measure)
      - interact (combine, isolate, chain, connect, interact, contain, compete, share, coordinate, equate, group, overlap, overload, merge, trade, mix, union, intersection, inject, embed)
      
    - automation
      - function operations: resolve function definition, find functionality, index function metadata, chain functions, function-modifying/generating functions
      - interim functions: provide resources used as inputs to activate other functions (a set of molecules that when detached can activate other processes) 
      - metadata functions: find definition/attribute/object/function
        
    - dependency
      - assume
      - expect
      - contextualize

    - attribute
      - state functions
      - update attribute
      - scope (use case, relevance, lifecycle, self-destruct triggers, context, range)

    - other function types
      - decoy rules that consider probable usage, so usage follows the actual rule
      - cost-based system rules
        - avoiding assumptions or other objects where the cost of being wrong is too high to recover from 
          - in a case with multiple alternative explanations, but one is very high-cost if it's true or false, so assuming anything that rules it out cant be assumed without a high ratio of information or high number of indicators
        - cost as an aggregation/interaction rule (lowest cost routes should be assumed first)
        - cost that exceeds the value of intent should be assumed to be either false, unlikely, developing into a more efficient rule, being interacted with from another object/function/attribute, or being destroyed

- objects:
    - errors
    - assumptions
    - input/output parameters & parameter types
    - definitions of concepts like equivalence, specific to that function

- structures:
    - formats: core functions, filters, sequences, limits, network/tree representation, probabilities, attributes

'''