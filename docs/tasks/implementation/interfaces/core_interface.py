'''
  - example of the analysis for this interface: 
    - this describes the common components that can build other analysis types 
  - objects (interface objects like patterns & concepts) 
  - structures (core structures (intersections, hubs, vertices, maps, limits, symmetries, & alignments)) 
  - concepts (abstract concepts (similarity, power)) 
  - attributes: 
    - interface attributes (intent/priority, potential/certainty, perspective, causality, abstraction) 
    - commonness, scope, optimization, completeness, randomness, reusability, complexity, dependence 
    - contexts (coordinating/opposing, use cases, extreme cases, examples) 
    - coordinatability: integration potential 
    - interaction layer: which objects it interacts with, on what layers of a system like abstraction/scope layer 
    - injectability: can it be used as an input, in many operations 
    - emergence: is it generatable from other objects 
    - neutrality: the range of operations/contexts it can be used for 
    - automation/optimization potential (resource investment, rule stabilization)  
    - applicable definitions (like for equivalence)  
    - minimum object identification information (required identity attributes)  
    - relationships  
      - interface queries that can produce this object 
      - adjacent/related objects of same/different type  
      - problems with adjacent objects & how those problems are generated by adjacent object metadata  
      
  - functions (structural functions: combine, merge, apply, embed, mix, filter, chain, define, create, derive, identify, change, version)         

    - function to derive core component functions for any system - then you can write functions to calculate function metadata:
        - determine equivalent functions or more optimal version of a function
        - determine function intent
        - alter core functions used to alter function intent
        - when generating solutions, change core functions to vary to describe any function set that builds any other function set in a system
          - set of binding/interaction/priority functions for element atoms

    - target objects of problem space analysis to find an 'ethical' or other algorithm to guide an object through a system:

      - events that reduce potential (irreversible outcomes like an agent death)
      - intent vs. outcome within context (repeated intents & exploits of intent stacks for malicious intents)
      - symmetries like ambiguity, potential, & alternative-generating paths/bases
      - assumptions/limits (neutral intents are likelier to be used maliciously than positive intents)
      - context trajectory (such as maintaing a path through contexts to avoid calculations)

      - once these objects are identified as necessary to understand the problem, then the implemented objects can be identified in the problem space, & the solution can be calculated

    - derive the context set that a prediction function has varying degrees of success in (type distance, missing variables, changing problem space, etc)
      - this can be used to reduce the uncertainty by first identifying which contexts a function will be successful in predicting and then checking for those contexts in the problem space

    - rank methods of structure application for different contexts
      - expansion/compression (by intent, function, etc)
      - filters/connections
      - systematization
    
    - prediction/change/context as fundamental function objects

    - function generators:
        structural shapes (subset, limit, gap) & operations are all functions
        movement functions
        shape functions
        relationship functions
        type functions
        changing structural attributes (position) generates functions (move, polish, align, combine, etc)

    - core functions
        - build
          - copy/replace/remove
          - combine
            - group
            - merge
            - connect/bind
                - communication
                - mark/identify/recognize
                - find path
                - find map (common language)
          - boundary
          - fit/fill
          - match
              - request/response handling
          - position
            - move
            - rearrange
            - distribution
            - order
        - change
          - change prevention (regulation)
            - testing/assessment/metric selection
            - repair
          - change variable metadata (type/value)
          - change process/variable status (activate)
          - convert/translate/format
          - change reversal/compounding
          - differentiation (commitment to a state from a core state)

        - functions for the set of core conceptual math operations between concepts
          - core function + core object -> interaction rule of core attributes that aligns with core function + core object priority
          - depict core functions on their own direction to indicate a dimension when graphing

    - core structure function definitions

      - connect
        - concepts
        - functions

      - limit
        - concepts
        - functions

      - change
        - concepts
        - functions

      - combine
        - concepts:
          - anomaly/counterexample/outlier
          - conflict
          - symmetry
          - common shape (circle)
        - functions:
          - neutralizing/opposing
          - promoting/synergistic
          - core structure combinations

      - distribute
        - concepts:
          - network
        - functions:

      - filter
        - concepts:
          - network
        - functions:

      - organize
        - concepts:
          - filters
          - position
          - adjacence
        - functions:
          - info rules (storage/compression)
          - specific structural core intent rules (combine/connect/filtering/boundary)

    - emergent/interaction layer functions

        - learning (built by change function)
        - competition (built by change/find/test functions)
        - finding/borrowing/generating functionality & other resources (built by find/build functions)

    - sub-system functions

    - interim functions
        - provide resources used as inputs to activate other functions (a set of molecules that when detached can activate other processes)
        - these functions may be cross-system, or may be unnecessary middlemen in a function chain whose functionality should be merged with other functions
      
    - platform functions
        - provide platform for functionality (variance allowing functionality to develop on foundational structures)

    - intent functions
      - direct/indirect intent
      - multiple/single intents
      - certain/uncertain intent
      - abstract/neutral/specific intent
      - intent-related intents (intent-modification intent)

    - attribute-based relationship types
        - explicit (such as 'convert input energy into output structure')
        - implicit (such as unintended side effects of outputs, interim functions between input/output, and unpredicted emergent functions at scale or across many linked integrated function chains)

  - system layer analysis: 

    - apply combinations of core operations to get information object layers ('democracy games', 'barriers to intents or false information') once definitions are standardized to system interface

      perspective: priority set with object positions & default paths
      strategy: efficient path between points
      joke: difference between expected & actual position
      error: difference between expected & actual decision
      argument: position of objects or path between points with supporting connective functions
      game: incentivized motion within a system having limits to prevent motion
      filter: barrier creating a difference between input & output

    - function to apply core system layer analysis (where you generate next generation of objects using core operations supported in the space) can be used to harden a system against risk inherent in using defined objects, which will inevitably change, such as identifying new structures & interactions of the concept of risk given the next layer of imminent objects in a system

    - apply the set of core structures, functions, objects, and attributes to itself to get next layer of transforms & systems to run next error analysis
      - attribute spaces (object model + structure interface = a calculation method for attributes)
      - false similarity (info interface attribute + core attribute = an error type/definition route, if agency is involved)
      - filter chains (structure interface + structure interface = a core object to frame info)

    - function to define/generate core language functions
      - the core functionality includes combinations of the following components:
        - core operations: match, fit, apply, test, inject, build, derive, define, identify, import, change, format, structure (combine, stack, sequence, filter)
        - core objects: definition, interface, type, object, function, attribute (including interface-specific objects)
        - core attributes: relevance, difference, uniqueness, usefulness, intents, abstraction, dependencies
        - core structures: set, subset, stack/layer, sequence, connection, filter, position/point/value, boundary/limit/threshold, gap, distance, min/max, range
        - for example: combining operation 'change' with structure 'position' = a 'move' function
      - derive combinations & make sure you have full function coverage of all important combinations (check codebase function index for combinations)
      - expand on core math-language operation mapping (like add: combine, subtract: differentiate (isolate difference), multiply: expand by, divide: standardize by) with interface queries for core operations
        - define core operations: apply (expand one by the other), inject (input one to the other), embed (attach one as a component/attribute of the other)
          - the operation of injecting truth into trust on the power interface means applying the truth dynamics as an input to trust dynamics
            - example: what happens when trust is embedded in a context, and one side has more information about untrustworthiness?

    - function to identify next gen object layers would apply attribute changes & stack operations to get the structural definition routes or describe new systems
      - attributes
        - attachment
          - over
            - addiction
        - belief
          - ratio
            - uncertainty
              - religion
        - connection
          - moment
            - difference
              - direction
                - inspiration
      - functions
        - deciding
        - persecuting
      - objects
        - ethical system
        - understanding
        - definitions
        - fallacies
        - arguments
'''