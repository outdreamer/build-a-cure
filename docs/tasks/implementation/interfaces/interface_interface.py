'''
  - definition: 
      - the abstract interface network optionally includes layers of network filters (intent, perspective, function (can optionally include patterns, logic, strategies, core functions, and any other set of operations/objects that has order), structure, concept, information (organization, formats, types, info objects like problems/questions/insights/assumptions), potential, change, cause system) 
      - it can refer to a specific interface set for a specific problem space 
        - the specific interface network for the debugging code space could be a structure containing filters like: dependencies, logic gaps/order/validity, side effects, types 
        - these specific interface networks are often implementations of the general interface network with mapped objects: 
          - dependency interface is a combination of the cause/function interface 
          - types (data, classes, etc) interface is a subset of the general type interface 
          - side effects are a subset of the variance interface (gaps in intent & execution, prediction of emergent attributes after nth iterations of combinations or other operations) 
        - like all other sets of objects on an equal interface, any item in the set can be used to find the others
        - in a set of (4, 6, 2, 3) you can start with 4 to find 2 or 3 to find 4

      - interface: attribute that highlights differences within a limit when objects are reduced to that attribute, using it as a standard for comparison, that filters out attributes that dont fit its definition
        - gaps in known rules allowing filter to be applied to objects that can occupy the gaps, to identify variance nodes
        - interfaces should produce a network when their variance is exhausted

      - can generate an interface by the combinations of variables that minimize & maximize change (filters to remove common information to leave differentiating information for comparison)

      - interfaces that capture change types: 
        - conceptual bases (power), intent bases (motion, increase, efficiency), type bases (number type, variable type), structural bases (value, position, distance, set), change bases (rate, possibility/opportunity difference, randomness ratio, change interface stack, change type)
      - if the interface network (position of power with respect to balance, interfaces like intent/concept/structure) is static, there is a limited supply of change/potential/power in the universe/system, and change should be allocated non-randomly (priorities matter)
      - if the interface network is not static (you can change the position of power with respect to balance, you can change base interfaces), then information should be standardized to a set of filtering interfaces, because the filters will host the most changes & changes to the filters will cause other changes
      - other embedded parameters than time: adjacent/probable/convergent/inevitable states/causes/patterns/interactions/changes/limits based on system position
      - some spaces have embedded concepts like core/unit and relevance, and others have embedded concepts like type & potential 
        (adjacence is assumed to indicate potential field in some spaces so its not explicitly represented)
      - whether to frame other bases as the independent or dependent variable in a pair:
        - you usually want to find the impact of a variable (change, position, value, distance) on the interface (potential, change), rather than the impact of the interface (potential) on a variable (distance), but either can be useful depending on needed intents (finding causal direction, emphasizing certain change types)
        - this is in a space where time has been removed, indicating potential - is one type of change capable of being transformed into another? then point a can be connected to point b on the x-axis
        - this is using potential as a proxy variable for embedded time, since if change is not possible, time cannot pass, so types of change or changes or change states that are causally linked & possible are adjacent, so changes in the x-axis indicate changes in type/state, but they may not be chronological, according to corresponding changes in time (if they dont change the set of possible events, time may not have passed, even if the change or change state or change type may have changed due to physics indicating probable transformations if left unattended or if some force is applied)
        - two adjacent change states may not be chronological in time, if a lot of time is required to offset the loss of potential represented by one change state turning into another, or it may be impossible to get from one change state to another despite adjacence in the change interface, given amounts of time still possible in a system with that change applied
        - one change state turning into another may require more time than can be injected, removal of time, reversal, or symmetry violation of time
        - in euclidean space where the y-axis represents position, adjacence represents possibility as well - indicating that an object has to traverse every point on a continuous path between two points in order to get there - the same cant be said for the change interface, where one point may not be able to get to another point no matter how many transformations are done
        - there may be symmetries and limits preventing certain changes from being possible, given a starting point/direction, so each point on the change interface has a set of possible starting points, and traversing the change interface often means a set of points rather than a continuous function, so the set of points needs to be converted to a space where they can be a continuous function to describe time-based change
        - when there's no more potential in a system, the system cant be represented based on potential or change, and collapses to a constant/measurable shape in 3-d irrespective of time, like an assumption core to 3-d space
        - order-independent processes can be modeled in other spaces (generative functions where it doesnt matter which function you start with bc each function can generate the others)
      - interfaces evolve when a unifying attribute (priority, cause, structure) can frame a set of developing variance 
      - interfaces, standards, & perspectives can all be formatted as filters 
        - an interface can be specific but on the general interface network, it offers a standard for multiple related attributes or causative attributes (types/intents/patterns offer a way to interact with all layers of a system), whereas a perspective is focused on a very restricted set of variables, with the intention of distorting reality to highlight information that other perspectives dont make clear.
      - each interface's definition has a specific: 
        - conversion (filter) function to convert input information to that interface (or a combination or other structure of interfaces), and convert retrieved/generated information back to the input format 
        - component traversal function (to execute after after conversion) 
        - a function (and corresponding data, like definitions or interface structures) to find/generate/derive the interface network from that interface, in case resources are isolated 
      - each interface may have related interface objects, like supported intents 
      - interface traversal & queries have supported intents such as: 
        - 'finding formats linking other formats' 
        - 'finding a structure for a concept' 
        - 'applying a function to a structure' 
        - 'match a problem in this format, with a solution (in a format that can interact with the problem)' 
        - 'optimize this system' 
        - 'find an optimal route between these system positions' 
        - 'find a cause of this variable' 
        - 'find an optimal structure for this information' 
        - 'design an interface query to convert input information into an output information type (like an insight, a cause, a new interface in data, problem-solving automation workflow)' 
        - 'assemble a meaningful (relevant) format of this information for this intent' 


  - attributes: 
    - generatability/common derivable core functions with other interfaces 
    - information loss 
    - variance focus (what variance is exaggerated for comparison by this interface) 
    - position of interface on default interface network (what distortions produce this filter/perspective from unfiltered origin) 
  
  - objects:
    - interface
    - interface operation (combine interfaces, etc)
    - interface traversal (apply an interface to a problem)
    - interface query (cross multiple interfaces in a sequence)
    - workflow (apply a problem-solving automation workflow with a particular origin interface or interface query)
      - an example of a workflow is shown in FIG 14 (Problem-solving automation workflow)
      - the general workflow of this program is shown in FIG 2 (Solution Automation Module 140)
    - workflow operation (select a problem-solving automation workflow)
    - symmetry: change types that dont lose information, so can be used to define the boundaries of an interface or used as a base

        - symmetry => interface
          - a limit on change provides a standard for comparison
          - example: 
            - given that a circle is symmetric in every axis that crosses its center, you can compare one side of the axis and expect the other side to reflect that, using one side as a standard for comparison
            - the symmetry is produced by the filter of the set of axes crossing the center, because the center is the key identifying & generative attribute of the object type (radiating outward from center or rotating radius line, holding one point at center - generates the circle shape and can be used as an identifier)
          - this includes object definitions like common shape definitions 
            (transforms that maintain the object type can be considered symmetries to explore change within the object without removing its standards for comparison)
          - therefore key identifying/generative attributes of an object can be used as symmetries 
            - example: core functions, priorities, types
        
        - symmetry implies reversibility, so when a natural process is asymmetrical that implies its leaving the range of reversibility, which may mean leaving a space or an interface
          - is time the unit base of change or is it an interim base between variance and potential?
        - symmetry: "feature of the system that is preserved under some transformation" (as opposed to lost information/irreversible transform) - https://en.wikipedia.org/wiki/Symmetry_(physics)
          - a sphere is symmetric with respect to the origin when a rotation transform is applied, producing attributes for comparison (spin, momentum, speed, direction) while others are held constant (origin on axis of rotation)
          - this is an example of standardizing an object (sphere) to the variance or interaction interface (leaked energy of an object, which also leads to interactions with other objects)
        
        - symmetries as a base for change, or as a boundary to define limits of a change type without losing information (staying on the interface)
          - symmetries as a source of misclassification error and efficient/cooperative/optimal attributes
            - symmetry as a source of limits to restrict variance with
            - the limits can be common attributes/intents, around which variance develops
              - separation/delegation symmetry
              - retaining backup alternatives
              - organization
              - abstraction 
              - uniqueness 
            - symmetries are also where to look for key differentiating factors
              - the range allowed by a symmetry exists for a reason - to explore possible utility of variance in that range 
            - symmetry types:
              - functional symmetry: only restricted to find an optimal value, after which it's set to that value (tail shape) or the variance is reduced (remove tails with new design)
              - random symmetry: insignificant except in that it displays common patterns or efficiencies (independent evolution of intelligence across diverging species)
              - interface symmetry: allows enough variance that it continues attracting compounding variance (mammal interface, brain interface)
            
            - some symmetry types should be removed from data set bc they dont add variance but allow it to develop
            - you can also calculate the variance types to look for given the structure of a symmetry network
              - given symmetries powering an interface, predict which variable types to look for that could develop in that structure, then try to identify which phase of interface development its at
                - "given uniqueness and functional symmetries powering the identity interface, predict which variables to look for that could develop, then identify phase of development"
                  
                  - given that you need certain features in order to exist (a way to breathe, a way to sense, a way to communicate, a way to identify other people),
                    predict which variables are likely to vary in the human interface, then identify phase of development
                    - within the scope of features that can vary without impacting required survival functionality, senses for example can vary while still performing communication functions and are likely to vary to introduce testing of utility in different values, so senses are likely to vary
                    - predict which phase of evolution the human interface is at: given the level of variance & optimization achieved on the human interface as well as variance trends, the human interface is likely reaching another explosion of evolution, given how much optimization potential has already been exploited in its existing interfaces (organ differentiation, sense optimization, neuron automation)
                  
                  - so in order to identify one human from another, look for sense variance (facial identification) as well as variance in the interfaces powering existing variance (organ differentiation, sense optimization, neuron automation, etc) when that expected variance occurs (may take the form of variance on other interfaces with less variance (like cellular structure variance, cellular communication variance, gene repair variance) but are likely to be connected by a functionality interface (reusing/sharing/finding functionality) as an identifying feature of the human interface, which now is struggling to be identified compared to its automatons, so efficiencies in processing are the next likely variance-hosting interface, if humans have to compete with machines for identity for example
            - you can also identify symmetry paths mapping to variance levels
              - in the example of muffin vs. chihuahua, the symmetry paths of a muffin:
                - common shape (humans gravitate toward simple common shapes so theyre likelier to create tools mimicking these shapes)
                - distribution (humans can understand concepts like optimization, and one implementation of optimization in the muffin interface is distribution of differentiating components)
                - humans have sensory preferences in common (texture, flavor), as some flavors are still useful indicators of healthy food (how dogs crave grass & other things when they're sick)
                  so sensory attributes like texture & flavor are likely to converge for food intended as comfort food
              - lead to different variance levels than the symmetry paths of a chihuahua
                - distribution (dogs' sensory organs are distributed)
                - communication (dogs sensory organs need to communicate with each other (the mouth can detect if the nose is ok, the nose can detect if the eyes are ok, the ears can tell the eyes if dangerous fists are imminent)
                - backup alternatives (some organs' functions are so important you need a backup - eyes, kidneys, ears, mouth/nose as a possible airway, lungs)
                - uniqueness (domesticated dogs are treated like humans with identities, and sensory organs are likely to produce potentially identifying uniqueness due to the lack of functionality present in some sensory variance)
                - functional variance (some dog sensory organ configurations have utility value)
              - so you can expect variance in the chihuahua that the false chihuahua cannot provide
                - the chihuahua may vary in ways that a muffin cant given their symmetry paths
                - the chihuahua will vary along its facial interface (two eyes, mouth, nose) but the muffin distribution of components will be more random, for texture/flavor optimization
                - the symmetries making it unclear which is which include:
                  - size (chihuahua face and muffin are often the same size)
                  - the fact that visually measurable ingredients are often used in muffins (chocolate chip) and happen to mimic color scheme
                  - the fact that there are only so many positions a chocolate chip can take, given its size, 
                  - the fact that the baker will optimize the distribution metric with pretty good accuracy most of the time, meaning its likely to mimic a chihuahua face
                - these symmetries can be used as points for variable reduction (ignore size, ignore color scheme, etc)
                - the routes to these symmetries are insignificant in terms of the identity interface
              - the ways that significant symmetry paths vary can determine possible classification errors
                - chihuahua eyes can be shiny in different light environments
                - muffins may be coated with sugar, which may mimic the attribute 'shiny' used as a way to differentiate between muffin/chihuahua
                - this is a false symmetry, not indicating variance around a common interface, but can still be incorrectly identified as a legitimate symmetry (similarity in shininess means similar class)
              - these provide a point of variance reduction
                - shininess is not significant given that a distortion of an attribute in one class can mimic the naturally developed, identifying attribute in another class, so remove shininess from data set
              
              - therefore given the set of attribute values that can mimic each other, the insignificant symmetries, and the variable potentials left by the differences between significant symmetry paths, you can calculate which variables in a problem space will be capable of having predictive value
                - after removing false mimicking symmetries like shininess, insignificant symmetries like color schema, common symmetries like distribution, you have a limited set of differentiating features left:
                  - muffin chocolate chips wont have tear ducts
                  - chihuahua eyes wont have chocolate chip texture
                - therefore if you determine that your data set supports the level of detail required for these remaining attributes, you can use them as a predictor
              - given that a classification problem usually gets more difficult in time, you can also predict ways it will change to reduce the differentiating variables
                - they may start using candy that looks more like chihuahua eyes
                - they may start messing with the data set to lure the model into a false sense of security (using raisins which are easier to differentiate) so the actual data is more difficult to differentiate (chocolate chips)
                - this is a problem of identifying intent to misclassify, which means predicting symmetries in other objects that can be used to trick the algorithm into creating an inaccurate model
                - if an evil person wants to fool a movie theatre security ai into believing they are bringing their dog to the movie and not an evil reasonably-priced or homemade snack, there are many ways they can do so, but these ways are predictable & involve insignificant symmetries between classes (similar color, similar shape type)
                - how do you make your algorithm robust against these evil tricksters?
                  - you need to be able to identify insignificant symmetries & distortion functions that can exploit them
          
          - Symmetry evolution & stacking in progressions of systems
                - as you add equivalently long lines to the system of 'connect these lines at their ends', you can see the evolution of symmetries that can generate the system
                  - it starts with creating objects on the explicit system interface (use the 'line' object and the 'angle' object to create shapes connected at line ends)
                  - then it adds more interfaces from which the shape can be generated, as the number of lines variable increases
                  - as properties emerge in shapes as the progression continues (such as rotation, prior object interface patterns, corner/angle behavior, emerging circle shape as number of lines increases), other interfaces develop, not just on the structural level but other levels
                - the triangle is the first closed shape in the progression of that system, and you can see the symmetry between each corner and the line split by equivalent angles to the other side,
                  making three symmetries total (in raw structural symmetries, not counting attribute/rule/change symmetries) 
                  - with two connected lines, at a 60 degree angle, you can generate the triangle by duplicating & rotating to connect the duplicate with the other lines to create a 3-sided object
                  - the triangle is the first object to have a 'center point' or 'origin' object 
                  - the triangle is self-similar (can be used to generate other versions of itself - building triangles out of triangles)
                  - the triangle, having the center point object, is also the first object that can be generated with the rotation symmetry:
                    - given the center point object and the rotation function, the triangle can be generated by positioning three lines at equal angles from the center point, where the lines will lead to the corners, which can be connected
                - the square has more symmetries than the triangle (not just from corners to opposite corner but side mid-points to opposite side-midpoints) bc of the increase in number of sides, which allows for a corner-to-corner symmetry that the triangle cannot allow given its lack of opposite sides (two corners cant be connected by a shape-crossing line because each line connecting two corners in a triangle is just the side), making four raw structural symmetries total
                  - the square can be generated on the triangle interface (four small triangle building a square, one large triangle with a square inside, etc)
                  - the square can be generated on the circle interface (using four lines to create a square using a circle as a base)
                  - with two connected lines (at a right angle) you can generate the square
                - the pentagon has more symmetries than the square because it can be generated with more shapes
                  - the opposite corner-midpoint symmetry exists in the pentagon but also the rotation symmetry
                  - with symmetry in angles, you can generate the pentagon from the origin center point & a rotation transform
                  - with two connected lines, you can generate the whole five-sided pentagon
                  - with transforms on the triangle interface, you can also generate the pentagon
                  - so the pentagon can be generated by prior interfaces (triangle, square, line), sub objects (corners, angles, center points) & combinations of them (square plus triangle)
                  - you can also generate the pentagon with combinations of prior interfaces & variance interface (square plus opening/expansion of system)
                  - shapes generatable with rotation interface & capable of evolving a rotation function trend toward the property of smoothness & curvature, which lead to circle, which is the best rotation shape
                  - this implies some attributes like rotation are inherently compounding & cascading throughout a system, just like efficiency can be compounding
                - because of the emerging combination/rotation symmetries, other symmetries emerge:
                  - variance interface 
                    - permuting the line variable is one way to inject variance, but only using a permutation of an explicit variable
                    - you can also inject variance by removing/transforming one sub-object (like a side/corner/angle) into another version
                      (opening the square by removing one side allows for two lines to replace the removed side if the other sides' angles are expanded)
                  - efficiency interface
                    - if two lines carry more functionality than one (like hitting more nodes), the injection of two lines in place of one can produce efficiencies
                - so you can see how these interfaces stack:
                  - structural: explicit variables (lines), implicit objects (corners)
                  - emergent: rotation, combination
                  - abstract: variance, efficiency
                - the interface stack can be rearranged to optimize relationships when generating objects
                


  - structures:
    - interface filter
    - interface network: the set of networks that act as useful filters/standards for applying structure to organize information 
    - interface stack:
      - example interface stack
        - it might seem there are just two dimensions to the chaotic-neutral-lawful good vs. evil matrix:
          - degree of order (chaotic -> neutral -> lawful)
          - degree of evil (good -> neutral -> evil)
          - but this matrix can actually be generated by one dimension, applied to a topic:
            - dimension: extreme - middle - opposite extreme
            - dimension: maximum - balance - zero/minimum
            - topic: ethics, order
          - if you apply either of the dimensions above as one axis, and then add another copy of the dimension but applied to the topic of 'ethics' & the topic of 'order' to create a transformed dimension 'ethical degree', youve generated this matrix using one interface (a general spectrum interface) & one topic (ethics)
          - therefore you have an interface stack inherent to this structure because of their symmetries: 
            foundation: spectrum interface
            application on top of foundation: ethical interface
            extra application on top of application: order interface
          - you can also use order or ethics as the base dimension and create the other by applying one to the other topic:
            - dimension: ethical spectrum
            - dimension order spectrum
            - topic: ethics, order
            - apply order to ethical spectrum: 
              - raw application (alignment): order aligns with good
              - semantic application (context): 'order' in the context of an ethical spectrum aligns with good
            - apply ethics to order spectrum: 
              - raw application (alignment): good aligns with order
              - semantic application (context): 'good' in the context of an order spectrum means 'orderly'
          - not every interface will be so clearly mappable & applicable to another interface - these two interfaces have symmetries because theyre built on the same foundation interface
          - you'll notice there are variations in optimality when applying these dimensions:
            - sometimes chaos aligns with good, and sometimes order aligns with evil - not the usual way we typically see those concepts portrayed - usually we see them portrayed in the opposite alignments, with chaos being evil and order being good
            - but when laws are bad, chaos is good - there is no absolute virtue in chaos or order, just like there's no absolute rule that stays constant when its overloaded with falsehoods like false assumptions
          - those arent the only symmetries in this two-dimensional matrix, given the topics at hand
            - for example, according to these definitions, the neutral evil & chaotic good have a similarity in behavior
              - the neutral evil person will act in their own interest bc of selfishness
              - the chaotic good person will act in their own interest if they think its right, and if they think it will produce other good things or enable other good deeds
              - they act for different reasons (selfishness & ethics) which parse to the same intent (selfish behavior)

  - related objects
    
    - priorities
      - prioritized distortion functions relevant for structure-matching on the interface
      - prioritized interfaces & interface objects relevant for structure-matching on the interface

    - problems solved

      - finding explanatory variables on multiple interfaces 
      - building a problem-solving automation workflow 
      - selecting those optimal interfaces to solve a problem: framing a conflict of type 'competition' as opposing direction/intent or equivalent direction/intent is a calculation that can be automated using any of these kinds of analysis, but the logic & intent interfaces are best at this
      - finding explanatory variables on multiple interfaces (a trajectory on the interface network) & translating them to a shared interface where possible
      - determining position/trajectory within an interface
      - selecting interface as the best standard for comparison (identifying when a particular specific interface will reduce solution set across any possible host system)
      - generating specific interfaces (filters) for a problem/space
      - generating full set of general interfaces (intent, concept, structure)
        - these can be generated by identifying the key differentiating factors across systems, which can be generated as system structures (like combinations of objects - type is an attribute set, intent is a function effect set, concept is a network of networks describing a structural concept (balance, power), structure is an information & rule set)
      - identifying all interfaces with variance that cant be captured in other interfaces
      - calculating when to skip interim variables/interfaces
      - determining adjacent interfaces
      - building or selecting a problem-solving automation workflow (whether to start with a particular workflow, which is a layer of abstraction above the question of whether to start with a particular interface, which assumes a workflow has already been selected)

    - questions answered
      - how to find the metadata that is most useful in determining other information:
        - are core functions the best method to derive the system structure?
        - once you have system structure, can all the sub-components be derived? Can other systems be derived?
        - once you have the flow network indicating the derivation dependencies, you'll have a framework for deciding which metadata to use to solve which problem types
      - by navigating the certainty interface (angles, distance, order), can you derive the shape of the corresponding object in the uncertainty interface?
      - how do different layers of interaction objects emerge? 
        - why do collections of properties accrete into objects on one layer & other property collections gather on other layers? 
        - do mostly objects with similar types, functions, attributes, attribute values, or complexity interact?
        - how do objects of very different types (an attribute & an object) usually interact in systems, or do they not have behaviors defined outside of similarly typed object interactions?
          example: does a cat respond to teeth (attribute) the same way in any object, or only when attached to certain objects, like a dog, or when it has a certain value (sharpness: high)
      - what happens when a system or space is exhausted and all combinations & interactions have been defined? 
        - does the interface of variance freeze/stabilize into a network
        - does its remaining variance gather on other interfaces/layers? 
        - discuss how sub-interfaces can collapse into a super interface (change interfaces) as the default shape of interfaces can be shapes other than networks
      - sub-interface interactions:
        - is it better to standardize to object interface, variable interface, type interface, or function interface?
      - what types of variables can be ignored even when theyre good indicators?
        - output rather than input variables (output is a good indicator even though input variable may be preferable)
        - variables less likely to change
      - what space are these symmetries derivable in? the spectrum interface is derivable from the chaotic evil matrix - what space makes these symmetries derivable?
      - why do some of the most useful interfaces have semantic values (context like identities of nodes, producing interfaces like priority, which is specific to non-random systems that can have intent)rather than structural values (type, pattern, change, structural)
      

    - examples
      - give example of framing variance with different interfaces to highlight predictive information or information that can be structured on other interfaces that simplify the problem
        - the common goal of 'variance reduction' which maps to 'applying a standard' may not always be the right first step, as 'variance expansion' can offer potential to identify different component interfaces that would highlight hidden variable set ranges
          - example: if you expand or maintain variance, or frame it as a combination of variances simultaneously framable in multiple standards, you can identify hidden variable gaps where variable sets on different interfaces can fill the gap in a way that doesnt disrupt the original variance
          - identify example where variance cant be reduced to a common interface but is still solvable with a set of interface positions/trajectories
      - give example of variance transforms
        - adding a new interface for variance to expand into
          - changing existing interface used as a filter to hold constant
          - adding new interactions to allow the expansion of new variance
        - moving variance into other interfaces to make the problem more solvable
          - rather than a species evolving into a new set of sub-species, host the variance in epigenetics rather than inherited mutations
      - example interface (emotion) within another interface (agent):
        - emotion functions involve:
          - information indexing
          - assigning cause
          - directing intent 
          - perspective/layer switching
        - emotions are used as a cause, a standard, and an output, allowing for variance injection due to current lack of measurability
        - they can capture sub-nets or trajectory nets on the interface network
      - give example of calculating which variable resolutions can be postponed & solved later with information acquired in subsequent analysis
      - give example of mix & match interface assembly given the problem of 'model identification'
      - example of finding an object on different interfaces, using its structures within that interface:
        - symmetric (efficiency & similarity) interfaces:
          - efficiencies can be found in: 
            - symmetries
              - can be the quickest way to determine relevant/causative variables
            - similarities
              - similarity of shape/position can be a quick way to classify or match
            - attribute alignments
              - alignments between attributes can cause similar systems or emergent rules/attributes, which can provide an interface for comparison or reusing solutions
            - aligned incentives (default rules without exerting force) & intents (structural/conceptual goals)
              - if transporting an object where there is a decrease in height along the trajectory, letting it fall at a rate that wont damage it to take advantage of the gravity incentive built-in that aligns with the intent of 'transportation'
            - an efficiency can be any side effect, assuming each output is potentially useful until proven otherwise, especially if the relationship occurs from system forces like stabilizing incentives rather than costing something to create
        - structural (adjacency & alignment) interfaces:
          - emergent attributes can be illusory & created by:
            - attribute alignments: 
              - example: direction of growth in similar direction by adjacent objects can create the illusion of an emergent border attribute

      - examples of primary interface layers & sub-interfaces
          - structural interface
            - dimension/attribute/variable/property
              - variables have symmetries with interfaces, since variables are a standard where change can occur within a limit
              - what shapes do attributes take with regard to an object?
                - can be an edge on the outside (output layer) emerging from internal rules (acidity, phenotype)
                - can be a circuit on which the object participates or circulates where current position has meaning (starting interface)
                - can be a set of vectors creating an output intent or a trajectory linking various networks where an attribute shows up (relevance)
                - can be a metadata attribute of intersecting rules (diagonal attribute in a square formed by perpendicular rules)
              - what shapes do attributes take with regard to a system?
            - position
            - distance measures
            - set of possible variable values
            - limit/metric/boundary
            - equivalence is on several interfaces (conceptual, change, & structural) and it ties to the other sub-interfaces of the structural interface, because position is a differentiating attribute that describes difference, so it depends on a definition of equivalence inherent to that space
            - similarity
            - symmetry
            - shape
            - information
            - variable sympathies (cooperation/antagonism/similarity between variables as a way to visualize difference between dimensions, on dimension network)
          
          - type
            - combination (combination of attributes)
          - priority
            - direction (intent direction)
          - rule: 
            - pattern
            - function
              - filter order (functions as an order of filters)
            - logic
          - change: 
            - variance
            - potential
            - attribute
          - conceptual: 
            - problem
            - communication concepts:
              - question: info asymmetry
            - abstraction (balance, power)
          - causal


    - concepts:  
      - perspective (default version of an interface, which implies a different method of calculation, priorities, & focus on different objects) 
    
    - core components

  - functions 
    - interface query functions 

    - interface traversal functions
      - function to find distortions to apply that would generate useful information (example: 'apply core/interaction layer/generative/causative/primary functions to input information') 
      - function to identify & find related objects of an interface 
      - function to apply a distortion function from an interface to input information 
    
    - interface-interface functions 
          - interface operations:
          - intent / structure interface: assess intent interface by a standard of structure interface (which structures can simplify the intent interface)
          - function + pattern interface: merge networks of functions & patterns into one standard interface definition (input/output/logic + metadata of both objects)
          - function * pattern interface: 
            function patterns (what patterns are there in functions), pattern functions (what functions generate patterns)
            function pattern functions (what functions generate function patterns), pattern function patterns (what patterns are there in functions that generate patterns)
          - cause * type interface: 
            causal type interface (what types of cause are there), type cause interface (what causes types)
            causal type cause (what causes causal types), type cause type (what types of type causes are there)
    
    - interface implementation functions

      - interface change function
        - interfaces will attract other attributes until a new interface is necessary to capture extra attributes, acting like centers

      - function to determine intents supported by an interface (apply intent interface to find matching intents)

      - function to find mismatches between interfaces
        - answer questions like: 
          - is there a gap in describability that means the math interface cannot be standardized or applied to another interface, which has information that cant be described by the math interface?
          - what do these mismatches indicate in terms of a causal relationship between interfaces - is the information description interface causative, generated by, or in another causal structure with the information interfaces & their causes?
      
      - interaction level identification function
        - interaction level is determined by which objects are marked as equals so they interact with each other, forming an interaction level/layer, such as the macromolecule layer or the pathogen layer

      - sub-interface identification function
        - identifying sub-interfaces (electricity, potential, similarity) is an important first step before doing other analysis, because if you can identify the important/causative interfaces right away, you can ignore a lot of information
    
      - function to detect patterns in queries & outputs to optimize queries & find insight paths to improve response time
        - example: 3-step jumps with direction change, navigating across a certain pathway in standard structures across interfaces, starting with system then cause & intent, etc
        - this has to identify & remove unnecessary steps that dont change the output
        - identify & replace with faster ways to get to the output without changing the output
        - test cases to determine if output would be changed by removing a step and/or replacing it with another step

      - function to map between core & important objects
        - example of choosing inefficiencies/exploit combinations in a system
        - function to find common emergent combinations of core components (include derivation of invalidating contexts for core functions)
        - function to find decision metrics (bias towards more measurable/different metrics rather than the right metric)
        - function to find key questions to filter objects (like attention/info-gathering/solution) to counteract biases, counterintuitive change types, & other objects that create inefficiencies in problem-solving
      
      - interface selection function: 
        - applying structures like sequence/combination to select which interfaces to use first when describing each primary interface, to produce the formatted & filtered information likeliest to be useful in the most situations to produce the default interface network)
        - how many degrees away from core functions, specific layers or sub-systems, what position on causal structures
        - choosing bio interfaces including electricity as components with a common language on an interface
        - format selection: 
          - selecting filter vs. rule as a structural conflict in the form of a trade-off
          - framing filters as positions
          - framing common problems with the standard of variance vs. time (recurrent nn)
        - import rules for selecting interfaces to solve a problem on
          - determine minimum information
          - query for rules making inferences from available information sets
          - Function interface helps find unused functions
          - Intent interface helps predict system priorities & find exploit opportunities
          - System interface helps find efficiencies
          - Pattern interface helps find insight paths/similarities

      - function to calculate the interface query (set & order of filters/interfaces/standards to use to solve a particular problem)
        - 'deriving core functions' can be converted to a set of filters in a particular order, just like a normal finding problem can
        - calculating the set of generative/expanding dimensions or reductive/standardizing filters to use is more valuable than writing the function manually
        - can dimensions act as filters or vice versa? dimensions can capture & highlight information differences, whereas filters can remove information similarities & highlight differences
        - how would expanding dimensions enable deriving a set of core functions in a system?
        - derivation rule examples:
          - start with common core functions across systems
          - apply common dimensions of distortion to expand core function set
        - filter rule examples:
          - replace concrete rules with type versions
          - reduce rules by similarity across attributes that are typical parameters of common core functions
      - algorithm to decide when to use interface query, when to standardize to a particular interface, and when to stack interfaces to isolate variance by applying one interface to another
        - example: analyzing priority direction once you standardize to variance interface
      - algorithm to decide when its time to retire an interface:
        - when the exploit, optimization, & variance opportunities have been exhausted using all possible combinations of components & core functions, so that the interface has fulfilled its potential usage
        - if there is external system variance, another interface may develop to host the remaining variance

      - interface compression function:
        - interfaces may devolve to their abstract forms once a particular implementation is fulfilled (once the interface definition is complete and cannot host additional change)
          - type :: combination (combination of attributes)
          - priority :: direction (intent direction)
          - function :: filter order (functions as an order of filters)
          - etc for the other interfaces - which have sub-interfaces created with transforms of the original interface:
            - rule: pattern, function
            - change: change sub-interfaces like variance/potential/attribute interface
            - conceptual: problem, question, perspective, abstraction
            - structural: symmetry, shape, similarity, information, limit, metric, boundary, filter
        - do these transforms have patterns in common?
        - the combination, direction & filter order interfaces hold more variance than their specific implementations in the semantic interface nexus
        - this implies there are other interface nexuses using those core interfaces
        - given that the core functions of a space map to the core interfaces, the space can determine this core interface nexus 
          - derive the core functions in a space and you'll have the original interface nexus to start from
        - another example implementation of the core interface nexus:
          - combination :: network, set, cluster, dimensions
          - direction :: potential
          - filter order :: structure (filter orders map to structures that capture variance potential)
        - examine mixed interfaces: interfaces applied on top of interfaces in various combinations to create a topology of applied filters
        - sometimes interfaces should be applied at intervals, so variance can develop in between & adjust interface order & identity as needed
        - embedding layers like parameterization have relevance for choosing interface cycle origin points
        - how would you derive core functions which map to core shapes (combine, direction) from this space?
          - this space allows:
            - freedom to interact (there's room to select between equal alternative rules, all rules are not enforced)
            - freedom to fail (interactions don't have to benefit all entities involved)
            - freedom to calculate (you can check & verify information)
            - limits on calculation (you can know some things at cost of not knowing other things)
            - limits on variance (some rules are enforced but change or assumptions can be concentrated on specific rules to change them or change their enforcement)
            - limits on structure (you can cooperate to create structure but it will decay according to system rules)
            - limits on direction (not all decisions are reversible, and some decisions limit future decision potentials)
          - can you derive the core functions/shapes (combine, direction, filter, position) from those opportunities & limits?
            - filter maps to calculation - when you calculate something, you're reducing your consumption of other information
            - interaction allows for combination
            - interaction allows for direction (choosing a path between equal alternatives)
            - freedoms allow for randomness, which leaves room for variance
          - these freedoms & limits can be framed as a set of filters (rules) which generate the core functions/shapes, which can be used to generates various interface networks, including a key generative interface like concepts
          - freedoms can be framed as gaps in limits, so the limits would represent the interface or network structure
          - there may be an optimal interface network, but allowing them to compete could be the optimal filter
          - what shape do these limits restrict? what filter is applied to another interface to leave these limits remaining, that allow core functions like combine to thrive?
            1. this could be a meta interface (the interface interface, the limit interface) but that leaves the question of the source interface open rather than resolving it
            2. there might not be a calculatable answer (the source is not measurable inside the space) or it's a cyclical answer, where other interfaces generate other interfaces
            - interfaces overlap & influence each other: structural limits form rules, which are classifiable on the function interface, as well as the type interface, structure maps to core functions, concepts map to structure
            - so the network of rules linking interfaces for a particular core interface nexus implementation may be significant, not just as a generator of the nexus but as the primary interface for variance to develop on
            - and the network of these networks may give informtion about the answer to 2
          - standard nn structure has unidirectional causal support 
          - the collapse of sub-networks into a feature on a network with nodes to classify has patterns
          - the transformation of a classification network (containing nodes representing species) into a set of causally connected networks (containing nodes represent symmetries, types, patterns, functions)
            can be done if the data set contains a minimum of information needed to derive variance potentials, symmetry paths, type hierarchies, etc
          - the physics of attribute accretion into types can also be used to derive the set of networks building a classification network
          - if you have x variables on one interface and y variables on another interface, you can derive the network set to build a classification model for the classification network
          - the standard nn supports accreting attributes into types
          - it should also be able to support removing attributes to reveal differentiating factors that are not mimickable with distortion functions or random symmetries possible in the mimicking class
          - distortion functions are the first line of attack in reducing the set of identifying factors
        - what about networks with multidirectional causal support?
          - for example:
            - a classification problem that impacts the classification potential
            - an assumption set that changes the type evolution
            - a type structure that determines the attributes that can accrete in it, rather than only the attributes determining the type
              - example: given that a type has a set of symmetries around which variance accretes up to a limit, which attribute types are possible & which attribute probabilities occur given the level of variance allowed by the initial attribute set?
                - given that a level of variance occurs, what is the likelihood that a backup alternative variable will evolve?
                - "given that a particular sense is inherently limited but the demand for senses is not, what is the likelihood that an alternate way of sensing will evolve"
            - other layers of cause can occur before the type influences the attribute set - like a type that influences filters/symmetries that generate attributes
            - the relationship between attributes & types is multi-directional in cause, not to mention other relationships between interfaces
            - where is the potential for feedback from types-to-attributes in the network structure?
          - a species is overloaded with variance the more its compared to another mimicking species, or the mimicking species adopts variance to become a better mimicker
          - as attributes stabilize into types, its likelier that more interfaces of variance will develop that are not captured by those attributes
          - the relationship between the type/pattern/priority interfaces & variance-capturing variables is not unidirectional (one network builds the other, not the other way around or both)
          - however this network structure can often be used to capture the collapse of attribute sets into types, because types are by definition a collection of attributes, unless:
            - those types are in a state of convergence/divergence that isnt captured by the data or algorithm
            - some attributes have an insignificant symmetry with the identifying attributes (illusory correlation)
            - some attribute variance isnt captured by data set (chihuahua that has been in battle and lost some of its identifying attributes)
          - also there is a trajectory on the interface network that can build the identifying variable set (variance remaining after reduction by distortion functions & other insignificant symmetry types)
            which can take the form of a specific interface built for that problem type (filter out attributes that dont differentiate between these classes, leaving the differentiating attributes for comparison)
            this is what is called the prediction model/function, but usually its built from raw attributes than alternate interface attributes, which may be derivable from a data set that cant capture full identifying variance
          - an interface-building query for a problem type, integrated with a network algorithm, can therefore be a faster approach than using an information filtering network on its own
            similar to standardizing problems to optimal transport problems (how do you get to the target information state given initial information)
          - there may be interim interfaces that are more useful than raw data to determine a collapsed interface
            rather than using feature data to determine type, use feature pattern & feature evolution pattern data to determine type & type state
          - there may also be interfaces that allow variance in likelier patterns than another interface
            rather than using the priority or pattern or type interface, the function interface may capture more variance if the classes being identified are in a state of change

  - visuals
    FIG. 20. 'Interface conversion & matching' illustrates an example of selecting an interface to traverse. 
    FIG. 21. 'Interface & traversal diagram' illustrates an example of a diagram indicating an example interface, & a diagram indicating which interfaces to traverse in what sequence (forming an interface query). 

'''