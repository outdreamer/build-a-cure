'''
  - definition: 
      - the abstract interface network optionally includes layers of network filters (intent, perspective, function (can optionally include patterns, logic, strategies, core functions, and any other set of operations/objects that has order), structure, concept, information (organization, formats, types, info objects like problems/questions/insights/assumptions), potential, change, cause system) 
      - it can refer to a specific interface set for a specific problem space 
        - the specific interface network for the debugging code space could be a structure containing filters like: dependencies, logic gaps/order/validity, side effects, types 
        - these specific interface networks are often implementations of the general interface network with mapped objects: 
          - dependency interface is a combination of the cause/function interface 
          - types (data, classes, etc) interface is a subset of the general type interface 
          - side effects are a subset of the variance interface (gaps in intent & execution, prediction of emergent attributes after nth iterations of combinations or other operations) 
        - like all other sets of objects on an equal interface, any item in the set can be used to find the others
        - in a set of (4, 6, 2, 3) you can start with 4 to find 2 or 3 to find 4

      - interfaces that capture change types: conceptual bases (power), intent bases (motion, increase, efficiency), type bases (number type, variable type), structural bases (value, position, distance, set), change bases (rate, possibility/opportunity difference, randomness ratio, change interface stack, change type)
      - if the interface network (position of power with respect to balance, interfaces like intent/concept/structure) is static, there is a limited supply of change/potential/power in the universe/system, and change should be allocated non-randomly (priorities matter)
      - if the interface network is not static (you can change the position of power with respect to balance, you can change base interfaces), then information should be standardized to a set of filtering interfaces, because the filters will host the most changes & changes to the filters will cause other changes
      - other embedded parameters than time: adjacent/probable/convergent/inevitable states/causes/patterns/interactions/changes/limits based on system position
      - some spaces have embedded concepts like core/unit and relevance, and others have embedded concepts like type & potential 
        (adjacence is assumed to indicate potential field in some spaces so its not explicitly represented)
      - whether to frame other bases as the independent or dependent variable in a pair:
        - you usually want to find the impact of a variable (change, position, value, distance) on the interface (potential, change), rather than the impact of the interface (potential) on a variable (distance), but either can be useful depending on needed intents (finding causal direction, emphasizing certain change types)
        - this is in a space where time has been removed, indicating potential - is one type of change capable of being transformed into another? then point a can be connected to point b on the x-axis
        - this is using potential as a proxy variable for embedded time, since if change is not possible, time cannot pass, so types of change or changes or change states that are causally linked & possible are adjacent, so changes in the x-axis indicate changes in type/state, but they may not be chronological, according to corresponding changes in time (if they dont change the set of possible events, time may not have passed, even if the change or change state or change type may have changed due to physics indicating probable transformations if left unattended or if some force is applied)
        - two adjacent change states may not be chronological in time, if a lot of time is required to offset the loss of potential represented by one change state turning into another, or it may be impossible to get from one change state to another despite adjacence in the change interface, given amounts of time still possible in a system with that change applied
        - one change state turning into another may require more time than can be injected, removal of time, reversal, or symmetry violation of time
        - in euclidean space where the y-axis represents position, adjacence represents possibility as well - indicating that an object has to traverse every point on a continuous path between two points in order to get there - the same cant be said for the change interface, where one point may not be able to get to another point no matter how many transformations are done
        - there may be symmetries and limits preventing certain changes from being possible, given a starting point/direction, so each point on the change interface has a set of possible starting points, and traversing the change interface often means a set of points rather than a continuous function, so the set of points needs to be converted to a space where they can be a continuous function to describe time-based change
        - when there's no more potential in a system, the system cant be represented based on potential or change, and collapses to a constant/measurable shape in 3-d irrespective of time, like an assumption core to 3-d space
        - order-independent processes can be modeled in other spaces (generative functions where it doesnt matter which function you start with bc each function can generate the others)
    
  - attributes: 
    - generatability/common derivable core functions with other interfaces 
    - information loss 
    - variance focus (what variance is exaggerated for comparison by this interface) 
    - position of interface on default interface network (what distortions produce this filter/perspective from unfiltered origin) 
  
  - objects:
    - interface
    - interface operation (combine interfaces, etc)
    - interface traversal (apply an interface to a problem)
    - interface query (cross multiple interfaces in a sequence)
    - workflow (apply a problem-solving automation workflow with a particular origin interface or interface query)
      - an example of a workflow is shown in FIG 14 (Problem-solving automation workflow)
      - the general workflow of this program is shown in FIG 2 (Solution Automation Module 140)
    - workflow operation (select a problem-solving automation workflow)

  - structures:
    - interface filter
    - interface network: the set of networks that act as useful filters/standards for applying structure to organize information 

  - related objects
    
    - priorities
      - prioritized distortion functions relevant for structure-matching on the interface
      - prioritized interfaces & interface objects relevant for structure-matching on the interface

    - problems solved

      - finding explanatory variables on multiple interfaces 
      - building a problem-solving automation workflow 
      - selecting those optimal interfaces to solve a problem: framing a conflict of type 'competition' as opposing direction/intent or equivalent direction/intent is a calculation that can be automated using any of these kinds of analysis, but the logic & intent interfaces are best at this
      - finding explanatory variables on multiple interfaces (a trajectory on the interface network) & translating them to a shared interface where possible
      - determining position/trajectory within an interface
      - selecting interface as the best standard for comparison (identifying when a particular specific interface will reduce solution set across any possible host system)
      - generating specific interfaces (filters) for a problem/space
      - generating full set of general interfaces (intent, concept, structure)
        - these can be generated by identifying the key differentiating factors across systems, which can be generated as system structures (like combinations of objects - type is an attribute set, intent is a function effect set, concept is a network of networks describing a structural concept (balance, power), structure is an information & rule set)
      - identifying all interfaces with variance that cant be captured in other interfaces
      - calculating when to skip interim variables/interfaces
      - determining adjacent interfaces
      - building or selecting a problem-solving automation workflow (whether to start with a particular workflow, which is a layer of abstraction above the question of whether to start with a particular interface, which assumes a workflow has already been selected)

    - questions answered
      - how to find the metadata that is most useful in determining other information:
        - are core functions the best method to derive the system structure?
        - once you have system structure, can all the sub-components be derived? Can other systems be derived?
        - once you have the flow network indicating the derivation dependencies, you'll have a framework for deciding which metadata to use to solve which problem types

    - concepts:  
      - perspective (default version of an interface, which implies a different method of calculation, priorities, & focus on different objects) 
    
    - core components

  - functions 
    - interface query functions 
    - interface traversal functions
      - function to find distortions to apply that would generate useful information (example: 'apply core/interaction layer/generative/causative/primary functions to input information') 
      - function to identify & find related objects of an interface 
      - function to apply a distortion function from an interface to input information 
    - interface-interface functions 
          - interface operations:
          - intent / structure interface: assess intent interface by a standard of structure interface (which structures can simplify the intent interface)
          - function + pattern interface: merge networks of functions & patterns into one standard interface definition (input/output/logic + metadata of both objects)
          - function * pattern interface: 
            function patterns (what patterns are there in functions), pattern functions (what functions generate patterns)
            function pattern functions (what functions generate function patterns), pattern function patterns (what patterns are there in functions that generate patterns)
          - cause * type interface: 
            causal type interface (what types of cause are there), type cause interface (what causes types)
            causal type cause (what causes causal types), type cause type (what types of type causes are there)
    - interface implementation functions

  - visuals
    FIG. 20. 'Interface conversion & matching' illustrates an example of selecting an interface to traverse. 
    FIG. 21. 'Interface & traversal diagram' illustrates an example of a diagram indicating an example interface, & a diagram indicating which interfaces to traverse in what sequence (forming an interface query). 

'''