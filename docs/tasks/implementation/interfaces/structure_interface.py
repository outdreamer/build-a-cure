'''
  - definition: 
    - indexing objects by structure allows clear matching of useful structures to objects/attributes/types/rules 
    - this allows objects to be graphed in a standard way, which means translating objects like problems into a computable interface 
    - anything that has its own internal gravity can be modeled as a physics system, but if it has its own internal operations like how to traverse the interface network, it also has a description system which can be mapped to structure
    - involves assigning shapes/formats/structures/spaces
      - mapping a structure to an item (value, variable, object, type, system etc) requires an algorithm that:
        - matches variance with structure change potential

  - attributes (order, balance, equivalence, accuracy/fit, position) 
  - objects (comparison, combination, permutation, approximation, metric, activator, trade/cost/benefit, change, filter) 
  - concepts (equivalent, alternate, substitute, opposite, inverse) 

  - related objects

    - related questions

      - how to identify components with structural attributes like chainability (cause, risk, variance, errors, gaps, limits) or variability
      - how to identify a shape fitting information: chain/stack/network/mix/layer, adjacent shapes, or emergent info shapes like alignments/gaps/conflicts
          - will a type stack (which type values on different type layers) or a network/tree (type hierarchy) be a more useful structure to capture a type relationship
      - identify compression/conversion functions of a shape
      - this interface can also be used for specific attribute analysis, of properties that descend from concepts & take form in a specific problem space:
        - the power concept interface (has structures that look like trust, info, etc)
        - the balance concept interface (has structures that look like symmetry, justice, etc)
        
      - how to evaluate shape potential
        - given an object and the topology of its potential emergent interactions with each other object, what is the set of potential shapes that can interact with (build, coexist, coordinate, use, neutralize, destroy, or be built by) this object, given the full range of interaction topologies and combinations of the same?
        - example: 
          - given a molecule and the topologies of its interactions with other interactable molecules, what is the function generating the set of macromolecules that molecule can contribute to the assembly of in a way that enables a high ratio of component-substitutions or component-derivation from other components in the absence of one?
            - given the full set of these generating functions, which molecules/molecule combinations are the best contributors/collaborators/derivers/substiters/hubs?
          - given a variable and the topologies of its interactions with other interactable variables, what is the function generating the set of functions that variable can contribute to the assembly of in a way that enables a high ratio of variable-substitutions or variable-derivation from other variables in the absence of one?
            - this goes beyond indexing isolated variables by metadata (such as variable type), to incorporate the metadata of variable interactions embedded in a relationship

  - structures: 
    - dimension
    - layer: parameter determining variance accretion interfaces where interactions develop
    - space: dimension set
    - scale, range, spectrum
    - group: set, potentially across dimensions (cluster of data points)
    - position (point)
    - line: position link
    - sequence
    - center: possible in a shape with symmetries
    - vector: line with restricted metadata (direction & magnitude)
    - circuit: series of lines moving at angles that allow returning to origin point
    - network: linked points
    - tree: network with direction
    - stack: layers representing variables or variants within a type with values (trajectory between points in layers)
    - topology, manifold: permutation set with symmetric properties
    - distance: variance in a similarity measure
    - origin: starting point
    - point: value set of dimensions
    - angle: comparative measure of divergence between paths with same starting point
    - direction: output attribute from input origin given a space-traversal object (line)
    - boundary/edge/limit: extremes of resource combination generative potential
    - inflection: metric change limit (maxima/minima of rate of change)
    - intersection: conflict/overlap
    - tangent: line of least nonzero interactions with another line
    - ratio
    - connection
    - barrier
    - container
    - spiral 
    - curve
    - twist
    - overlap
    - knot
    - symmetry
    - scalar
    - path
    - expansion
    - progression
    - distribution
    - combination/contextual/conceptual structures:
      - unit (isolatable entity)
      - comparison (rate)
      - combination (group)
      - permutation
      - interface (common attribute or attribute set)
      - trigger
      - trade
      - variance
      - pattern
      - change
      - state (combination of structure & information)
      - filter/standard (reduce)
      - perspective (focus)
      - equivalent, alternate, substitute, opposite, inverse

  - functions: 
    - formatting (structure-application) function to describe an object in a structure/format
    - function to identify structures of objects
      - example: what concepts look like in data sets:
        - first identify sets of core bases/functions/assumptions/values that can generate variation seen in data set
        - then systematize sets
        - then identify trajectories in those set systems that can be identified as a unique concept according to your definition
    - identify components with structural attributes like chainability (cause, risk, variance, errors, gaps, limits) or variability 
    - identify a shape fitting information: chain/stack/network/mix/layer, adjacent shapes, or emergent info shapes like alignments/gaps/conflicts 
      - will a type stack (which type values on different type layers) or a network/tree (type hierarchy) be a more useful structure to capture a type relationship 
    - identify compression/conversion functions of a shape 
    - identify structures in objects: which objects are chained (cause, risk, variance, errors, gaps, limits), which are dimensions (isolatable attributes of change patterns), which have position 
    - find important structures (combinations/layers/matches/differences/sub-components) 
    - map structures (function sets) to target structures (sequences), given a metric like progression toward goal 
      - identify sub-components 
      - a function to convert an object between formats (function => attribute sequence, function => filter sequence, etc) by mapping attributes & functions & other metadata of the objects & removing attributes that don't fit in the target format definition (for example, if you're converting to a type, the output should be in an attribute set format)  
      - a function to identify structure matching a pattern (like identify a structure embodying a mismatch, which is a problem type, given a system network definition, where the system could represent an object, function, or attribute)  
    - structure identification functions 
      - identify shape: chain/stack/network/mix/layer 
      - identify adjacent shapes 
      - identify compression functions of shape given target dimensions 
      - identify transformation functions of shape given source/target shape 
      - identify alignments/symmetries/gaps/conflicts 
      - choosing between structures (like nodes & links) to model another structure (objects in a network): 
        - node: many connections to many other objects having a similar property, like having a type in common, usually unique 
        - links: usually many connections between two objects at a time, having many possible variations, can be repeated 
      - example of structural analysis by applying a particular structure: 
        - time analysis: as time increases, what changes: 
              - position 
              - value (position on a dimension) 
              - distance (position from a base point) 
          - changing position based on embedded time 
          - as change increases, what structures change (which structures are stable even in certain change rates) 
        - apply other standard structural bases as alternatives to time, where change is on a y-axis, and these parameters are on the x-axis 
          - order: changes are framed based on order - to examine change patterns with respect to order (where unit order is original/standard and highest order is most different order possible) 
          - position: changes are framed based on difference from previous position, starting from the standard unit position (default) - for examining change patterns with respect to position distortion 
          - distance: changes are framed based on distance type (distance from value, distance from number type, distance from pattern) - for examining change patterns with respect to distance type 
          - value: changes are framed based on value type (exponential, constant, pattern value, symmetric value, origin value) - for examining change patterns with respect to value 
          - set: changes are framed based on set membership (number type (prime), pattern (progression), distance (adjacent groups)) - for examining change patterns with respect to sets 
          - space: changes are framed based on spaces where that change can be framed (topologies, dimensions, vector spaces) - where spaces are formed by adding dimension units 
      - mapping a structure to an item (value, variable, object, type, system etc) requires an algorithm that: 
        - matches variance with structure change potential 
      - organization/format analysis 
          - optimal path/distribution/states 
          - what would the optimal path be, given a certain intent, object identity, & host system? 
          - "what is the function linking these variables that is most efficient/involves fewest variables/involves known constants?" 
          - identify layer to solve a problem at 
          - identify key objects needed to solve a problem 
          - identify structures for information 
      - example: 
        - market structure analysis
          - the market interface is a standard interface where resources (goods, labor, time, risk, information, expectations, theories, & stored prior labor (currency)) are traded
          - a useful new way to use this is to frame non-resource objects as resources (systems, structures, positions, paths, directions, risk chains, trade loops, markets)
          - then you can apply traditional market analysis (optimal transport) to find, for example, the optimal set of trades to change an industry's position
      - for a problem of type 'conflict', like vectors aiming at a corner of a closed shape (where the shape is formed by the intersections of limiting attributes), the structural way to solve that problem is:
        - reducing the angle of the corner 
          which reduces the difference between corners (and the incentive to aim for a corner) & adds extra alternatives
          - the solution is an example of 'false limit' - the limit of there being a finite supply of corners or the limit of one route occupying a position at a given time can be surmounted with extra resources
        - reducing incentive to aim at corners
          - if the shape has fewer corners, there will be less incentive for internal vectors to aim there
        - reducing motion
          - if the shape has a stable state, the motion of the internal vectors can be reduced or staggered at intervals for resource-distribution
        - adding motion
          - use types of motion to distribute the vectors so they aim at different corners
      - you could apply these methods of solving the structural problem to the original problem 
        (a conflict like competition or overflow or false limit or false alignment if the vectors dont need to aim for the same corner)
      - the way to assign 'conflict' problem type to the closed shape structure with internal vectors is by aligning attributes 
        (incentives that organize motion to create an oversupply of resources (motion vectors) that cant be supported by a resource (position))

- examples

  - give example of basic structure-intent map with db key-val structure used to store nested structures
    - intent of a key-value store is for lookups of info with unique keys in a map
    - lookups of nested values would otherwise have to be stored in rdbms or existing nesting-supporting formats like json, given that a 'nested' structures implies an intent to store relationships to associated objects
    - key structure can store strings - path in nested structure can be converted into a string
      - nested structures can add delimiters & type tags to resolve ambiguities like unnamed/unordered lists
      - by adding organization through type tags, info in nested structures can be stored in a map, with the intent of preventing information loss

      - structure intents
        - map: information organized by position
        - key: a string to find information at a position
        - string: a sequence (like a path in a nested structure)
        - concatenate: combine into a set with different dimension values (value count, delimiter count, position)
        - concatenated string: preserve order of list (like a list of path steps in a nested structure)
        - delimiter: differentiate within a set concatenated into a string or within a list/set
        - nested value: information associated with other information by position
        - nested structure: structure organizing information with non-intersecting (unique) sequences of steps

      - you can see how you can query for objects with intents that would link input (like a json object) with output (info indexed in a db) formats, given the intents using standardized terms above

  - structures of difference: chaining difference types (like randomness, core operations & definitions) across different component types like objects/variables are a quick way to identify new objects/systems to explain or fill rule gaps

  - identifying structures of randomness vs. false illusion of randomness (temporary equivalence)

  - variables can be represented better in other structures (probabilitistic networks/trees) than their original structures (spectrum representing full possible value range)

  - abstraction as a method to capture variation in the form of change/difference types

  - ratios of change across connecting structures like interaction layers/types as a way to predict error probabilities & locations
    - example: code change ratio vs. config change ratio vs. user event/workflow change ratio
    - when the dimension of change exceeds dimension of abstraction to handle change, errors will occur

  - add abstract keyword search support (find objects of an abstract type), like 'find all customers impacted by attack' will return results including all specific customer names in search result snippets
    - apply 'all' definition to return unique complete results
    - apply 'abstract' or 'specific' definition or identify an object type (customers) to list specific customer names

  - identify high-impact structures on an interface
    - causal loop: 
      - entities in a dependency loop where each supplies an input that the other needs (like a security product from a security product provider and a software resource product like a cloud server provider, where each product is not supplied by the other entity) offer an opportunity to take out both entities & their dependencies while conflating root cause & minimizing impact
    - meta cause: 
      - dependencies (like security/deployment tools of security provider) of the same type/level of dependencies for other entities (security provider product)
    - balance structures
      - a position with the most contradictions is the most balanced position
    - combination structures
      - a meta cause injected in a causal loop can cause cascading conflated outages where structure & source is difficult to determine
        - examples
          - disrupt deployment tool of a security product used for auth process
          - disrupt neutral abstract tool (update/deploy/networking) used by security provider
          - disrupt logging mechanism of a log search tool used by many companies for incident response
          - disrupt default trusted response (string returned from ip checking service that may be queried & accepted without validation)
          - disrupt trust root nodes like security providers & authorities
            - 'trust' being a conceptual definition of the concept of 'risk', and 'lack of input validation' being a structural definition
            - 'lack of required trust' having 'user risk-minimizing' structures like 'protecting/providing/cooperating with/lowering switching costs for alternative options' (no trustworthy provider requires exclusivity from demanders)
        - these structures can be used to identify the function nodes/positions/structures that would be highest-impact, to apply increased security in those function positions & their relevant structures (inputs/outputs)
    - high-impact functions
      - are permitted to access other high-impact functions

    - anomaly detection methods to identify differences have vulnerabilities in single-metric threshold structures that can capture one difference type
      - a threshold identifies aggregated resources crossing that threshold, but does not identify aggregations across different thresholds to build similar functionality from multiple sources
      - a combination structure of anomalies like an anomaly chain/network can escape detection using manipulation of multiple threshold-governed signals
      - example: monitoring just file modifications in isolation without monitoring file content modifications

    - malicious structures
      - have structures of variation like similarity ratio that follow patterns compared to legitimate variation structures
        - malicious structures will have structures of legitimacy (like a whitelist/blacklist) to mimic legitimate structures that have components to defend themselves against attack
          - however these structures of legitimacy used to signal similarity wont be implemented in the same way as legitimate components
          - legitimate components implement structures of legitimacy in ways like:
            - applying default config bc of budget constraints
            - not finishing configuration & making errors in configuration bc of budget constraints
          - malicious components implement structures of legitimacy in ways like:
            - applying config that is not enforced (has a whitelist file but doesnt import it anywhere)

  - examine structures of randomness
    - lack of information from:
      - position (cant access information)
      - adjacent information (cant derive information from adjacent information)
      - time (information was not generated yet or its generation is disincentivized or theres no structure that can contain/stabilize it)

  - identify 'relevance' mismatch structure in irrelevant components (interfaces like intent & structures like causal loop)
    - example: 
      - intent: when a default/required value is used, that may indicate the action was not intentional from the user position, and intent interface should not be used to capture variation in user changes
      - cause: when two events are often/always found occurring in a sequence, that doesnt necessarily indicate a cause
      - change: 
        - a static prediction function or data set contradicts the concept of 'generalizability' or 'robustness' which have the concept of 'change' as a dependency
      - meaning:
        - an 'isolated' function/data set (that does not have access to other functions/data sets as sources for an inference function) contradicts an integrated analysis of structures of meaning and structures allowing derivation of understanding

    - structures that dont match 'relevance' definition
      - these irrelevant structures contradict some component of the definition of the component, like where the default/required assumption doesnt offer/require a choice, which is an input to intent
    
    - to do: 
      - identify other important mismatches occurring in meaning/understanding and other fundamental attributes like similarity
      - document optimal filter & other structures (sequences, combinations)
        - filter sequences
          - "all combinations, then possible, then similar, then position" = find "missing components"
        - change type sequences
          - input: 'switch priorities' applies function 'find perspective with validation as lower priority' to generate output: 'reduce validation checks'

  - give examples of matching network structures & algorithmic traversal structures that are good at solving certain problem structures 

    - example of problem structure matching network architecture/algorithm:
      - function sets aggregated into a prediction function (one input set following one weight path through the network layers, representing one function set that could be the inputs to the prediction function), as a unit for comparing structures like combinations of function subsets/subcomponents/versions to fit the data
        - initialize with weights at a probable distorted position (like average + some wave frequency A & magnitude B to capture variation), then adjust with iterated network layer weights on the weight path toward a good approximation of the prediction function

    - problem structures
      - bounce between limits representing function versions, slowly correcting to similar line as regression line
      - bounce around a symmetry, finding distortion that matches data the best
      - combine common sub-function components or variables, slowly adjusting with common distortions to get to prediction function
      - find local points of slowing change (inflection points) given differences in change rates
      - find variables maximizing difference in difficult to determine (high similarity) cases for identification
      - aggregating isolated variables & other variable structures like generative/combination variables like nature does into a produced function
    
    - training an ai on these can match problem structure to solution architecture & algorithm structures
      - the network algorithm structure represents the solution automation workflow from problem format to solution format, implemented with a specific interface query
      - the network architecture structure represents the resources that can be traversed/combined (interfaces, definitions, functions, information, queries)

  - give example of how to select query among good alternatives (without priorities or other requirements/constraints) to solve a problem structure optimally:
    - applying structures of randomness, difference, and cause to generate structures of relevance
    - patterns of function sequences filling in gap between structures with known positions in a system
    - applying different problem formats
    - identifying sub-problems best solved on different interfaces & starting from a solution aggregation method to connect them 

  - give example tying solution automation workflows to specific queries & query metadata 
    - tie specific queries (content) to solution automation workflows (structure) that generate or apply them optimally
      - the solution automation workflows specifically connecting a problem to solution, and the queries connecting any interface objects

  - apply information organization methods as solution aggregation methods
    - solutions act as structures of organization/relevance in contrast to problem structures of randomness
    - information organizes itself according to various metrics like energy-sharing (efficiency) & energy ratios/stability (balance)
    - structures generating randomness can be used as a default data source for identifying problem causes
    
  - give example of how to identify a vertex interface like randomness out of all the interface structures like combinations & subsets
    - definition: equal probability distribution across outcomes
    - queries to identify the vertex interface as important/explanatory
      - change assumption of core objects (interface)
        - lack of a primary interface 
          - lack of cause, having a structural similarity with the problem space (appearance of lack of organization in the form of cause)
          - lack of the interface interface (relevance/organization)
          - lack of structure (equal distribution having minimal structure)
          - lack of information (randomness revealing minimal information)
      - apply a core structural concept's (similarity) insight function ('like attracts like', or 'equivalence can cause other equivalence'): 
        - equivalence of conflicting forces generating another type of equivalence (in outcomes)

  - structural interface query example
    - apply structures to structural components & operations to generate new solution object to format/organize/structure information for a given intent
      - select structure (network, tree, sequence, position, path, combination, filter, value)
      - select structural component (definition, base, variable, constant, coefficient, rate, change, type, function)
      - select structural operation (build, apply/change, derive/connect, test, find, organize)
    - example: 
      - start from a network of bases, apply changes of types supported by that base to generate variable networks for each base, then test each variable network with intent to find most useful base & variable network to solve a problem structure like 'finding relevant variables quickly'

  - info shapes: if you become dependent on info, youre always looking backward, using metrics/rules/info sources chosen in the past, with past info

  - ethical Shapes

      - if someone attacks their neighbor:
        - the neighbor can retaliate
        - or the neighbor can recognize that the hit was not relevant to them but to prior attack chains, and hit the source of that attack chain that attacked their neighbor,
          so rather than continuing the chain, the neighbor creates a causal circle, directing consequences toward the relevant source of the problem
      - there are ethical shapes for each ethical problem type

  - insight Shapes (Unit, Paths)

    - use patterns in network structures & insight paths to predict:
      - probable missing pieces of networks
      - insight path of a route type (optimal/realistic)
      - insight path trajectory for a particular assumption set

  - interface Shapes

    - interface: filter/standard for comparison of specific attribute(s)
    - interfaces evolve when a unifying attribute (priority, cause, structure) can frame a set of developing variances
    - interfaces, standards, & perspectives are all filters
      - an interface can be specific but on the general interface network, it offers a standard for multiple related attributes or causative attributes 
        (types/intents/patterns offer a way to interact with all layers of a system)
      - whereas a perspective is focused on a very restricted set of variables, with the intention of distorting reality to highlight information that other perspectives dont make clear

  - variance Shapes: given that variance flows through systems in patterns, what are the common variance shapes, given host system type & structure + set of unknowns?
  - pattern Shapes: given that observed patterns often have patterns, what are the common pattern & pattern-generation shapes, given variance level & observation tools?
  - prediction Shapes: given that predictions are often between similarly complex systems & target metrics, what the common shapes of predictions, given system type & structure and metric type + set of unknowns?
  - certainty Shapes
    - while risk shapes store a ratio of shape coverage, certainty shapes store a compression of a shape
    - uncertainty shapes include variance gaps & questions

  - causal shapes
    - most causal shapes are cyclical, tensor, layer, or network-shaped rather than one-directional vector-shaped, which is why some existing methods are inherently incapable of producing system-fitted insights that wont break the system when applied (a particular drug that is not evaluated for bio-system impact, just impact on a particular pathogen or process)

  - math interface: matrix
    - find out method to determine adjacent matrix representations for a particular function, and use it in reverse to determine likely functions for a matrix
    - alternative methods of framing a matrix
      - operator interface: 
        - applying operations to vector sets within the vector set (custom operators to operate on, convert between, or generate the specific vectors in the matrix) & examining the output metrics
        - example:
          - ratio space of a matrix includes the output of vector ratios for properties associated with ratios (like rate of change or similarity) that can be used to describe the vector set
      - path interface:
        - applying path analysis to find paths across features in the matrix that reflect its properties
      - data interface:
        - applying statistical analysis to vectors as variable values/data points of a polynomial (coefficients being variables) or a function set
      - function interface:
        - finding relevant generator functions of matrix
      - state interface:
        - finding adjacent states that fit a common/useful/relevant transform pathway

  - market trade loops: independence can be created with closed trade loops
    - the most basic example is where agent A produces everything agent B needs, and vice versa


  # poc system object identification:

    - example problems

      - find in/efficiencies in a system
      - convert inefficiencies to efficiencies

    - example system

      - system of rules like:
        - 'A communicates info to B'
        - 'B converts info to a format that is interpretable by C, D, & E'
        - 'B sends the info to C, D, & E'

    - example workflow

      - import system as network

      - pull efficiency definition: 

        - interaction that fulfills an original intent with higher or similar resources after units of work, compared to units of work

        - pull sub-object definitions
          - interaction: function connecting multiple objects
          - cost: unit of work
          - benefit: resource that can be an input for an intent

      - convert definitions to system interface

        - find routes that 'fulfill original intent with higher or similar resources after units of work, compared to units of work'

        - convert sub-objects to system interface
          - resources in the system
          - intents supported by the system
          - original intent of the system
          - units of work in the system

      - create combination list of objects in system
        
        - resource A + function B for intent C
        - function A + object B + function C for intent 'get function C output D'

      - identify system objects (standard or specific) or object combinations matching the converted structural definition routes

        - identify relevant object filters in the system, according to the converted structural definition

          - units of work that result in higher or similar resources after the units of work
          - intents that have a high association with high resource/work ratio
          - resources that enable a high ratio of work units (resources that are an input to many functions)

        - identify relevant system structures that:

          - are often found with this object type (efficiency) or related object types (inefficiency)
          - generate these or related objects
          - fulfill their definitions (identify the object, determine whether an object fulfills that definitions' metric, invalidate an object identity according to definition metrics)
          - describe their interactions or related interactions

          - how to identify the components likeliest to be relevant to identify efficiency in a system (such as the 'unnecessary' attribute, the 'alignment' attribute, the 'coordination' function, etc)

            - apply system analysis to identify the important generative causes, changers/catalysts, core components, and other important vertices

              - core structures of efficiency
                - a core structure of 'cost-reduction' is removing unnecessary costs
              
              - efficiency interaction & change types
                - scope is an important structure bc inefficiencies tend to compound
              
              - proxies/alternates of efficiency
                - optimization is a related function that doesnt always produce the target efficiency but may fulfill another metric, so can be used as a proxy for efficiency & then irrelevant optimizations can be filtered out
              
              - changers of efficiency
                - resource distribution/sharing is related to efficiency bc if resources are distributed differently, different routes are optimal or efficient

          - attribute: required/unnecessary

            - required/unnecessary standard system components (using info objects found in systems, like ambiguities)
              - required/unnecessary ambiguities (options, unenforced rules, variables that should be constants or removed, etc)

            - required/unnecessary specific system components (objects/functions/attributes)
              - required/unnecessary sub-components (function inputs/outputs)

            - required/unnecessary combination components
              - condition-function-intent interaction
                - conditional work outside of context (conditions like validation checks applied where not needed)
              - node-middleman-node interaction

          - object: optimization opportunity

            - optimization opportunity (a trajectory between nodes that increases a resource/cost ratio)
              - alternate functions with an intent in common with varying speed in input cases that dont occur in this system

            - not all optimization opportunities will be useful in a system, given supported intents/metrics

          - object: scope

            - efficiencies can be local to agents or interactions rather than system-wide 
              - is it increasing one resource/cost ratio, at the expense of the system resource/cost ratios? if so, its an inefficiency even if it seems like an optimization

          - function: distribution

            - cost can be allocated in unfair/unbalanced ways
              - ethical rules can be injected as a filter to rule out optimization opportunities that distribute cost/resources unfairly (without considering cause/value/uniqueness of work)

          - attribute: alignment

            - alignment between intents is an efficiency-generator, since alignment creates a coordination/sharing opportunity of both work & resources (such as network effects)

          - function: info magnification

            - function attribute: many-to-one
            - object type: hub nodes
                
        - iterate through objects & combinations

          - does system object combination 'resource A + function B for intent C' match the efficiency definition 'high benefit/cost ratio' in its structural version 'high resource output compared to work input'?
            
            - does it have an optimization opportunity (does it match an inefficiency structural definition)?
              
              - if so, how could that inefficiency be converted to an efficiency?
                
                - apply all insight mechanisms to reduce work units that could result in higher resource outputs, such as:
                  - 'removing middlemen (unnecessary nodes/functions for an intent)'
                  - 'removing unnecessary inputs/outputs that create costs'
                  - 'calling conditional functions as needed (when the condition occurs) rather than every time'
                  - 'removing interactions that dont change outputs'
                  - 'removing ambiguities that dont add necessary variation'

    - example output:

      - applying insight path from efficiency definition:

        - iterate through attributes/functions/objects, checking for required/unnecessary components & other structures associated with the target object definition to identify

        - 'A communicates info to B'
          - does this communication contain unnecessary info?

        - 'B converts info to a format that is interpretable by C, D, & E'
          - is this conversion function necessary?
          - can this conversion function be done by A, or automatically?
          - can C, D, & E learn to interpret the original format?

        - 'B sends the info to C, D, & E'
          - does B send the info in one message or separately, and is there a need for separate messages or can they be condensed?

      - example efficiency opportunities:
        - if the conversion function is not required to be executed by B, the middleman node B can be removed, and the conversion function can be taught/distributed to receivers/senders or automated
        - if the messages dont need to be sent separately each to C, D, & E, the messages can be condensed into one message
        - if the messages dont need to be sent at all, but can be left in a place that C, D, & E go regularly, the 'send' function can be replaced with a 'leave in position' function

  '''