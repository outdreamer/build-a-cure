
    - examples of interface queries that function as problem-solving automation workflows 
        https://github.com/outdreamer/build-a-cure/blob/52c3461fdd3ff38284b63f8c2e71542f415d88d9/docs/specific_methods/problem_solving_matching.md 
      - The following are general examples of a workflow to find a solution to a problem automatically, as described in application 16887411.  
      The process 400 in application 16887411 runs interface queries to match a problem with its intended solution information (like a strategy) in the intended solution format (strategy formatted as a set of steps in a problem network or vectors reducing a problem shape) 
        - interface queries to solve a problem can be as simple as a query for specific solutions to re-use solutions in the database, or as complex as applying a format to the problem to make calculating the solution trivial) 
        Workflow variables optionally include: 
          - starting point of the analysis (which interface the query starts from) 
          - structures relevant (which structures or type of graphing method to use) 
          - intent (create a prediction function, reduce solution space, compare solutions, or match problem with solution) 
          - core abstract function represented (is it a find method, an apply method, a combination) 
          - formats & structures used (object model, interface query) 
        If the problem is 'finding a structure that matches conceptual priorities like strength', that can clearly begin on the concept-structure traversal, if information required for that traversal already exists in the problem definition or derived metadata 
          - concept-structure interface traversal (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with structures like filters/limits/functions that adjust the origin structure until it matches the target structural attributes or concepts) 
          - problem-solution interface traversal: sometimes a sufficient solution may be already stored in the solution table (solution being an information object) and the way to solve the problem is formatting it correctly or identifying its type correctly so that solutions for that format or type can be queried & applied as-is, the most basic traversal type 
          - intent interface traversal, which is particularly effective at linking other interfaces (find intents & intent structures that fulfill the 'strength' attribute, and structures matching those intents) 
        Other workflows can be derived given alternate traversals that can generate information (like how causation, information formats, functions, and intent can generate structure information), given existing information. 
        These workflows can be generated with new interface combinations or interfaces, if each interface in the sequence can add information required to solve the problem. Occasionally an interface will be sufficient on its own, if the problem is already pre-structured. For example, the function interface may be enough to find the right sequence of functions, if the function metadata optionally includes input/outputs and there are no ambiguities to resolve, meaning this solution is a simple query to match inputs/outputs, where the final output is the intended goal of the query 
        Other problem-solving automation workflows would start with different interface traversals & use different origin & target structures, different target structures like:  
          - a new method to design interface trajectories 
          - new info object layers to use as interfaces/systems (like by combining perspective & potential to generate a potential-perspective field, problems & markets to create a market for problems, platforms & platforms to create a platform to sell platforms, variables & networks to create variable networks, variables & risk to identify variable development sequences)). 
          - structures that, when applied to a problem, create a clear format/structure sequence linking the problem with a solution (like insights such as 'break a problem into sub-problems & aggregate solutions' or 'apply filters until the problem space is a solution space, then repeat until the solution space is a solution'). A specific example is 'problem vectorization' as mentioned above in VII: finding specific interim formats linking a problem & solution format (such as the structure of concepts/interfaces that would link variables with a prediction function) & applying structures to create that format sequence (like a directed network) 
        A problem-solving automation workflow is a type of interface traversal that can be applied to any problem, although some workflows are more adjacent to a problem definition than others, like how a highly structured problem may already have an existing solution in the database, so that workflow of querying the database to find a solution should be applied first. Workflows are very abstract insight paths (a cross-system, insight-generating sequence) detailing specific interface traversals that can generate solutions automatically.     
        For example, the workflow inherent to this tool (to match a problem with a solution) uses the problem information as the default interface. The overall workflow of this tool can be built with an interface query: 
          - find problem type & format the problem as a combination of information problem types (information (problem, assumption) interface, type interface), as well as any related problems (information (problem) interface, pattern interface, and the change interface to generate related problems if none are logged) 
          - find solution requirements (structure interface where requirements are limits/thresholds) 
          - apply a set of various information formats (interface interface, information interface, structure interface), positioned in the sequence likeliest to find the missing information to solve the problem. For example, if its missing cause information, standardize to the causal interface or generate information about likely causes from other interfaces like the pattern interface or generate adjacent or proxy information to cause information like a set of tests to filter out non-cause information or generate interaction pattern information to predict which objects will interact, generating causes. 
          - if the information formats applied don't reveal enough info, apply combinations of the formats (structure interface, core interface) 
          - if no solution space can be identified or reduced, return the queries and the problem & problem space metadata 
        Specific workflows to automate problem-solving apply various interfaces & analysis types, and can be applied to any problem with sufficient information in its definition. These workflows optionally include: 
          I. Filter problem definition until it matches solution structure (using definition & standardization, applying increasing limits/filters/transforms until problem & solution match) 
            - this applies structures such as limits to fulfill solution intents iteratively 
            - for example, when deriving the structural implementation of the concept of cryptocurrency, applying a 'group' structure to the 'transaction' object creates the 'transaction ledger' object, which fulfills sub-intents of the solution ('access related information' and 'connect related information') and reduces a problem sub-component (the 'information imbalance' problem type between receiver & sender), a problem type which has related solution functions (like 'distribute information evenly') 
          II. Solve problem with structure fitting (adapt probable solution structures to match problem definition) 
            - this starts with core, probable, or difference-maximizing structures and applies additional structures until one is found that fulfills solution metrics 
            - for example, to find a prediction function for a data set,  
            - the core functions would be common base/distortion (patterns of change), component (core patterns of prediction functions), approximation (generalizing functions), & adjacent functions (functions within a range of accuracy) of prediction functions 
            - the probable functions would be functions in between the most accurate and the most generalized function versions 
            - the difference-maximizing functions would be the most different possible functions (a circle function to explain a high-randomness data set, multiple step-functions to explain a continuous function, a linear function, etc) to start by examining the most different possibilities and eliminate them with additional filters 
          III. Transforming problem into query of solved problems (using most adjacent solution formats) 
            - converting the problem into a structure (set, sequence, network) of solved problems (like distributing power, resolving imbalances, etc), and then traversing that structure if multiple alternatives are found 
            - this method can take the form of a simple database query ('fetch & apply solutions, optionally including insight paths, for this problem type' or 'find the fewest question jumps that can solve the problem') in its most basic form, if the problem is an existing solved problem 
            - for example, finding a prediction function is a set of problems like 'decide on metrics & threshold values', 'decide on complexity', 'choose between opposing sides of tradeoffs', 'generalize', 'identify outliers', 'identify noise', 'account for error types like corrupt/incorrect/unrecoverable/incentivized or improperly formatted/standardized data', 'account for alternate explanations', 'account for correlation between independent variables', 'account for incorrect data types', 'account for missing information', etc 
          IV. Solve problem with solution function generation & selection (optionally with pattern/intent-matching) 
            - this uses the function interface to identify useful metrics to select functions to begin with when searching for a function to solve a problem (like 'calculate x') which can involve function metadata like identifying hub functions, functions that move in a direction, etc 
            - this analysis involves identifying/deriving decision rules to identify alternate/interchangeable solution functions & select between solution functions 
            - an example would be deciding when to select a solution function you have indexed in the solution table and when to look for a new function, or update the existing function 
          V. Solve problem with conceptual query (iterate through conceptual paths & match with structural path) 
            - start with required concepts (but not their optimal relationships in a concept combination) such as 'trust', 'distribution', 'power', and find a structure that arranges those concepts in an optimal way that fits the solution requirements 
          VI. Derive conceptual query & match with structural path 
            - start by finding the concept combination required ('trust generated from equal distribution of power'), then find matching structures of that specific combination 
          VII. Vectorize problem/solution space & match intents 
            - this involves framing a problem as a structure like a directed network to convert it to a route optimization problem, where the assumptions are inputs, the intents are outputs, & the interim structures can be a mix of interface objects like concepts 
            - if you have a general problem definition like 'find a function that calculates x', you would arrange input information on one side, the function on the other side as the goal, and identify related concepts, patterns, & other objects to that intent to connect them, given the definition routes of those terms 
            - this can also involve formatting the problem as a set of questions (sub-problems of an information asymmetry problem type) to answer that map from starting information to target information 
          VIII. Mapping variance objects in problem space systems as starting solution space 
            - framing a problem in terms of variance (on the potential interface) makes it clear which objects are important, given variance/potential structures like interaction spaces, inevitable interactions, variance gaps, etc 
            - the high-variance objects in the 'find a prediction function' problem are the error types, assumptions, change types, data set concepts (like how the concept of 'survival skills' is relevant & inferable in the titanic survival data set), and variation across data sets, so a good solution would integrate functions to identify & handle those objects 
          IX. System snapshot (interface/symmetry/vertex) derivation 
            - finding the specific interfaces & related objects in a problem system to frame a problem efficiently 
            - in the bio system, this would mean automatically identifying the genetic configuration, protein structure, immune memory, and brain interfaces as important determinants of the system 
            - in a function set like a code base, this would mean automatically identifying the function type interface (to identify function types like boundary/change rules for efficient function indexing) and the intent interface as important for indexing functions 
            - in the 'find a prediction function' problem, this would identify the concept of 'average' as an important symmetry balancing various tradeoffs, identify independent variable probability distributions as an important vertex in predicting the behavior of dependent variables, and identify the cause interface as an important interface for understanding, which is a proxy for a prediction function, the potential interface as a tool for understanding variable dynamics (how sources of variance gather into variables), and the system interface as a way to derive the range of possible prediction functions (how variables gather in complex systems, and how the range of prediction functions is whichever prediction functions are possible between those variables as system components, given system structure, so you should start with the vertices of that range - meaning a set of difference-maximizing functions in that range) 
          X. System derivation 
            - this is a more comprehensive format that allows quick application & identification of system objects (alternates, efficiencies, incentives) 
            - for example, identifying known system objects for the 'find a prediction function' problem would mean identifying incentives in data collection (collect small sample, collect representative sample), efficiencies in calculating prediction functions (some sections should be treated as potential fields, where a network is embedded in place of a function section, to indicate decision logic or alternate functions accessible with additional information, if a predicted value is requested from that section of the function), false similarities (like the apparent similarity between two variables being correlation rather than a direct relationship), opposites (like neutralizing variables), and other core system objects 
  