- dependencies

	- constants

		- definitions

			- component definitions (interface, function, etc)

			- a minimum set of interface object definitions (abstract concept definitions, change function definitions, math function definitions, etc)

	- functions:

		- function types:


    - once those are defined, you can run queries to find matching objects
    - then you need conversion functions between formats (to an interface)
      - a good test of conversion functions is 'can they find a docs site for alternate tools, and map/fit objects between docs to generate a key-value map to migrate between tools'
    - once you have conversion functions, you can connect problem space data to solutions
    - then youd need problem space visualization & solution metadata calculation functions to finish it
    - function to determine minimum information & other solvability metrics
      - example: if a process happened in the past and didnt leave measurable info like fossils or evolution, that problem isnt solvable, but if the phenomenon happens again and can be predicted or triggered, the information may be capturable


			- core functions (find, identify, apply, build, derive, change)

			- interface conversion functions (standardize to an interface format)

			- interface traversal functions (to find matching components between input & interface)

			- interface operation functions (to apply an interface to another, combine interfaces, etc)

			- interface-specific logic functions (to navigate a particular interface, such as with interface-specific priorities or operations)

				- this function applies the core functions to interface objects (patterns, intents, definitions)

					- then it iterates that application, until the iterated core function-interface object combinations describe the important interaction layer referenced in the interface definition

					- example: 
						- the information interface:
							- applies core functions (find, build, apply) to the core information interface objects (value, fact, rule)
							- it then alters the output with structural components (position, distribution, routes, state)
							- to produce:
								- core structures of that interface (info imbalance)
								- interaction layer that the information interface is normally interacted with:
									- assumptions (constant info), questions (info imbalance), insights (new true info), problems (problematic info, info problem types like imbalanced or conflicting info) etc
								- then it applies core & interface-specific operations given component definitions to generate probable interactions between the objects on that interaction layer
									- to produce the set of emerging interaction functions at that layer, which describe the interface-specific functions that may differ from those on other interfaces, which should be stored as interface-specific logic functions
									- information interface-specific functions would include functions that answer questions about information component interactions, like:
										- which question structures normally produce which information-aggregation or filtering patterns?
										- which question types usually produce the most insight paths?
									- but also questions about cross-layer interactions, like:
										- what facts typically lead to which questions?
										- what insight types rely on the lowest number of facts?
										- what facts are linked to the most problems?
									- standard interface functions would answer questions like:
										- what objects generate or interact the most with other layers or other objects on the same interaction layer (applies system interface)
							- additional layers can be generated by iterating this process

					- a summary of the interface-specific analysis is: 
						- apply core analysis
						- apply structural interface to output of core analysis (identify structures like layers or connections between core analysis output objects)
						- apply other interfaces to the output of the core analysis & structural interface output (apply system/causal interface to identify structures of other interface objects (like combinations) that could determine interface-specific interactions on that interface, such as the unique connections across components on different interactions layers of the interface (like the link between a fact and an assumption)
						- once you have a set of functions which describes important interactions or a set of core operations which can generate descriptions of important interactions (and a function to combine these core operations), you're almost done describing the interface-specific logic
						- the next step is describing cross-interface interactions, to identify how a specific interface interacts with other specific interfaces
						- then finally, describing any logic specific to how that interface changes

	- objects:

		- an interface object index (including objects like insights, example patterns, or function definitions) can be a dependency, so the system can re-generate itself if other dependencies are compromised
		
		- language map

			- this is a standard language map of related terms, which may be specific to usage (some words are popular to use in a particular way) or state (some words are banned)
				
				- the reason you'd want a comprehensive map including non-standard terms is to include options to indicate information by using specific terms that may not be standard
					
					- example:
						- 'alter the objects, functions, and attributes of the component, and then replace the object attributes with defaults' can be standardized to replace all the nouns with 'component', which may be more standard, but it will lose information like what to apply the 'replace' operation to, and which component types 'of the component' you're referring to

			- alternate language maps can include terms that have been standardized to a particular interface

				- example: 

					- standardizing a term like 'balance' to the structural interface could produce a definition like 'a structure with a clear differentiating boundary where resources on either side of the boundary are equivalent'
					
					- standardizing a term like 'equal' to the structural interface could produce a definition like 'equal on this attribute', or 'equal in a structural attribute like position or functionality'

		- math-language operator map (for standardizing to the math or language interface, given input values/patterns in either format)
			
			- example: this can be created with a function that can:
				- translate core terms like 'multiply' to 'expand'
				- identify specific implementations of multiply that map to related terms (compare, intersect, interact, combine, organize, connect)
				- identify the set of core terms that can generate a more specific term

			- this function can use patterns across these systems to map terms (components with certain interaction/change patterns or functionality or position across the language & math systems)

			- ideally these maps would be updated with usage

			- these maps can also be updated with patterns & other predictive tools like core analysis, to identify probable new combinations of core components likely to be used next




