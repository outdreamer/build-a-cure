- dependencies

	- constants

		- definitions

			- component definitions (interface, function, etc)

			- a minimum set of interface object definitions (abstract concept definitions, change function definitions, math function definitions, etc)

	- functions:

		- function types:


    - once those are defined, you can run queries to find matching objects
    - then you need conversion functions between formats (to an interface)
      - a good test of conversion functions is 'can they find a docs site for alternate tools, and map/fit objects between docs to generate a key-value map to migrate between tools'
    - once you have conversion functions, you can connect problem space data to solutions
    - then youd need problem space visualization & solution metadata calculation functions to finish it
    - function to determine minimum information & other solvability metrics
      - example: if a process happened in the past and didnt leave measurable info like fossils or evolution, that problem isnt solvable, but if the phenomenon happens again and can be predicted or triggered, the information may be capturable


			- core functions (find, identify, apply, build, derive, change)

			- interface conversion functions (standardize to an interface format)

			- interface traversal functions (to find matching components between input & interface)

			- interface operation functions (to apply an interface to another, combine interfaces, etc)

			- interface-specific logic functions (to navigate a particular interface, such as with interface-specific priorities or operations)

				- this function applies the core functions to interface objects (patterns, intents, definitions)

					- then it iterates that application, until the iterated core function-interface object combinations describe the important interaction layer referenced in the interface definition

					- example: when the information interface applies core functions (find, build, apply) to the core information interface objects (value, fact, rule), permuting them with structural components (position, distribution, routes, state), it will produce the core structures of that interface (info imbalance), and subsequently produce the interaction layer that the information interface is normally interacted with (assumption (constant info), questions (info imbalance), insights (new true info), etc), and the set of emerging interaction functions at that layer describe the interface-specific functions that may differ from those on other interfaces, which should be stored as interface-specific logic functions.

	- objects:

		- an interface object index (including objects like insights, example patterns, or function definitions) can be a dependency, so the system can re-generate itself if other dependencies are compromised
		
		- language map

			- this is a standard language map of related terms, which may be specific to usage (some words are popular to use in a particular way) or state (some words are banned)
				
				- the reason you'd want a comprehensive map including non-standard terms is to include options to indicate information by using specific terms that may not be standard
					
					- example:
						- 'alter the objects, functions, and attributes of the component, and then replace the object attributes with defaults' can be standardized to replace all the nouns with 'component', which may be more standard, but it will lose information like what to apply the 'replace' operation to, and which component types 'of the component' you're referring to

			- alternate language maps can include terms that have been standardized to a particular interface

				- example: 

					- standardizing a term like 'balance' to the structural interface could produce a definition like 'a structure with a clear differentiating boundary where resources on either side of the boundary are equivalent'
					
					- standardizing a term like 'equal' to the structural interface could produce a definition like 'equal on this attribute', or 'equal in a structural attribute like position or functionality'

		- math-language operator map (for standardizing to the math or language interface, given input values/patterns in either format)
			
			- example: this can be created with a function that can:
				- translate core terms like 'multiply' to 'expand'
				- identify specific implementations of multiply that map to related terms (compare, intersect, interact, combine, organize, connect)
				- identify the set of core terms that can generate a more specific term

			- this function can use patterns across these systems to map terms (components with certain interaction/change patterns or functionality or position across the language & math systems)

			- ideally these maps would be updated with usage

			- these maps can also be updated with patterns & other predictive tools like core analysis, to identify probable new combinations of core components likely to be used next




