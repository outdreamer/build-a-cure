CLAIMS 


The overall workflow of this tool can be built with an interface query:

	- find problem type & format the problem as a combination of information problem types (information (problem, assumption) interface, type interface), as well as any related problems (information (problem) interface, pattern interface, and the change interface to generate related problems if none are logged)
	- find solution requirements (structure interface where requirements are limits/thresholds)
	- apply a directed graph (structure interface) of various information formats (interface interface, information interface), positioned in the sequence likeliest to find the missing information to solve (structure interface, similarity concept interface)
		(if its missing cause information, standardize to the causal interface or generate information about likely causes from other interfaces like the pattern interface or generate adjacent or proxy information to cause information like a set of tests to filter out non-cause information or generate interaction pattern information to predict which objects will interact, generating causes)
	- if the information formats applied dont reveal enough info, apply combinations of the formats (structure interface, core interface)
	- if no solution space can be identified or reduced, return the queries and the problem & problem space metadata

Here's why different interfaces are more useful in different situations, given a standard problem like 'build a function automatically for a given function intent'.

Intent interface

	If you want to build a function automatically, and you have code indexed by intent, then you don't need to write code, you need to write the intent & sub-intent sequence or other structure. I would call that 'standardizing to the intent interface' or 'applying intent structures' to the overall function intent, which is the problem definition ('build a function with this overall intent'). If you already have code indexed by intent, framing a function as a set of intents is trivial. If you don't already have code indexed by intent, the process you use to decompose an overall function intent into a structure of sub-intents is a tool that can be re-used to index existing functions by intent.

Information interface

	If the problem can be framed as an information problem, you can query information problem type rules & patterns to solve it automatically. Building a function automatically given an overall intent would mean:
		
		- solving a series of information problems like:
			- 'information mismatch' (object1 doesnt match object2 and it should, so assign object2 to object1)
			- 'conflicting information' (object1 doesnt match object2 so merge their conflicts) 
			- 'required information' (object1 is required to have this attribute value so assign it)
			- 'missing information' (object1 is missing this attribute so return False or query for that information or generate it).

Cause interface

	If the problem can be framed as a cause problem, then you are querying for causes. Building a function automatically given an overall intent would mean: 

		- finding the causes of bugs
		- finding the causes of different types of logic & structures (like sequences) applied to different types of logic (inherent rules governing logic given the point/definition of logical operations, like 'an if condition usually precedes a non-if condition' because the point of an if condition is to test for a case to apply logic, where the logic applied is not another condition)
		- finding the causes of functions & function-related objects like side effects, memory usage, optimizations done on other functions, etc
		- then you'd compose these causes in a structure that would allow automatic generation of functions from a given intent (first apply logic-related causes to generate a function causing the given function intent, then check for optimization-causes in the generated function & apply optimizations if those causes are found in your generated function structure, then apply tests for bug causes, etc).

Structure interface

	If the problem can be framed as a structure problem, then you are querying for structures. Building a function automatically given an overall intent would mean:

		- finding structures to standardize functions to (limits, filters, networks of relationships, directed networks of operations)
		- finding structures to standardize intents to (directions as priorities or more structural goals, possible usage ranges as intents, abstraction as an indicator of intent (neutral/mathematical functions can be used for anything), using intent as a proxy structure for the concept of permission by organizing information access by intent)
		- matching intent & function structures that fulfill the given overall function intent without causing invalidating side effect intents

Pattern interface

	If the problem can be framed as a problem of resolving which patterns to combine in what structures (where patterns include abstract/generalized structures (such as variables, variable patterns, input-output path patterns, or type patterns) that resolve to specific logic when converted into information, meaning theyre assigned constants), building a function automatically given an overall intent would mean:
		
		- finding which patterns or alternative pattern sets (a variable type relationship pattern, an input-output type trajectory pattern, a logic sequence pattern, an optimization pattern) can generate the required logic when constants (specific information-filled versions of the abstract pattern structure) are applied
			- the output of that may be as diverse as an input-output table to handle a variety of use cases observed, a prediction function trained on input-output data, a logical sequence, a code query, an intent sequence, a directed logic network, etc - depending on the patterns used

System interface

	If the problem can be framed as a problem of fitting the function to a system, building a function automatically given an overall intent would mean:
		- identifying starting & ending position to map intent to structure in the system (get from input start node to output end node)
		- identify default & alternative (higher cost, lower step count, etc) paths between start & end node
		- identifying system objects like efficiencies, incentives, etc, especially those structures clearly relevant to the default & alternative paths between start & end nodes identified
		- applying definitions of those system objects to select the logical step sequence (avoid conflicts, target rewards without side effects, minimize costs, apply symmetries for standardization purposes)
		- checking which routes fulfill given function intent

Concept interface

	If the problem can be framed as a set of concepts required for the solution (framing the intent in terms of concepts like 'distribute power evenly'), or if you have conceptual information indexed for code, building a function automatically given an overall intent would mean:

		- using conceptual math operations to determine which structure of concepts is most useful for the given intent (if combining 'power' and 'efficiency' in a 'sequence' or 'balanced' structure would produce the optimal function for an intent like 'distribute power evenly', that is calculatable if you have other functions indexed by conceptual structures, or if you have conceptual math operations accessible to determine what structure of concepts would generate the required concept set, or if you have intent indexed by conceptual structures, or if you can standardize intent & concept to another interface where you have conceptual structures indexed, etc)
			- for example if you have functions indexed with conceptual structures like the individual concepts required (power, efficiency, distribution), what operations can be applied to these concepts to create the optimal concept combination ('distribute power evenly') - meaning conceptual operations like 'inject power to distribution structure', 'limit distribution structure with power injected by efficiency', etc.
			- these conceptual operations involve finding matching structures across the concept definitions:
				- 'injecting' power into a structure manifesting the 'distribution' concept is possible if the distribution-manifesting structure has an input opportunity of some structure, and power can be translated into a structure that can be used by the structure having that input opportunity (a distribution structure such as a function having an input opportunity in the form of a parameter, where power can be translated into a usable structure like information assigned to that parameter), given the definition of the 'inject' operation as 'input the injectable to the receiver'
			- you can avoid doing structural operations by storing the structures for each concept and then storing patterns/outputs of their operations
				- if combining power & efficiency produces a structure set, that can be derived by querying the structures of power & efficiency and combining those structures in a way that doesnt invalidate either definition
			- you can also apply logic to the concept operation ('inject power to distribution, limited by efficiency') to create the output concept of that conceptual operation ('efficient distribution of power'), and then do a structure query of that output concept
			- once you have function structures matching the output (having found function logic matching 'efficient distribution of power' once translated to the structural version 'minimized cost of allocating inputs' if inputs are the structure found in the function system matching the power definition, where 'minimized cost of allocating inputs' can mean 'diversifying calls for this intent across various alternative functions' or 're-using existing functions where possible to minimize the cost of building a function on-demand or at compile time' or 'a function set that minimizes the memory/space requirements of allocating inputs'), you check if those structures optimally fulfill this function's intent, 'distribute power evenly', and then execute the final steps to resolve those structures into function logic (with input-output requirement chains, intent-matching, etc)
			
Problem interface

	If the problem can be framed as a problem in a problem network of related problems, and/or a problem space, you can calculate attributes like whether the problem is about to be invalidated by other functions built for other problems, whether the profit opportunity of solving the problem is worth the probable cost, whether the whole problem space is about to fundamentally change, etc. Building a function automatically given an overall intent would mean:

		- determining whether the problem of organizing logic is a solved problem if framed differently (can AI generate code with enough accuracy to invalidate further investment)
		- determining whether solving an adjacent or proxy problem invalidates solving this specific problem (can concept or intent identification tools or even existing code bases invalidate the need for a tool to build functions automatically, or can code bases be re-written in a way that invalidates automatic code generation, by simplifying code-writing to a task of intent-writing or code query-writing or another process simple enough to invalidate complex code and the need to generate it)
			- determining if a solution like logic automation can replace code generation (a tool that automatically applies the definition of logic, including all related objects like logical fallacies, to prevent logically 'jumping to conclusions' or 'ignoring assumptions' or 'over-applying bias vs. updating bias', then indexing code as these logical objects so logical rules can be applied to optimize/generate code)
				- this would involve writing high-level logic language like 'find information, avoid misidentifying object1 as object2, combine common attributes of these objects with versioning in case of conflicting values, avoid this conclusion & this fallacy error type', which would allow logical object definitions (of what a fallacy is, what a legitimate conclusion/assumption/implication is, etc) to be applied automatically, rather than the existing method of applying conditional/contextual/specific low-level logic developer-defined definitions to be applied manually, which involves writing low-level logic like 'select * from table, check if object1.attribute.value == object2.attribute.value, etc'.
		- determining whether the problem can be formatted as a set of solved problems (applying organization to information, applying definitions, finding matching structures, generating tests) or in a format that is solved (route optimization)


Given the information you have, one interface may be more useful to standardize to than another. If you already have intent or cause information indexed or otherwise adjacently calculatable, or if those interfaces contain the required solution information (as in, the problem is 'finding the cause of some measurement', so the solution is going to be findable on the causal interface), you'd be better off standardizing to those interfaces first, without other information.


Examples to use in claims & drawings:

	- problem: find a prediction function to predict variables causing an output, like predicting stock price or a diagnosis from symptoms/causative conditions
		
		- interface traversal
			- information (describing variable types, redundancies, missing info, etc)
			- system (fitting the variables to a system format)
			- causal (finding root/direct causes & causal structures)
			- concept (whether the problem is valid given a definition of price)
			- change (how the function can change)
		
		- if thats not enough to fulfill solution metrics or reduce the problem (identify a range of possible prediction functions), traversals with interface operations can be done
			- causal * change * pattern - to examine whether causal change patterns can reduce the problem or identify a solution
			- concept * change * causes - to identify if a concept change looks imminent

	- problem: find & build an optimal invention design to fulfill intents like 'building a function with minimal bugs'

		- interface traversal
			- information (describing function intents, limits, and assumptions like parameters)
			- system (fitting the function to a system, formatted to include possible variance injection points, identify efficiencies like logic that can be merged, etc)
			- structure (identifying structures that can be applied to the function system, like filters (conditions), direction changes (control flow statements), relationships (assignments), and mismatches (errors)
			- potential (identifying unenforced rules, rule-intent imbalances, false similarities, & other objects of potential allowing exploit opportunities that are not already identified)
			- causal, intent, concept (test function impact on other causes, concepts, & intents, which are high-level objects a function can alter)
		
		- if the function implementation doesnt fulfill solution metrics, other interface traversals can be done
			- pattern interface (does this function comply with patterns for functions with similar solution metrics)
			- a system-object or function-concept interface like the 'efficiency interface' or 'ambiguity interface' (does this function have a more efficient or less ambiguous route between input & output that might fulfill a solution metric, given that maximizing efficiency & reducing ambiguity are standard system & function metrics)

	- problem: find an optimal route between start & end points, like the 'minimal trades to get equal problem/opportunity distribution'
		
		- interface traversal
			- information (identify differentiating attributes/functions/sub-systems of agents/positions/routes within the system)
			- system (identify relevant structures like abstraction layer to traverse at, identify important objects required to solve the problem, like trading problems/markets/skills/information/risk/bets vs. trading currency, or framing currency as a position attribute, rather than a standardizing interface)
			- structure (identify trade & other market structures that are important for understanding why resources dont get distributed fairly, like closed trade loops & independence machines)
			- potential (identify alternative perspectives that could also explain the variation in optimized routes, like alternate value definitions)
			- causal (identify causes like marketing, collusion, and regulations that prevent or interfere with equilibrium market events)
			- concept (identify concepts relevant to markets like balance, demand/supply matching, and how the concept of information can disrupt any other market bc it enables automation)
		
		- if queries of those interfaces are insufficient to solve the problem, interface operations can be used
			- the information-system-structure interface operation (can be used to determine information like the next layer of information objects that are relevant if enough automation is distributed)


1. A method comprising: 

	- obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes)
		
		- converting a user-submitted query like 'distribute money equally' into a standardized problem statement like 'find a function to distribute resources while fulfilling this fairness definition', which is the actual intent of the user, given that equality and fairness definitions are often conflated


	- identifying problem & problem space metadata (such as problem type, variables, side effects, position on problem network, & minimum information required to solve the problem)
		
		- for the 'route optimization' problem, this means identifying: 
			- the problem type stack, like 'information asymmetry', 'find function', 'route optimization', 'system fitting', 'object identification'
			- the problem space metadata, like related problems ('getting consensus', 'aligning interests across disinterested parties', 'matching common interests')
			- the problem variables like 'information certainty (data accuracy/bias)', 'fairness definition across agent positions', 'cost-benefit of distributing vs. generating vs. deriving resources'
			- the minimum information to solve like 'algorithm to distribute or generate resources according to these definitions with x% consensus, y% accuracy, in a way that uses at least z% common interests like common problems'
			- the solution requirements, like solution formats (a function, a function to generate functions, a function to invalidate the function)
				- for example, the solution structure of a 'prediction function' problem is a function fulfilling a metric of an associated data set, like minimized distance from maximum data points, or an insight path that can generate a prediction function in that problem space as needed

	- identifying optimal origin interface to start traversing from, identifying the interface traversal sequence, & applying interface operations like combine/embed
		
		- using core operations (like find, identify, fit, match, apply, embed, build, create, derive) and standard interfaces, generate a custom flow diagram representing the interface query, which will specify what steps to take across the interface network to solve this specific problem

		- *** example interface traversal flow diagram:
			- identify information (identify differentiating attributes/functions/sub-systems of agents/positions/routes within the system)
			- fit a system (identify relevant structures like abstraction layer to traverse at, identify important objects required to solve the problem, like trading problems/markets/skills/information/risk/bets vs. trading currency, or framing currency as a position attribute, rather than a standardizing interface)
			- match structures (identify trade & other market structures that are important for understanding why resources dont get distributed fairly, like closed trade loops & independence machines)
			- identify potential (identify alternative perspectives that could also explain the variation in optimized routes, like alternate value definitions)
			- fit causes (identify causes like marketing, collusion, and regulations that prevent or interfere with equilibrium market events)
			- find concepts (identify concepts relevant to markets like balance, demand/supply matching, and how the concept of information can disrupt any other market bc it enables automation)
		
		- if queries of those interfaces are insufficient to solve the problem, interface operations can be used
			- apply the system-structure interface to the information interface (can be used to determine information like the next layer of information objects that are relevant if enough automation is distributed)


	- traversing the interface network (including interfaces such as information, insight, structure, math, concept, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) according to that interface query, where the interface network is a network of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions/objects/attributes, and related information objects like patterns & other metadata specific to the interface)

		- traversing an interface requires first converting problem objects to that interface
		- the conversion function might be as simple as reducing objects to a set of attributes relevant to that interface (like how standardizing to the causal interface means focusing on dependencies between positions), or as complicated as fitting problem objects to another system
		- converting the 'route optimization' problem to the concept interface means identifying all important concepts (varying by the conceptual structure of an abstraction layer) determining the various states, paths, attributes, limits & other known important objects of the system where the route optimization occurs, like conditions that can prevent switching or connection two nodes in the system
		- once converted, the traversal proceeds to finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions)
			- once an object is matched in an interface, the relationships of that object are queried and tested for relevance to the associated problem objects
		- once any matching interface objects are found, reducing the problem statement into its most useful structure to reflect the new information
			- if there are 'connection-prevention conditions' between concepts relevant to the problem definition (converted to the concept interface), those conditions can be looked for in the problem itself, and rules/patterns/attributes related to those conditions can be used to improve the solution structure that is the route (by reducing the route optimization costs, like reducing steps required) or maximizing rewards of a particular route, like hitting more valuable nodes during the route), so that useful information can be associated with problem objects newly identified as important from this interface traversal
		- the output of a traversal may include information like matching interface objects, problem/solution or problem/solution space metadata, or functions/attributes reducing the problem
		- the intent of the query is to match a problem & a solution, done with various analysis specific to interfaces or the interfaces resulting from interface operations


	- identifying and/or reducing the solution space to a solution, applying filtering information found from interface traversals, to the standardized original/updated problem format

		- the solution space is the set of possible solutions, which in a 'route optimization' problem (formatted as a network of possible node positions with connecting functions, and/or a set of state networks) is the set of all possible routes that fulfill some solution metric, if not all of them
			- the filters found by the matching concept interface relationships in the example can be applied to reduce the solution space further

		- the solution can also be in alternative formats, if a solution in one format cannot be found
			- the solution to a 'route optimization' problem doesn't have to be a network trajectory, it can be a function installed in all positions to prevent the route from being necessary to traverse, or a system optimization to the same effect

		- this step involves calculating the remaining distance from the minimum information required to solve the problem, any fulfilled solution requirements, & other measures of progress in reducing the problem like reducing problem variables, causes, related problems, etc

		- the solution is found when the solution metrics are fulfilled (an optimal route is found, a prediction function with some level of accuracy is found, or a set of implementation steps of a bug-free function is found), which doesn't necessarily mean the solution space has been reduced to one solution (the solution can be a set of alternatives, a range, or a comparable format)


	- traversing subsequent interfaces to obtain additional information, if the minimum information to solve is not reached

		- if the solution metrics are not fulfilled, the interface query is updated if new information was found, the query is continued if no information was found, or a new query is generated if the previous query was complete

			- if the solution route doesn't minimize costs or maximize rewards above the specified solution metric level, or if there are nodes in the system that weren't checked during the previous interface traversal & there is room for optimization in the previous traversal's solution, the interface query can be continued/updated or a new one can be generated


	- returning identified solutions as a set of steps to reduce/solve the problem, as well as solution metrics, attributes, & actions, and/or related information objects like insights, patterns, the systematized problem format, the reduced solution space, and the interface queries used.

		- this could be the specific optimized route or route-invalidating system-optimization function found, with metrics fulfilled, descriptive attributes, & relevant information like comparative cost/benefit of this solution, as well as alternate solutions, and including general metrics like success probability, robustness/permanence of solution, etc.


2. The method of claim 1, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms or using general/abstract versions of words, converting passive to active language, and removing words that don't change the meaning of the statement, and other operations that enable framing the problem as having a target solution structure.

*** formatted standardized problem definition & metadata


3. The method of claim 2, wherein identifying the problem & problem space metadata includes:
	- identifying metadata like the problem type (like an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and problem inputs like interchangeable attribute sets, dependencies, & assumptions, as well as the minimum information required to solve the problem & other solution requirements
	- mapping the inferred/stated information describing the problem & problem space to a multi-dimensional structure generated by the problem variables (variables like number of information asymmetries, resource limits, decision points, variance sources, unanswerable questions of the problem, the trajectory of causes generating the problem if known, etc), a problem structure usually bound by assumption/filter/limit conditions, & indicating possible interactions between the problem objects & the other system objects like related problems & previous solutions, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure).

*** problem system 
*** problem space
*** problem network in problem space


4. The method of claim 3, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: 
	- assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, and differentiation potential) of the given & directly inferable information, which may include recommended traversals given the problem type, if identified (like how a 'prediction function' problem type has a recommended interface query sequence)
	- whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface, for example)
	- which interfaces should be traversed in what sequence, combination, or other structure produced by an interface operation.

	This interface query is designed to maximize the chance of finding/generating/deriving additional information necessary to describe information about the problem system, beyond its initially identified metadata, so that its corresponding solution space can be identified/reduced.

*** example interface query


5. The method of claim 4, wherein traversing the interface network includes: 
	- converting the problem definition to the interface using that interface's conversion function (which applies logic like system-mapping, position-finding, structure-matching, & object-identification logic)
	- checking for common attributes between problem objects & interface objects & their connecting structures (like transformations, subsets, & paths)
	- using matching interface relationships to infer relationships about associated problem objects
	- identifying starting points on the interface, including core objects & functions, directly mappable objects to the problem objects, or other starting points like important/required interface objects
	- where the output of each traversal may include information like matching interface objects, problem/solution or problem/solution space metadata, or functions/attributes reducing the problem

	- where the intent of traversals is to match a problem & a solution & is done with various analysis specific to interfaces or the interfaces resulting from interface operations, such as:

		- information problem type formatting (mapping the problem as a structure composed of information problem types, like an information mismatch/inequality/minimum/overflow/gap)
		- problem formatting to convert problems to a format with more solution methods, such as problem vectorization (mapping the problem definition to a directed network with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions)
			- an example is a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network)
		- insight path application (using insight paths from other fields to optimize insight generation)
		- system analysis (fitting of system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, efficiencies, incentives, and conflicts to problem definition)
		- a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationships)
		- a causal interface traversal (where the problem structures are matched to causal structures to infer causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape)
		- structure-math traversal (a multi-interface traversal to map problem structures to math objects to apply math insights to problem structures)
		- concept-structure traversal (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with structures like filters/limits/functions that adjust the origin structure until it matches the target structural attributes or concepts)	
		- problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied)

*** example interface conversion, matching, starting point selection, and inference about problem objects


6. The method of claim 1, wherein the solution space is identified or reduced with filtering information found from interface traversals to the original/updated problem format, & the interface network traversal process in claims 3 - 5 is repeated for converting the problem space to a solution space or reducing the solution space as needed to fulfill solution metrics, & then finding/deriving/generating a specific solution or a general solution method that reduces the problem into a format that is more similar to its final solved format (identifying a specific optimal route or explanatory variable combination), where the solution method may be calculated on other interfaces & then converted to a vector or other object impacting the formatted problem in the problem space structure (the causes of a problem & the sequence of reducing these causes calculated on the causal interface, a set of causes & reduction step sequence that is then mapped to the problem format in the problem space, at which point the solution is ready to be checked with regard to impact on the original problem, the problem space and/or related problems)

*** example of identifying/reducing solution space, and calculation of distance to minimum information, problem reduction, and fulfilled solution requirements, then deriving which direction to continue interface traversal


7. The method of claim 1, further comprising deriving summary solution metadata from the output of the interface traversals executed, like the success of comparable alternative found solutions & whether the solution created other problems in the problem space, given the solution requirements stated/inferred from the problem statement, where the query information & standardized problem space information is returned and if a solution or solution set is found, the summary solution metadata is included.


10. A non-transitory computer-readable medium containing instructions that, when executed by a processor, cause a device to perform operations, the operations comprising: 
	- obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes); 
	- identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); 
	- identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; 
	- traversing interface network (including interfaces such as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; 
	- finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions);
	- compressing the problem statement into its most accurate structure containing the found interface objects; 
	- iterating the origin interface selection & interface traversal process for the solution space;
	- identifying & reducing the solution space from this standardized problem format; 
	- traversing subsequent interfaces to obtain additional information; 
	- reducing the solution space by the problem & problem space definition; 
	- returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/ patterns/system/standardized description related to the problem if no solutions are found.

11. The non-transitory computer-readable medium of claim 10, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms, converting passive to active language, and removing words that don't change the meaning of the statement. 

12. The non-transitory computer-readable medium of claim 11, wherein identifying the problem & problem space metadata includes: identifying the problem type given the most adjacent type (such as an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and the minimum information required to solve the problem (inputs like alternate attribute sets; solution requirements; constant assumptions & other dependencies), then mapping the inferred or stated assumptions describing the problem space to a multi-dimensional structure, usually bounded by assumption limit or filter conditions, & indicating possible interactions between the problem objects & the other system objects, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure). 

13. The non-transitory computer-readable medium of claim 12, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, differentiation potential) of the given & directly inferable information, which interfaces should be traversed in what sequence, and whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface for example). 
14. The non-transitory computer-readable medium of claim 13, wherein traversing the interface network includes: converting the problem definition to the interface using the conversion function which applies system-mapping, position-finding, & object-fitting logic, & looks for common attributes between problem objects & interface objects & their structures (like transformations, subsets, & paths) so that interface object relationships can be used to infer relationships about associated problem objects, where the traversal may start from various points on the interface, including core objects & functions, or directly mappable objects to the problem objects, or important or required interface objects. 

15. The non-transitory computer-readable medium of claim 10, wherein the instructions are further configured to iteratively repeat the traversal method on other interfaces, given the achieved distance from the minimum information required to solve the problem, fulfilled solution requirements, & progress in compressing the problem, where information output by each traversal may include information, interface objects, functions, or attributes compressing the problem. 

16. The non-transitory computer-readable medium of claim 10, wherein the solution metadata is identified & the interface network traversal process in claims 3 - 5 is repeated for reducing the problem space to a solution space & then deriving, finding, matching, applying, or building a specific solution or general solution method that compresses the problem into a form that is more adjacent to its final solved form (occupying a point rather than a multi-dimensional structure in the problem space definition), where the solution method may be executed on other interfaces and is then converted to a vector or other object impacting the formatted problem on an interim interface used for calculations, and is then converted to an object impacting the original problem in the problem space structure. 

17. The non-transitory computer-readable medium of claim 10, wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution definitions & associated space definitions, including system analysis (fitting of system objects like symmetries, sub-systems, sub- interfaces, false assumptions, correlations, and conflicts to problem definition); information problem type composition (mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack); insight path application (using insight paths from other fields to optimize insight generation); problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions); concept-structure application (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts); a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship); a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape); structure-math mapping (a multi-interface traversal to map problem structures to math objects to apply math insights to problem structures); a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network); problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied). 

18. The non-transitory computer-readable medium of claim 10, the operations further comprising determining the success of a particular solution, given the solution requirements stated or inferred from the problem statement & iterating if solution requirements are not met, or if the problem is not fully compressed, or if the solution created other problems in the problem space.

19. A system comprising: one or more processors; and one or more non-transitory computer- readable media containing instructions that, when executed by the one or more processors, cause the system to perform operations, the operations comprising: obtaining a problem statement from a user including required solution metrics (such as priorities, functionality, or attributes); identifying problem & problem space metadata (such as problem type & minimum information required to solve the problem); identifying optimal origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject; traversing interface network (including interfaces such as information, insight, structure, math, concept, type, variance, potential, change, intent, perspective, system, attribute, pattern, function, cause, problem/question, solution/answer) of interfaces acting as filters (where an interface is comprised of its definition routes, conversion function, core functions, objects, & attributes, and related objects like patterns & metadata specific to the interface) starting at the origin interface; finding components on the interface that match the problem structures (including related objects like insights, patterns, & functions); compressing the problem statement into its most accurate structure containing the found interface objects; iterating the origin interface selection & interface traversal process for the solution space; identifying & reducing the solution space from this standardized problem format; traversing subsequent interfaces to obtain additional information; reducing the solution space by the problem & problem space definition; returning the identified optimal solution as a set of steps to compress the problem as well as solution metrics, attributes, & actions, and/or insights/patterns/system/ standardized description related to the problem if no solutions are found. 

20. The system of claim 19, wherein obtaining a problem statement includes: receiving a problem statement & translating the problem statement into its most standardized form, using standardization methods like replacing esoteric words with more common synonyms, converting passive to active language, and removing words that don't change the meaning of the statement. 

21. The system of claim 19, wherein identifying the problem & problem space metadata includes: identifying the problem type given the most adjacent type (such as an information asymmetry, incentive conflict, unenforced rule, finding a prediction function, route optimization) and the minimum information required to solve the problem (inputs like alternate attribute sets; solution requirements; constant assumptions & other dependencies), then mapping the inferred or stated assumptions describing the problem space to a multi-dimensional structure, usually bounded by assumption limit or filter conditions, & indicating possible interactions between the problem objects & the other system objects, & containing the problem object in that space (as a network or other shape indicating the problem variable interactions within the problem space structure). 

22. The system of claim 19, wherein identifying the origin interface to start traversing from, interface traversal sequence, & applying interface operations like combine/inject includes: assessing which interface maximizes the value (calculated as a combination of metrics like specificity, uniqueness, differentiation potential) of the given & directly inferable information, which interfaces should be traversed in what sequence, and whether interfaces should be applied to other interfaces with interface operations (applying the conceptual interface to the structural interface for example). 

23. The system of claim 19, wherein traversing the interface network includes: converting the problem definition to the interface using the conversion function which applies system- mapping, position-finding, & object-fitting logic, & looks for common attributes between problem objects & interface objects & their structures (like transformations, subsets, & paths) so that interface object relationships can be used to infer relationships about associated problem objects, where the traversal may start from various points on the interface, including core objects & functions, or directly mappable objects to the problem objects, or important or required interface objects. 

24. The system of claim 19, further comprising iteratively repeating the traversal method on other interfaces, given the achieved distance from the minimum information required to solve the problem, fulfilled solution requirements, & progress in compressing the problem, where information output by each traversal may include information, interface objects, functions, or attributes compressing the problem. 

25. The system of claim 19, wherein the solution metadata is identified & the interface network traversal process in claims 3 - 5 is repeated for reducing the problem space to a solution space & then deriving, finding, matching, applying, or building a specific solution or general solution method that compresses the problem into a form that is more adjacent to its final solved form (occupying a point rather than a multi-dimensional structure in the problem space definition), where the solution method may be executed on other interfaces and is then converted to a vector or other object impacting the formatted problem on an interim interface used for calculations, and is then converted to an object impacting the original problem in the problem space structure. 

26. The system of claim 19, wherein the matching of a problem and a solution is done with various interface traversals, potentially determined by the selected origin of the traversal, problem & solution definitions & associated space definitions, including system analysis (fitting of system objects like symmetries, sub-systems, sub-interfaces, false assumptions, correlations, and conflicts to problem definition); information problem type composition (mapping the problem as a combination/set/path containing information problem types like an information mismatch or inequality or minimum or overflow or lack); insight path application (using insight paths from other fields to optimize insight generation); problem vectorization (mapping the problem definition to a one-directional tree with inputs on one side, interim inferred important problem concepts in between, and target priorities or attributes on the other, linked by available functions); concept-structure application (a multi-interface traversal linking the concept & structure interfaces, so a target concept combination/set/path or target structural attribute can be achieved with a combination of filters & limits or functions applied to adjust the structure until it matches the target structural attributes or concepts); a pattern interface traversal (where patterns replace missing required data, such as patterns between variables of specific types or system positions to infer their probable relationship); a causal interface traversal (where the problem structures are matched to causal structures to infer probable causation metadata like directness of cause, degree of cause, inevitability, uniqueness of cause, causal tree/network/loop/layer shape); structure-math mapping (a multi- interface traversal to map problem structures to math objects to apply math insights to problem structures); a question-answer interface traversal (where a question is framed as a source position and a target position on a network, and the answer is the most robust path or the path that moves the nearest to the target position or the path that moves in the priority direction on the network); problem space analysis (given whether the problem space changes in a way that invalidates the original or other problems once a particular solution is applied). 

27. The system of claim 19, further comprising determining the success of a particular solution, given the solution requirements stated or inferred from the problem statement & iterating if solution requirements are not met, or if the problem is not fully compressed, or if the solution created other problems in the problem space. 