# Implementation Instructions


## Object Model Analysis

	- this is a simple index of objects as class instances

	- uses:

		- predict interactions & optimal versions of objects/attributes/types/rules
			- predict emergent objects/attributes/types/rules

		- problem-solving automation method to query objects/attributes/types/rules
		- reduce solution space or identify causative factor in problem

	- tech debt:

		- identify data sources (code bases defining schema/class definitions)
		- implement data sanitization & import
		- implement identification functions (objects/attributes/types/rules) to gather more data pre-indexed
		- implement object operation functions (combine, merge, apply, mix, filter)
		- implement object function set (change functions, boundary functions, probability functions)


## System Analysis

	- extension of object model

	- fits objects indexed in object model together in a system

	- observes not just rules between objects, but other key system data like:

		- variance (gaps in rule enforcement) & variance sources (gaps in system boundary allowing variance from other systems to leak in)
		- emerging objects
		- system errors & error-handlers
		- vertices (factors that generate or influence the system development)
		- incentives (forces with a built-in reason lending it extra momentum/gravity pulling agents in that direction)
		- interface metadata (intent, pattern, types, function, etc)
		- relationship metadata (related systems, system position in system interface network)


## Intent Analysis

	- alternative index to system/object indexes
	- indexing objects in a system by intent allows for quick optimization


## Variance Analysis

	- alternative index, indexing objects by change/potential/uncertainty

	- this is the problem of adding/fitting/reducing structure from a gap in structure, which can be used to solve problems like:

		- prediction
			- which variables are explanatory, given what we can measure

		- causation
			- how alternatives can converge to the same level of variance or change patterns

	- reducing gaps in rule enforcement to shapes or paths has its own set of rules

	- this interface can also be used for specific attribute analysis, of properties that descend from concepts & take form in a specific problem space:
		- the power concept interface (has implementations that look like trust, info, etc)
		- the balance concept interface (has implementations that look like symmetry, justice, etc)


## Structural Analysis

	- indexing objects by structure allows clear matching of useful structures to objects/attributes/types/rules

	- answering questions like: 

		- which objects are chained (cause, risk, variance, errors, gaps, limits)
		- which are dimensions (isolatable attributes of change patterns)
		- which have position
		- that a type stack (which type values on different type layers) and a network/tree (type hierarchy) are useful structures to capture type relationships

	- this allows objects to be graphed in a standard way, which means translating objects like problems into a computable interface


## Transformation Analysis

	- this regards the potential to break down & format a problem into many different combinations of solved problems (optimal transport, linear algebra, etc) or known interfaces (type, intent)
	- some sets are more adjacent than more optimal sets & may be a better investment for short-term gains


## Info Analysis

	- on this index, a lot of human & biological problems (problems associated with sentient life) can be clarified
	- these objects are related to agents & their communication: perspective, strategy, decisions, intent, game, motivation, problems


## Problem Analysis

	- on this index, problems are mapped to structure, once problems have been converted to an information problem, which has a clear mapping to the structural interface

	- problems can always be framed as info problems (missing info, conflicting info, unconnected info, mismatches, imbalances, asymmetries)
		- finding a prediction function can be framed as an optimal path in a network of variable nodes

	- once you frame a problem as an info problem, you can map info to structure:
		- conflicts can be vectors with different direction or which overlap
		

## Interface Network

	- this is the set of networks that act as useful filters/standards for comparing metadata 

	- it can refer to a specific set for a specific problem space

		- the specific interface network for the debugging code space could be layers of network filters like:

			- dependencies
			- logic gaps/order/validity
			- side effects
			- types

		- these specific interface networks are often implementations of the general interface network with mapped objects:
			- dependency interface is a combination of the cause/function interface
			- types (data, classes, etc) interface is a subset of the general type interface
			- side effects are a subset of the variance interface (gaps in intent & execution, prediction of emergent attributes after nth iterations of combinations or other operations)

	- whereas the general interface network includes layers of network filters like:

		- intent (priority)
		- perspective (the unit filter object)
		- functions (can include patterns, strategies, rules, and any other set of operations/objects that has order)
		- structure
			- sub interfaces of structure include:
				- difference/position
				- shape
				- direction
		- concepts
		- types
		- variance (change/potential)
		- cause
		- conflict (problem/solution)
		- system

	- a super-interface involves the core functions that can generate the general interface network:

		- filter/find/identify
		- apply/combine
		- build/fill
		- derive/predict
		- change/transform/process

