# Implementation Instructions


## Object Model

	- this is a simple index of objects as class instances

	- uses:

		- predict interactions & optimal versions of objects/attributes/types/rules
			- predict emergent objects/attributes/types/rules
		- problem-solving automation method to query objects/attributes/types/rules and reduce solution space or identify causative factor in problem

	- tech debt:

		- identify data sources (code bases defining schema/class definitions)
		- implement data sanitization & import
		- implement identification functions (objects/attributes/types/rules) to gather more data pre-indexed
		- implement object operation functions (combine, merge, apply, mix, filter)
		- implement object function set (change functions, boundary functions, probability functions)


## System Analysis

	- extension of object model

	- fits objects indexed in object model together in a system

	- observes not just rules between objects, but other key system data like:

		- variance (gaps in rule enforcement) & variance sources (gaps in system boundary allowing variance from other systems to leak in)
		- emerging objects
		- system errors & error-handlers
		- vertices (factors that generate or influence the system development), 
		- incentives (forces with a built-in reason lending it extra momentum/gravity pulling agents in that direction)
		- interface metadata (intent, pattern, types, function, etc)


## Intent Analysis

	- alternative index to system/object indexes
	- indexing objects in a system by intent allows for quick optimization


## Variance Analysis

	- alternative index, indexing objects by change/potential/uncertainty

	- this is the problem of adding/fitting/reducing structure from a gap in structure, which can be used to solve problems like:

		- prediction
			- which variables are explanatory, given what we can measure

		- causation
			- how alternatives can converge to the same level of variance or change patterns

	- reducing gaps in rule enforcement to shapes or paths has its own set of rules


## Structural Analysis

	- indexing objects by structure allows clear matching of useful structures to objects/attributes/types/rules

	- answering questions like: 

		- which objects are chained (cause, risk, variance, errors, gaps, limits)
		- which are dimensions (isolatable attributes of change patterns)
		- which have position
		- that a type stack (which type values on different type layers) and a network/tree (type hierarchy) are useful structures to capture type relationships

	- this allows objects to be graphed in a standard way, which means translating objects like problems into a computable interface


## Transformation Analysis

	- this regards the potential to break down & format a problem into many different combinations of solved problems (optimal transport, linear algebra, etc) or known interfaces (type, intent)
	- some sets are more adjacent than more optimal sets & may be a better investment for short-term gains


## Info Object Index

	- on this index, a lot of human & biological problems (problems associated with sentient life) can be clarified
	- these objects are related to agents & their communication: perspective, strategy, decisions, intent, game, motivation


## Interface Network

	- this is the set of networks that act as useful filters/standards for comparing metadata 

	- it can refer to a specific set for a specific problem space

		- the specific interface network for the debugging code space could be layers of network filters like:
			- dependencies
			- logic gaps/order/validity
			- side effects
			- types

	- whereas the general interface network includes layers of network filters like:

		- intent (priority)
		- perspective (the unit filter object)
		- functions (can include patterns, strategies, rules, and any other set of operations/objects that has order)
		- structure
			- sub interfaces of structure include:
				- difference/position
				- shape
				- direction
		- concepts
		- types
		- variance (change/potential)

	- a super-interface involves the core functions that can generate the general interface network:
	
		- filter/find/identify
		- apply/combine
		- build
		- derive
		- change

