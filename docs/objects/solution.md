# Solution Object

## Attributes

  - granularity/abstraction: 
    - needs to do one specific task really well
    - needs to cover an abstract problem gap with minimal impact/side effects
    - input types & logic are abstract enough to be used in many use cases

  - implementation time: time to learn/integrate/switch

  - relationships
    - problem types matching solution or adjacent/alternative solutions

  - functions/rules

    - core functions

      - distort/standardize
      - alternate/stabilize
      - isolate/combine
      - position (arrange)
      - compress/expand
      - transform (change)
      - fit (match/contain/fill structure)
      - differentiate (key points of difference)
      - filter (find: start from everything & reduce)
      - derive (build: start from scratch & build)
      - metadata (minimum information to derive)
      - generate (using limits, interfaces, symmetries, variables)
      - map (physics of limits, combination, calculation, approximation, measurement)

    - metadata functions

      - find minimum info needed to solve problem
      - definition
      - find objects in data
      - find important objects/rules/variables/layers/systems

    - change functions

      - attribute/rule update strategy: when is solution object updated
      - maintenance rules
      - typical solution change pattern (at various levels of implementation & order/phase of problem-solving trajectory):
        1. configuration to regulate solution switching
        2. combination on top of dependencies to delegate functionality
        3. testing to capture adjacent (one-degree) functionality exploits
        4. protocols to reduce solution space vs. enforcing solution rules or reconstructing problem space & rebuilding solutions on top

    - limit functions

      - scope limit (use case, relevance, lifecycle, self-destruct triggers, context, range)
        - time limit
          - only applicable in a certain time window
        - context limit
          - structural/conceptual or specific to context
        - reusability
          - only applicable once, as with solutions that are easily identified or stop working once you use them the first time
          - how to design/choose solutions for reusability
        - cost/benefit analysis 
          - such as learning/understanding/integration/implementation/migration/functionality gap cost potential
  
      - boundary limits

      - problem-type & problem-space scope
        - only handles asymmetries or structure-fitting or optimal transport or classification

    - dependency functions

      - assumptions
        - 'assumes that similarity means relationship'
        - 'assumes value above a threshold means difference'

      - context
        - 'requires that other tests have been eliminated'
        - 'requires metric value to qualify'

      - standards
        - which standards does it implement (code conventions, protocols, design patterns)

    - automation functions


  - intents

    - granular intent:
      - 'test a metric' (where metric indicates some rule to trigger or a classification/definition)
    
    - usage intent:
      - 'assess fit of model to data'
      - 'assess appropriateness of a test or method'

  - types

    - meta solution
      - method for evaluating solutions or determining solution starting point (choose between methods in problem_solving_matching.md)
      - method for automating solutions
      - method to update solution definition metadata (a method that can add new solution type when found)

    - solution generator
      - function derivation method
      - solution selection method

    - solution framework (limits reducing solution space)

    - problem decomposer (reduces problem dimensions, matching dimensions of solution to dimensions of problem)

    - problem metadata manipulation
      - changes problem space
      - postpones solving problem
      - matching problem with other problem to neutralize both
      - problem analysis: 
        - calculating probable solution cost
        - calculating value of problem reduction vs. problem solution (vs. secondary or source problem reduction/solution)
        - learning: using understanding as an alternative to using/selecting existing tools or solving problem directly

    - solution selector
      - existing tools: as an immediate implementation option
      - transforms unsolved problem into solved problem (transforms unsolved problem like markets or energy storage or evolution into an optimization/organization problem)

    - interim solution
