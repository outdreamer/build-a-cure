# Object definitions

- this schema highlights the types & the key differentiating attributes between these objects


## Common attributes

  - core spaces: default sets or other structures where this object can occur/develop
  - core structures (points, filters, limits, boundaries)
  - core objects
  - core functions
  - minimum object identification information (identity attributes)
  - optimization
  - completeness
  - randomness
  - reusability
  - equivalence/similarity metrics
  - abstraction: abstraction level should reduce misunderstandings while optimizing reusability
  - cooperativeness: integration capacity
  - complexity: is logic available/understandable/evaluatable
  - support: does it interact with existing objects
  - modularity: is it dependent on other objects, can it be swapped out & replaced seamlessly or does it have other dependencies making replacing it a complex calculation
  - delegation/trust: what can be delegated safely to this object
  - incentives: what does this object incentivize
  - assumptions
  - limits
  - types
  - state
  - potential
    - variance
    - opportunities/gaps
    - unused paths/energy
    - adjacent states accessible with existing/available resources
  - games: 
    - a set of intents/alternatives/limits/incentives/exploits/rules/risk & a definition of distance from intent fulfillment (position), usually resulting in the resolution of a clearly optimal route
    - a game is a type of system & a mixed set, which can exist as a component of a system
    - games can have many different structures like:
      - a directed graph with a vector set representing possible agent intents/functions/resources
      - a system of nodes & links where agents need function input resources to traverse
      - a decision tree where certain tree info becomes accessible only at certain nodes (adding uncertainty/risk)
      - a set of trade options between nodes with different info change/update rules in a system to optimize a resource/trade/market metric
  - context:
    - use cases
    - extreme/edge cases
  - dependencies: required objects or alternative object sets that can build this object
  - relationships
    - adjacent/related objects of same/different type
    - problems with adjacent objects & how those problems are generated by adjacent object metadata
    - order/position in chains & networks of this type
    - interface queries that can produce this object
    - related interface objects (problems, questions, strategies, insights, perspectives, filters, intents, concepts, patterns, structures, functions, types)
  
  - automation
    - resource investment (cost/time/security of sending data in a certain format or with a certain procedure)
    - understanding of host space (are the rules clear enough that we can safely automate with little expectation of variance injection)
  
  - examples

  - problems

    - dependency

    - mismatches
      - conflicts
      - imbalances
      - inefficiencies
      - complexity
      - incorrect metric
      - misidentification
      - gaps
      - limits

    - leaks (variance, resource/info)
    - injection (assumptions/variance/control/randomness)

    - side effects: whether it's a closed system or leaks variance
      - function side effect example:
        - before execution: pre-computing
        - during: memory access/overflow
        - after: process re-starting

    - specific problems:
      - enforcement gap (should have enforced rule but didnt)
      - unintended use (involves integrated third party tech not under review)
      - malicious alternative route to get same output
      - legitimate/alternative route to get malicious output


## Common functions

  - core
    - distort/standardize
    - alternate/stabilize
    - isolate/combine
    - position (arrange)
    - compress/expand
    - transform (change)
    - fit (match/contain/fill structure)
    - differentiate (key points of difference)
    - filter (find: start from everything & reduce)
    - derive (build: start from scratch & build)
    - metadata (minimum information to derive)
    - generate (using limits, interfaces, symmetries, variables)
    - map (physics of limits, combination, calculation, approximation, measurement)

  - metadata
    - find definition
    - find objects in data
    - find important objects/rules/variables/layers/systems

  - change

  - limit

  - automation

  - dependency
    - assumption/expectation
    - context
    - standards/protocols


## Objects

- function

  - definition: a set of inputs, a list of rules or rule lists (logic tree) applied to the input set, an output set created by changes to the input set, and side effects from execution

  - attributes:
    - alignment: enforced/optional, core, required, emergent/output (built from core functions, with or without associated intent)
    - interaction: cooperative/conflicting
    - intent: generative, filtering, grouping, organization/delegation/distribution/matching/grouping/filtering, classification, differentiation/transformation
    - scope: use case, context, range, host system
    - host spaces/systems & object positions in those

  - types:
    - core functions
    - meta (rule-modification/generation rules)
    - attribute rules:
      - state
      - scope (use case, relevance, lifecycle, self-destruct triggers, context, range)
    - interaction rules:
      - competition
      - binding/combination/cooperation/sharing
      - intersection/overlap/conflict resolution rules
      - trade
      - emergence
      - interactions with unclassified objects (that arent immediately classifiable as resources or targets)
    - assessment rules:
      - metric
      - difference (divergence, measures of distance/difference/equivalence)
      - validation/testing
      - attribute testing rules:
        - enforced/unenforced 
        - position
    - processing rules:
      - change
        - update
        - distorting (gap creation, divergence)
        - maintenance
        - adjacent objects/conversion potential (what can it be transformed into using available functions)
          - transformation within type
          - transformation to other types
      - filtering
        - finding
        - identification
        - definition
        - alternative
        - organizing
        - learning
      - matching
        - fitting (path/structure derivation, path evolution in isolation & with other factors)
        - filling (gap closing, convergence)
      - application
      - derivation
      - destruction (interacts with replacement, demand assessment, testing rules)
      - enforcement/governing (monitoring, correction, enforcement)
      - neutralizing/canceling
      - stabilizing/maintenance
    - object rules:
      - variable
      - type
      - incentive
      - interface (change, intent, type, pattern, concept)
      - info (problem, strategy, insight, game, perspective)
      - uncertainty/risk/potential/prediction
      - information handling (storage, versioning, replacement, merging, monitoring, indexing, communication, interpretation, processing)
      - variance (injection, leaks, combination, replacement, causal direction)
        (how does system become overwhelmed, does it have outlets to reduce variance, does it have interfaces with other systems to delegate variance)
      - solution (variance/stressor/error detection, tracing, identification & handler)
      - structure (gap, boundary, system, limit, hub, object, link, network, filter)


- variable
  - definition: 
  - attributes:
  - rules:
  - types:

- dimension
  - definition: 
  - attributes:
  - rules:
  - types:

- type
  - definition: 
  - attributes:
  - rules:
  - types:

- system
  - definition: 
  - attributes:
  - rules:
  - types:

- filter
  - definition: 
  - attributes:
  - rules:
  - types:

- intent
  - definition: 
  - attributes:
  - rules:
  - types:

- strategy
  - definition: 
  - attributes:
  - rules:
  - types:

- insight
  - definition: 
  - attributes:
  - rules:
  - types:

- problem
  - definition: 
  - attributes:
  - rules:
  - types:

- solution
  - definition: 
  - attributes:
  - rules:
  - types:
    - solution-metadata solution: evaluating & comparing solution metadata for solution selection
    - problem-metadata solution: evaluating problem metadata to evaluate metrics like problem-solving postponement
    - generative solution: solution that generates solutions
    - solution framework: provides starting point & structures for solutions to be built in/with
    - problem decomposer: solution that reduces a problem's root causative (as opposed to just varying) parameters
    - solution automator: solution that automates solutions of a type
    - interim solution: clearly suboptimal solution while optimal alternative is built
    - solution query constructor: solution that builds new solutions out of known solution types (existing structural solutions or core functions)
    - structure-finding solution: solution that assigns a structure to information
    - structure-fitting solution: solution that matches the gaps/limits in a problem structure to neutralize them

- concept
  - definition: set of unique objects remaining once objects from other spaces have their context & contradictory attributes removed
    - example: power is the object left when objects implementing it
      - resources => energy => input => potential) have their context removed, navigating up the abstraction stack from:
        - the info layer (resources & energy), removing their contextual attributes/rules
        - to the abstract structural layer (input)
        - to the abstract layer (potential, which is a related concept of power)
      - so that the final object is defined in terms of other abstract objects on the top layer
  - attributes:
  - rules:
  - types:

- structure
  - definition: 
  - attributes:
  - rules:
  - types:

- prediction
  - definition: 
  - attributes:
  - rules:
  - types:

- cause
  - definition: 
  - attributes:
  - rules:
  - types: